 Bueno, continuamos entonces con el bloque A. Del primer día de charlas de la Python es 2021. La siguiente charla se titula introducción de los algoritmos bio inspirados con Python. Vamos a ver si luego vamos a contar con Andrea Morales y Antonio Manjavacas para un poquito de la discusión. En caso contrario les invito a que se unan a Discord para que podamos continuar y hacer las preguntas por el canal de la charla. Muy buenos días somos Andrea Morales Garzón y Antonio Manjavacas Lucas y para nosotros es un verdadero placer formar parte de esta nueva edición de Python Spain y que mejor manera de hacerlo que con una introducción a los algoritmos bio inspirados con Python. Pero qué son los algoritmos bio inspirados? Bien todos sabemos lo que es un algoritmo y sabemos cómo programar decenas de ellos. Pero a qué nos referimos con bio inspirados? Es una palabra que nos sustita muchas dudas y que trataremos de dar respuesta a lo largo de esta presentación. Los algoritmos bio inspirados son algoritmos inspirados en el funcionamiento de sistemas naturales que modelan de forma aproximada fenómenos existentes en la naturaleza. Estos permitan resolver problemas de gran complejidad computacional. Por ejemplo, problemas de optimización basados en la búsqueda de la solución óptima con problemas o problemas orientados a maximizar beneficios, minimizar costes, riesgos, recursos, tiempo. Hablamos incluso de problemas multi-objetivos donde la solución que tratamos de aportar es una solución de compromiso entre diferentes objetivos que incluso en ocasiones pueden contradecirse. La cantidad de aplicaciones que tienen los algoritmos bio inspirados es enorme, desde el cálculo de rutas mínimas entre dos puntos hasta el enrutamiento de redes de comunicaciones y vehículos, agótica, aprendizaje automático y predicción, medicina, incluso simulación de sistemas naturales, algoritmos inspirados que han sido utilizados para predecir la propagación de incendios forestales, el comportamiento de ciertas reacciones químicas o incluso la interacción entre partículas, como es el caso del CERN, donde se han utilizado este tipo de algoritmos. A continuación, mi compañera Andrea nos mostrará un problema muy pequeño y que nos permitirá entender de una forma sencilla el dominio de aplicación de este tipo de algoritmos. Vale, pues a lo largo de estas llanas vamos a utilizar como guía el problema de la mochila, que es un problema sencillo de entender y que se puede resolver con algoritmos bio inspirados y que lo utilizaremos como base en distintos puntos que veremos a continuación. Entonces este problema parte de una mochila y de un conjunto de objetos. La mochila tiene una capacidad máxima que no se puede superar y los otros tienen distintos pesos y valor. Entonces buscamos una combinación de objetos que nos permita maximizar la ganancia sin superar el peso máximo que tiene la mochila. Entonces a simple vista, tal y como podemos ver, incluso podemos intuir cuál es la combinación que nos permitiría obtener la cantidad de euros máxima, pero tenemos que pensar que muchas veces no tenemos 10 o 12 objetos, tenemos una gran cantidad de objetos y que esto da lugar a un problema combinatorio complejo que no es sencillo de resolver. La siguiente diapositiva, podemos ver la solución propia a este problema. Realmente con esta combinación llegamos al peso tópez de la mochila y conseguimos la capacidad máxima, o sea, perdón, la cantidad monetaria máxima que conseguiríamos con estos objetos. Sin embargo, con el mismo peso máximo que ocupa la mochila, otra vez 16 kilogramos, también podemos obtener otras soluciones que no son la óptima. Entonces, esto representa un poco la naturaleza que tienen todos estos problemas que se utilizan dentro del ámbito de los algoritmos bien inspirados. En la siguiente diapositiva podemos ver otro problema también muy conocido y que también se puede resolver por medio de este tipo de algoritmos que es el problema del viajante de comercio. En este problema partimos de que tenemos una cantidad de ciudades con unas conexiones entre ellas. Esto se representa con un grafo como el que podemos ver en la diapositiva. Y las conexiones que existen entre las distintas ciudades tienen un coche que puede ser mayor o menor. Aquí se puede intuir por la longitud de las aristas que uno es los propios nodos. Entonces, aquí lo que se busca es ser capaz de recorrer todas las ciudades o nodos intentando invertir el coste mínimo para ello. Es de nuevo otro problema de optimización, también combinatorio, y que se puede complicar cuando el número de nodos es muy grande. Este problema es un problema de NPE, que con NPE nos referimos a una clase de complejidad que contiene todas aquellas problemas que no se resuelven en un tiempo polinómico. Entonces, al final lo que buscamos son aproximaciones por lo más cercanas posible al óptimo real. Los algoritmos bioinspirados, al final son algoritmos iterativos que permiten explorar en un espacio de búsqueda e intentar alcanzar estos óptimos. Y, por tanto, son algoritmos que nos permiten hacer frente a estos problemas. Esos son algoritmos que están dentro de las metaurísticas y en esta figura podemos ver como un breve esquema de todo lo que se involucra en este área de la computación. Podemos ver que dentro de las metaurísticas, que existen problemas basados en poblaciones y en otras redes de historia, pues entra los algoritmos bioinspirados. Y muchos de los que aparecen hay, como por ejemplo, los algoritmos genéticos o los pasados en las colonias de hormigas, pues los veremos posteriormente con la librería que vamos a explicar en esta en esta charla. Esta librería se llama SPILE y es una librería que se centra en la implementación de algoritmos bioinspirados en países. Estos algoritmos, tal y como sigue la filosofía de esta librería, tienen dos características perdón que sí o sí son dependentes del problema. Una de ellas es la representación de la solución. Aquí por solución lo que se entiende es cómo representamos una posible solución a nuestro problema, es decir, cómo la representamos computacionalmente para poder obtenerla. Y la otra característica es la evaluación. Una vez que tenemos representada las posibles soluciones necesitamos una forma de evaluarla para poder definir cuál es mejor o cuál es peor para intentar alcanzar el óptimo local. Y luego parte de características que dependen del algoritmo, que aquí ya entran, pues si es algoritmo basado en poblaciones, si es basado en trayectoria, pues siempre hay como unos métodos comunes o por ejemplo, cómo almacenar las soluciones independientemente del algoritmo, pues todas estas características también están traídas dentro de la propia librería. Al final, el objetivo que tiene es separar los componentes que son específicos del problema en cuestión de los que son más concretos del algoritmo para facilitar el trabajo a la hora de programarlo. Cuando hablamos de solución, como he dicho anteriormente, al final la representación que nosotros damos o con la que trabajamos para intentar alcanzar el óptimo el problema. Entonces aquí vamos a ver un ejemplo de solución para hacernos una idea más clara de a qué nos referimos exactamente con solución y volvemos al problema de la mochila. En este caso, la solución que nosotros buscamos es cuáles son los objetos que me llevan a llevar al óptimo en función de la capacidad que tenga la mochila. Pues esto se podría representar como un vector binario donde hay tanto alimento como objetos y el uno puede representar que ese objeto lo incluimos y el cero que no. En esto da lugar una explosión combinatoria de todas las posibilidades que se pueda andar para intentar alcanzar el óptimo. Esto obviamente no es la única solución que se podría dar. Nosotros podríamos haber elegido, por ejemplo, una tubla de elemento con el coche o alguna otra representación. Al final que hay que jugar un poco, pues con lo que sea más sencillo y también más eficiente computacionalmente. Entonces, volviendo a la librería, una vez que ya tenemos definido y tenemos claro lo que son las soluciones, pues ya podemos partir a los componentes específicos del problema que realmente son los que están basados en ellas. Por una parte tenemos la función generator y esta función pues nos va a permitir a nosotros crear nuestra propia solución con las características que queramos y como nosotros queramos diseñarlas. Por otra parte tenemos el otro componente clave, el evaluator, que nos va a permitir evaluar la solución generada. ¿Cuál sería la función de evaluación del problema de la mochila? Pues ver cuál es la cantidad de euros máximo que conseguimos con una selección concreta de los objetos. Y luego, por otra parte, pues tendríamos los componentes que dependen del algoritmo, que ya hemos comentado son más de implementación ya de características de algoritmo, bioaspirados, por ejemplo. ¿Cómo generar nuevas poblaciones? Pues hay un componente específico que nos permitan lidiar con este tipo de acciones. Visto de forma genérica, aunque consiste a InspireZ y cuál es su metodología de programación, veamos a continuación que algoritmos están disponibles en esta librería y cómo es su funcionamiento. Los primeros algoritmos bioespirados, que se nos pueden venir a la cabeza, son los algoritmos genéticos, seguramente los más famosos, que replican el proceso de evolución natural propuesto por Darwin. Están basados en hacer evolucionar poblaciones de soluciones hacia valores óptimos del problema. Recordemos que los problemas de esta naturaleza y que abordamos con algoritmos bioespirados parten de un conjunto de soluciones que se van mejorando de forma iterativa. Los algoritmos genéticos cuentan con una serie de operadores y elementos a tener en cuenta, como la población de soluciones, la función de evaluación o fíndez, que nos va a decir cómo de buena o mala es una solución, la operación de cruce que combina diferentes soluciones para dar lugar a una nueva y la mutación que se produce de forma aleatoria y altera de forma parcial, incluso mínima, una solución. Por ejemplo, para el problema de la mochila, su resolución con un algoritmo genético podría ser de la siguiente forma. Al final cada iteración parte de una población de la cual se seleccionan diferentes individuos, en este caso dos, que se cruzan, como podemos ver en la operación de cruce, y con cierta probabilidad esos cruces mutan en un nuevo elemento, en una nueva solución que reemplaza a la peor de la población existente, de forma cíclica y dando suficiente tiempo, el algoritmo convergerá en la solución óptima. Las bajos niveles, si nos centramos en el código necesario para implementar un algoritmo genético, podemos utilizar la clase evolucionaria y computación, que instancia un problema evolutivo y hasta cualquier tipo de algoritmo evolutivo. Tras instanciar el problema evolutivo, lo que hacemos es definir los diferentes elementos que lo componen, peorador de selección, cruce, reemplazo y terminación, definir la función que implementa el algoritmo genético y simplemente obtener la solución. En este caso, para el problema con elementos duplicados son multiplicados. Sin embargo, si lo que buscamos es una implementación mucho más simple y nuestro problema no es muy complejo, podemos utilizar directamente las clases que vienen implementadas por el SPYLEAD y que funcionan muy bien. Por ejemplo, en este caso, tenemos un diseño simplificado utilizando la clase genética algoritmo GAO y la misma filosofía se da para el resto de algoritmos. Una vez hemos visto que consiste el código su yacente a este tipo de algoritmos, podemos ver sus aplicaciones. Por ejemplo, aquí tenemos una serie de robots que han sido entrenados para andar y que a medida que avanzan las generaciones, su aprendizaje converge en una forma de caminar óptima, como es el caso de la generación 999. Veamos otra serie de algoritmos evolutivos. Por ejemplo, las estrategias evolutivas. Este tipo de algoritmos se utiliza en otros problemas de diferente naturaleza donde la solución codificada no es binaria, sino que se codifica por medio de valores reales. En este caso, no hay un operador de mutación como el que hemos visto antes, sino más bien un operador de mutación que añade valores a los parámetros siguiendo una distribución normal multivariante. Otro algoritmo de la misma naturaleza es enfriamiento simulado, bastante conocido, que consiste en un algoritmo de búsqueda local que parte de una serie de soluciones parciales explora soluciones vecinas y se va moviendo dentro de espacio de búsqueda hasta caer en óptimos locales. Para evitar caer en óptimos locales de forma permanente, lo que hace este algoritmo es permitir con cierta probabilidad de creciente en el tiempo que puedan transicionarse hacia soluciones peores de forma contraria. De esta forma garantizamos que se logre explorar todo el espacio de búsqueda y al final logremos converger en la solución óptima global. Por ejemplo, aquí podemos ver como a medida que la temperatura o tiempo disminuye, es decir convergencero, se alcanza en lo óptimo global. La evolución diferencial es otro algoritmo de la misma naturaleza que en este caso cuenta con una serie de vectores solución formados por números reales, la optimización se lleva a cabo en base a una métrica de calidad y contamos con una serie de vectores de prueba que compiten con individuos de la población actual buscando su superinvención. Por ejemplo, la evolución diferencial se utiliza para aproximar funciones, lo que vemos es que a lo largo de las iteraciones los individuos convergen en la función que define a la nube de puntos. De forma muy similar tenemos estimación de la distribución que estima de forma evolutiva la distribución de probabilidad de cada variable que compone la solución. No se emplea ni cruce ni mutación, sino que la población se actualiza modificando las distribuciones de probabilidad obtenidas y de forma iterativa la distribución se concentra en torno a la solución óptima. Vamos ahora con otro tipo de algoritmos, en este caso hablamos de optimización multi-objetivo. Los problemas multi-objetivos son aquellos donde se pretende encontrar una o más soluciones óptimas bajo una toma de decisiones multicriténeos. Por ejemplo, un problema multi-objetivo es cuántos vehículos deben conformar la flota de una empresa de transporte. En este caso, utilizando paes, lo que buscamos es maximizar el beneficio y crecimiento y minimizar los gastos, ya sea de combustible o reparación. Al final lo que buscamos es un óptimo de pareto, una solución es pareto óptima cuando no existe otra solución que mejora un objetivo sin empeorar el otro. Y decimos que una solución domina otra si es mejor. Esto nos sirve muy bien para abordar el siguiente algoritmo, NSGA, que también es evolutivo, elitista y multi-objetivo. Nos permite la preservación y evolución de soluciones pareto óptimas y está basado en la ordenación de la población empleando fronteras de no dominación. Básicamente el funcionamiento es el siguiente. Tenemos una población dividida en padres y descendientes obtenidos de esos padres. La población se ordena por dominancia y a partir de un determinado docente, esa población se poda y contamos con un frente no dominado, una serie de frente no dominados que pasan a formar parte de la siguiente iteración. Aquí podemos ver, por ejemplo, cómo se encuentra ese frente de pareto de forma evolutiva. Finalmente, vamos a ver otra serie de algoritmos muy interesantes, que son los pasados en enjambres, por ejemplo, enjambres de partículas o Particles of Optimization. Este tipo de algoritmos está basado en el comportamiento de las partículas en la naturaleza y la inteligencia de enjambro, bandadas de llaves, bancos de peces y permiten optimizar un problema partiendo de un conjunto de soluciones candidatas, que son las partículas que se mueven por todo el espacio de búsqueda. Este movimiento viene determinado por la posición y la velocidad de las partículas. El movimiento dependerá no sólo de la mejor posición local encontrada por cada partícula, sino de las mejores posiciones globales del resto del enjambro. Es algo similar a lo que podemos ver en la imagen. Por ejemplo, aquí podemos ver su aplicación, como puede ser en un defenso del gradiente o cualquier tipo de operación que suponga moverse por un espacio continuo. Y finalmente llegamos a los algoritmos de colonias de hormigas. Estos algoritmos son muy famosos y normalmente se destinan a buscar el camino óptimo en un grafo basándose en cómo las hormigas buscan alimento, liberan feromonas y lo llevan a la colonia. Dicho comportamiento está basado en la liberación, seguimiento y evaporación de los rastros de feromonas, como veremos a continuación. Básicamente, el funcionalamiento es el siguiente. Una hormiga parte de la colonia y se desplace hacia el alimento o realiza una trayectoria aleatoria que le lleva hasta él. Finalmente, una vez lo alcanza, lo que hace es volver a la colonia y transportar ese alimento a la vez que libera feromonas. A medida que ese camino se vuelve más viable porque es recorrido por más hormigas, el rastro de feromonas aumenta y la mayoría de las hormigas lo sigue consolidando esa ruta. También es importante decir que los rastros de feromonas se evaporan con el tiempo, lo que evita la convergencia en óptimos locales. Como podemos ver, la idea suya acente simula el comportamiento de las hormigas en el contexto de un grafo, como puede ser, por ejemplo, el del viaje entre el comercio que mencionábamos al principio de esta charla. Y como breve, al final, pues lo que lo hemos inspirado al final nos permiten, pues, aproximar problemas muy complejos, porque tal y como ha estado comentando Antonio, al final esto resulta en una exploración bastante sensada de todo el espacio de búsqueda, dando lugar a múltiples comidas que nos permitan con cierta inteligencia y hacia óptimos locales o incluso globales. Y con esta librería podemos atraer este concepto de algoritmo bio inspirado, porque tal y como también ha estado comentando Antonio, pues al final existen poblaciones, esas poblaciones pues evolucionan, se evaluan, hay pequeñas mutaciones, hay pequeñas variaciones, todas estas funcionan, al final son las que atraemos, las que podemos utilizar o incluso modificar o adecuar a nuestras necesidades dotando de una gran flexibilidad a la hora de poder resolver un problema completo, complejo, perdón. Y esto es todo, esperamos que os haya gustado y si tenéis cualquier duda pues estamos a vuestra disposición. Aquí hemos dejado también una pequeña referencia de todo lo que hemos utilizado y eso sería todo. Muchas gracias. Muchas gracias.

