1
00:00:00,000 --> 00:00:13,840
Bueno, nosotros cuando hablábamos de quién sería el keynote speaker, los keynote speakers

2
00:00:13,840 --> 00:00:20,000
dudábamos, traemos a alguien de fuera, pedimos a alguien de dentro y surgió de manera bastante

3
00:00:20,000 --> 00:00:26,400
orgánica que para que vamos a llamar a nadie fuera se tenemos gurús en casa que nos reconocemos

4
00:00:26,400 --> 00:00:36,240
pero son espectaculares. Bueno, ayer hablan de Victor, Victor es un chico muy majo, majerrimo

5
00:00:36,240 --> 00:00:43,600
diría yo. A mí, un día me dijo yo odio los ponentes a burri, dije, ole tú, que guay.

6
00:00:43,600 --> 00:00:48,360
Y bueno, además tiene muy poquita batería en el portátil así que…

7
00:00:48,360 --> 00:00:53,680
¿Se acabó ya? No, todavía no. Casi, casi, estamos ahí.

8
00:00:53,680 --> 00:01:01,360
Victor era un perfecto señor Andaluz y ahora es un perfecto yantenman londinense y nada,

9
00:01:01,360 --> 00:01:03,680
no me enrollo más, os dejo con el perfecto yantenman.

10
00:01:03,680 --> 00:01:06,680
Muchas gracias, May.

11
00:01:06,680 --> 00:01:18,480
Hola, estaba pensando que iba a decir cuando May me pasara la palabra y voy a decir esto.

12
00:01:18,480 --> 00:01:22,320
Estoy muy contento de que se me ofreciera a dar la charla porque creo que va a ser la

13
00:01:22,320 --> 00:01:30,520
última que de nunca porque conducen por la izquierda en Iloberra.

14
00:01:30,520 --> 00:01:35,400
No pienso conducir pero sé que voy a morir atropellado. De hecho, está tan mal que

15
00:01:35,400 --> 00:01:41,120
tienen señales en el suelo, se ve ido a Londra y pone, mira para otro lado. Casi me ha pillado

16
00:01:41,120 --> 00:01:45,500
autobús y sé que lo peor es que cuando, si no muero ahora, cuando aprenda a mirar

17
00:01:45,500 --> 00:01:51,160
hacia el otro lado, cuando venga en Navidad, me atropellarán por la derecha.

18
00:01:51,160 --> 00:01:57,000
Bueno, Londres. Me gustó una cosa que dijo Yami, que dijo hay que contar una historia

19
00:01:57,000 --> 00:02:04,440
y yo tengo una para empezar. Sí, funcionará. Un segundo, un segundo, voy a hacer clic

20
00:02:04,440 --> 00:02:18,720
aquí. No, no funciona. Un segundo. No me ha dado. Yo quería empezar con el país

21
00:02:18,720 --> 00:02:23,680
Kung Fu. Si alguien ha seguido un poco la actividad de país on-granada empezó con la idea de

22
00:02:23,680 --> 00:02:29,560
lanzar pequeños ejercicios y que la gente lo resuelva. Son una excusa para aprender

23
00:02:29,560 --> 00:02:34,640
un poco. Como todavía somos no demasiado y podemos permitirnos que cuando la gente envía

24
00:02:34,640 --> 00:02:39,200
una respuesta, puede decir no, si no, algo de otra forma. La idea es que sea una excusa

25
00:02:39,200 --> 00:02:44,120
para que la gente aprenda. Si lo llamas Kung Fu, cuando lo llamas algoritmica, la gente

26
00:02:44,120 --> 00:02:50,080
participa y hay que poner imágenes de ninjas, de explosiones. Y esto fue de hecho la primera.

27
00:02:50,080 --> 00:02:55,600
Y es una pregunta que se hace, no sé si me oye bien, en entrevistas de trabajo. Muy

28
00:02:55,600 --> 00:03:01,560
habitual. Hay alguna que otra guía de entrevistas de trabajo, cómo preparártelas. Y suele

29
00:03:01,560 --> 00:03:05,840
estar en el primer capítulo. Y es, si te doy una cadena de texto, ¿cómo determinas

30
00:03:05,840 --> 00:03:12,400
que una es una premutación de otra? Por ejemplo, amor y Roma son una premutación una de otra.

31
00:03:12,400 --> 00:03:18,840
Son las mismas letras desordenadas. No, que no funciona. Sí, sí, funciona. Y esto es

32
00:03:18,840 --> 00:03:25,200
lo principal. He visto cosas que no queréis. Pero no porque no funcionen, porque de hecho,

33
00:03:25,200 --> 00:03:30,480
como la si lo miráis en GitHub, tenemos pruebas de unidad y entonces la gente, al menos cuando

34
00:03:30,480 --> 00:03:35,200
manda el código sabe que funciona. Hay algo que es lo que me atormenta siempre y es que

35
00:03:35,200 --> 00:03:42,000
hay una tendencia a complicarnos demasiado, muchísimo. Pasen todas partes. Por ejemplo,

36
00:03:42,000 --> 00:03:46,320
tuvimos una persona y funcionaba la solución que envió y era, bueno, quiero comparar si

37
00:03:46,320 --> 00:03:53,320
la cadena es igual a la otra. ¿Cómo compruebo si dos cadenas son iguales? Pues calculaba

38
00:03:53,320 --> 00:03:59,120
el hash de ambas cadenas. Y decía, bueno, el hash es igual, luego las cadenas son iguales.

39
00:03:59,120 --> 00:04:06,080
Sí. Cierto, es cierto. He dicho, pero se puede hacer mucho más sencillo. Y esta es

40
00:04:06,080 --> 00:04:11,880
una de las soluciones que vemos. Muy habitual. La gente manda muchas respuestas y esta es

41
00:04:11,880 --> 00:04:16,760
una muy habitual. Que dicen, bueno, voy a recorrer todas las letras de la palabra y para

42
00:04:16,760 --> 00:04:21,280
cada una de las letras que me encuentre, me voy a la otra palabra, cuento cuántas veces

43
00:04:21,280 --> 00:04:25,640
aparece y bueno, en esencia, si todas las letras aparecen el mismo número de veces en

44
00:04:25,640 --> 00:04:30,960
las dos palabras, es que es una premutación. Roma y amor, las dos tienen una vez una R,

45
00:04:30,960 --> 00:04:36,480
una O, una M y una A. Luego puedo afirmar, es una premutación. Y la gente lo hace, funciona,

46
00:04:36,480 --> 00:04:43,320
compila, pasan las pruebas, enviar. Pero aquí es cuando nos empezamos a dar cuenta. Hay

47
00:04:43,320 --> 00:04:47,640
una cosa muy fundamental que mucha gente no conoce. Y como puede que haya alguna persona

48
00:04:47,640 --> 00:04:51,920
aquí que no la conozca, vamos a hacer una pequeña introducción. Es la notación Big

49
00:04:51,920 --> 00:04:58,600
O, que es como analizamos la complejidad de los algoritmos. Básicamente lo que nos importa

50
00:04:58,600 --> 00:05:03,000
cuando analizamos un algoritmo es cuánto tarda en ejecutarse y cuánta memoria requiere.

51
00:05:03,000 --> 00:05:07,280
De hecho poniéndonos a estrictos, y esto me regañó un amigo de bajo nivel, no es tiempo,

52
00:05:07,280 --> 00:05:12,360
es instrucciones. Pero bueno, como al final acabo podemos hacer un número finito de instrucciones

53
00:05:12,360 --> 00:05:17,920
por unidad de tiempo, podemos hablar que instrucciones va a tener una proporcionalidad con tiempo.

54
00:05:17,920 --> 00:05:23,080
En resumen, cuánto tarda el algoritmo en ejecutarse. Y esto de hecho es intuitivo,

55
00:05:23,080 --> 00:05:29,240
no es lo mismo ordenar una lista de 100 elementos que de 100 millones. Sabemos que va a tardar

56
00:05:29,240 --> 00:05:33,520
más una que otra, por ejemplo, más grande. Del mismo modo, la memoria, no es lo mismo

57
00:05:33,520 --> 00:05:38,240
almacenar una matriz pequeñita en memoria que almacenar una gigante tridimensional.

58
00:05:38,240 --> 00:05:42,920
Hasta ahí bien, algo que llevamos a confusión, muchas veces que cuando decimos cuánto tiempo,

59
00:05:42,920 --> 00:05:46,880
cuál es la complejidad en tiempo y en memoria de tu solución, mucha gente dice, lo hacen

60
00:05:46,880 --> 00:05:52,960
mucho, en mi ordenador tarda 5 milisegundos. Ya. Pero es que realmente no nos importa en

61
00:05:52,960 --> 00:05:58,280
términos absolutos, toda la historia de la notación Big O lo que busca es responder una

62
00:05:58,280 --> 00:06:04,200
respuesta fundamental que es a qué es proporcional el tiempo que tarda en ejecutarse tu algoritmo

63
00:06:04,200 --> 00:06:13,240
en función de la entrada. Y cuánta memoria requiero, cómo quiere en proporción. Porque

64
00:06:13,240 --> 00:06:18,440
el algoritmo importa. Es decir, si sabemos que Quick Sort es un algoritmo muy bueno para

65
00:06:18,440 --> 00:06:25,800
ordenar. ¿Alguien sabe cómo es que algoritmo utiliza Python? Gracias. Exactamente. Que no

66
00:06:25,800 --> 00:06:30,120
una variación de Quick Sort, no, creo que es del Merch Sort y que funciona muy bien. Sabemos

67
00:06:30,120 --> 00:06:35,400
que ese algoritmo es mucho mejor que el del Bubble Sort o otros que son mucho más ineficiente.

68
00:06:35,400 --> 00:06:39,280
Así que sabemos que el algoritmo importa y es muy importante. Y podríamos estar tentados

69
00:06:39,280 --> 00:06:45,120
de decir, bueno, pues simplemente mi algoritmo es muy malo, pues arrojo un par de súper ordenadores.

70
00:06:45,120 --> 00:06:50,360
Pero el problema es que si tu solución escala mucho, si tu requerimiento de tiempo y memoria

71
00:06:50,360 --> 00:06:54,760
crecen mucho más rápido de lo que tú puedes arrojar en hardware, llega a un punto en el

72
00:06:54,760 --> 00:06:59,400
cual no vas a poder solucionar el problema. Se convierte en intratable. Y bueno, podemos

73
00:06:59,400 --> 00:07:03,760
ver algún ejemplo. Hay operaciones que tienen un tiempo constante. Por ejemplo, si yo tengo

74
00:07:03,760 --> 00:07:08,400
una cadena de texto y quiero decirle, muy bien, vete a la cadena de letras y dame el elemento

75
00:07:08,400 --> 00:07:13,440
que está en la posición de índice 5, que es la que está en el sexto, pues Python simplemente

76
00:07:13,440 --> 00:07:17,680
se va, accede a esa posición y me dice, muy bien, es una F. Del mismo modo, si queremos

77
00:07:17,680 --> 00:07:21,720
ver la longitud de la cadena, hay quien podría creer que Python va a recorrerse la cadena

78
00:07:21,720 --> 00:07:25,320
contando cuántos caracteres hay, realmente a nivel interno, llevamos la cuenta de cuántos

79
00:07:25,320 --> 00:07:31,440
elementos hay. Ambas operaciones son constantes. Da igual la longitud de la cadena va a tardar

80
00:07:31,440 --> 00:07:35,320
siempre lo mismo. Esto es lo que se llama constante. Y en notación es O1.

81
00:07:35,320 --> 00:07:41,680
En mismo modo, tenemos otras que son lineales. Si, por ejemplo, tengo una cadena de texto

82
00:07:41,680 --> 00:07:47,560
y quiero contar la ocurrencia de una palabra, por ejemplo, aquí, E, pues tengo que recorrerme

83
00:07:47,560 --> 00:07:53,240
inevitablemente toda la cadena y ver cuántos elementos hay. O si quiero elevar al cuadrado

84
00:07:53,240 --> 00:07:57,240
todos los elementos de una lista, sabemos que el tamaño de la lista importa. Esto es

85
00:07:57,240 --> 00:08:01,040
lo que se llama lineal. Y esto se lo ponemos en notación, en sí, en matemática muy formal,

86
00:08:01,040 --> 00:08:06,040
ponemos O, DN, cuando quieres hacerte el listo, y esto es lo que quiere decir, es que mi algoritmo

87
00:08:06,040 --> 00:08:10,800
tiene unos requerimientos que aquí, para simplificar, solamente estamos considerando el tiempo de

88
00:08:10,800 --> 00:08:16,080
ejecución, por simplificar, esto es lineal, escala con el proporcionalmente al número

89
00:08:16,080 --> 00:08:20,240
de elementos. Del mismo modo, hay cosas que son cuadráticas. Si yo tengo una serie de

90
00:08:20,240 --> 00:08:24,320
números y quiero calcular todas las parejas posibles, por ejemplo, hay un ejemplo de libro

91
00:08:24,320 --> 00:08:27,960
que es de parejas de baile. Todo el mundo baila con todo el mundo en esta fiesta. Pues

92
00:08:27,960 --> 00:08:32,160
bueno, aquí, si quisiéramos hacer el producto de todos los elementos con todos los elementos,

93
00:08:32,160 --> 00:08:36,920
eso es cuadrático. Va a crecer con el cuadrado del número de entrada. Hay un montón. Por

94
00:08:36,920 --> 00:08:42,000
ejemplo, os digamos que generar números de Fibonacci. Y entonces lo que vamos a hacer

95
00:08:42,000 --> 00:08:46,400
es, bueno, pues, tengo que, claro, como cada número de Fibonacci en la secuencia se define

96
00:08:46,400 --> 00:08:51,120
en función de los dos anteriores, hay que hacer recursión, y esto resulta que en sus

97
00:08:51,120 --> 00:08:55,560
implementaciones más sencillas, más ingenuas, esto es dos elevados a n, que de hecho es

98
00:08:55,560 --> 00:09:00,000
muy, muy, muy malo. También hay cosas, bueno, siempre estoy poniendo acaso que van a peor,

99
00:09:00,000 --> 00:09:02,880
pero también hay cosas que son buenas. Por ejemplo, la búsqueda binaria. La búsqueda

100
00:09:02,880 --> 00:09:06,560
binaria es cuando, si tenemos una secuencia ordenada, en cada paso lo que puedo seguirme

101
00:09:06,560 --> 00:09:11,400
a la mitad. Por ejemplo, como buscamos un número, cuando había listires telefónicos,

102
00:09:11,400 --> 00:09:15,120
buscaba un número. No, no, que te iba a la M, no, está antes de la M, me puedo venir

103
00:09:15,120 --> 00:09:19,440
aquí. Eso a cada paso descarto a la mitad de los elementos. Eso es lo que se conoce

104
00:09:19,440 --> 00:09:25,040
como tiempo logarítmico. Y bueno, hay muchas categorías más. Esta gráfica es fundamental.

105
00:09:25,040 --> 00:09:30,080
Y de hecho es horrible pensar que hay gente que programa sin tenerla muy presente. La

106
00:09:30,080 --> 00:09:34,880
complejidad de tu algoritmo importa un montón. Cuando me ha hecho una solución ineficiente,

107
00:09:34,880 --> 00:09:38,400
pequeñita, bueno, en un caso pequeñito, pues funciona, pero es que te puedes morder

108
00:09:38,400 --> 00:09:44,280
si no mucho después. La categoría de las de arriba son muy malas. Los tiempos exponenciales

109
00:09:44,280 --> 00:09:51,920
son realmente, realmente terribles. Y una cosa, ¿alguien reconoce esta escena? Totalmente

110
00:09:51,920 --> 00:09:56,440
maravillosa. En la cual sé que hay muchos matemáticos en la sala. Yo sé que los matemáticos

111
00:09:56,440 --> 00:10:04,360
al ver esta película se sienten como los informáticos cuando ven esta escena de CSI.

112
00:10:04,360 --> 00:10:08,600
Voy a programar una interfaz gráfica en Visual Basic para encontrar la IP del asesino. ¿Habéis

113
00:10:08,600 --> 00:10:13,360
visto eso? Bueno, pues un matemático se siente igual, porque en esta película y en Fian

114
00:10:13,360 --> 00:10:18,200
tenemos un supercifrado ruso. Matemático haga algo y el dice trae uno, ocho, cuatro

115
00:10:18,200 --> 00:10:25,360
y sacaba la clave. Y recuerdo haber, hace muchos años, visto matemáticos que se enfadaban

116
00:10:25,360 --> 00:10:29,160
un montón con la película. Pues bueno, se sienten igual que nosotros con otras. Y esta

117
00:10:29,160 --> 00:10:32,920
era mi imagen para introducir que realmente las reglas de operaciones con las complejidades

118
00:10:32,920 --> 00:10:37,360
son el sueño dorado de toda la gente que creíamos que se nos daban más las matemáticas. De

119
00:10:37,360 --> 00:10:40,520
hecho, en realidad no eran nosotros, era el profesor. Porque es siempre que te lo explican

120
00:10:40,520 --> 00:10:46,120
mal, ¿no tú? Porque son las reglas más sencillas del mundo. De hecho, en cuanto al grado nos

121
00:10:46,120 --> 00:10:50,560
quedamos con el monomio, que es el término más formal que he podido encontrar, de mayor

122
00:10:50,560 --> 00:10:57,960
grado, donde monomio significa, amigos matemáticos, cacho. Aquí tenemos un cacho que es N cuadrado,

123
00:10:57,960 --> 00:11:01,640
otro que N y otro que es lo grimo de N. Pues como el cacho más grande es N cuadrado, cuando

124
00:11:01,640 --> 00:11:05,840
tenemos un algoritmo que tiene esa complejidad, se simplifica. Este algoritmo de arriba se

125
00:11:05,840 --> 00:11:09,960
simplifica y se dice la complejidad es N cuadrado. ¿Por qué? Porque lo que predomina,

126
00:11:09,960 --> 00:11:15,400
cuando nos acercamos al infinito, realmente es el cuadrado, para valores grandes. Y de

127
00:11:15,400 --> 00:11:19,160
la misma forma podemos eliminar a los coeficientes, porque son solamente una constante. Entonces

128
00:11:19,160 --> 00:11:24,320
se considera que pertenecen a la misma categoría, que esto es aún más intuitivo. Infinito,

129
00:11:24,320 --> 00:11:31,960
y cinco veces infinito es un montón. Así que se puede decir, oh, le va a 2N. Y es fantástico.

130
00:11:31,960 --> 00:11:36,480
Teniendo eso presente, podemos volver al kung fu. Lo mejor de todos, por cierto, es que

131
00:11:36,480 --> 00:11:41,800
ponemos el país de un kung fu y las imágenes nunca son de kung fu. Que eso a la gente que

132
00:11:41,800 --> 00:11:48,840
sabe algo de cultura de esa parte del mundo es también terrible, nunca es kung fu. ¿Cómo

133
00:11:48,840 --> 00:11:52,680
determinamos una cadena o una permutación de otra? Y entonces pues, volvemos a la solución

134
00:11:52,680 --> 00:12:01,120
que se ve un montón. Y es esta. ¿Cuál es la complejidad de este algoritmo? Exactamente.

135
00:12:01,120 --> 00:12:08,800
La complejidad es cuadrática. Y bueno, funciona, pero toda la idea del país de un kung fu

136
00:12:08,800 --> 00:12:14,480
era que pudiéramos aprender. Entonces hay una variante que funciona muy bien y es mucho,

137
00:12:14,480 --> 00:12:18,120
mucho mejor. Y es que lo que decimos es bueno, en vez de para cada una de las letras nos

138
00:12:18,120 --> 00:12:21,360
recorremos toda la cadena y entonces vemos cuántas letras hay, vamos a hacer una cosa,

139
00:12:21,360 --> 00:12:25,480
que no las contamos solamente una vez cada letra. Entonces lo que hago es muy bien. Voy

140
00:12:25,480 --> 00:12:29,160
a crearme un contador o un diccionario en otras lenguajes conocidos como un tablajas

141
00:12:29,160 --> 00:12:32,760
y lo que voy a hacer es muy bien, voy a recorrerme la palabra y entonces cada vez que me encuentre

142
00:12:32,760 --> 00:12:36,360
una letra voy a decir muy bien, pues incrementa su contador en uno. Ahora como en un diccionario

143
00:12:36,360 --> 00:12:40,080
en país, tenemos que decir, oh, pero es que si intentamos incrementar en uno el contador

144
00:12:40,080 --> 00:12:43,880
de la palabra e que todavía no lo he visto me va a dar un cierro. Entonces tengo que

145
00:12:43,880 --> 00:12:48,480
asignarlo a uno. Y en caso de que si es 3, posiblemente lo incremento. Y luego lo hago

146
00:12:48,480 --> 00:12:53,640
a otro para la otra palabra y las comparo. Si las palabras son una premutación una de

147
00:12:53,640 --> 00:12:58,640
la otra, los contadores, los diccionarios serán iguales. Cual es la complejidad de

148
00:12:58,640 --> 00:13:03,320
esto? Lineal, porque eso lo tengo que recorrerme las cadenas una vez y voy creando el diccionario.

149
00:13:03,320 --> 00:13:10,200
Yo también. Hay una página web la cual buscan imágenes de película y reemplazan las pistolas

150
00:13:10,200 --> 00:13:18,640
por, ok, hay un montón. Pero hacer eso es muy aburrido porque eso de oh, tengo que crear

151
00:13:18,640 --> 00:13:23,760
el contador, tengo que tener en cuenta siempre, es un patrón muy habitual. Tengo que ver si

152
00:13:23,760 --> 00:13:29,040
el elemento está allá o no está y si no está lo pongo a uno si está lo aumento.

153
00:13:29,040 --> 00:13:34,480
Para eso está el default dict, que son los diccionarios por defecto dentro de uno de

154
00:13:34,480 --> 00:13:38,880
los tres grandes módulos de Python, que es uno de ellos es Collections. Y entonces lo

155
00:13:38,880 --> 00:13:42,680
que podemos decir es simplemente, bueno, en caso de que yo accede un elemento y no esté,

156
00:13:42,680 --> 00:13:47,560
pues simplemente me va a dar un valor. Cuando lo creemos así, con int lo que nos va a dar

157
00:13:47,560 --> 00:13:51,680
no va a devolver un 0. ¿Por qué? Porque de hecho si llamamos a int comparences y solo

158
00:13:51,680 --> 00:13:56,360
no va a devolver un 0. Entonces así podemos ver que si nosotros hacemos un diccionario

159
00:13:56,360 --> 00:14:01,640
normal funciona como siempre, pero cuando hacemos una variable que no es un elemento

160
00:14:01,640 --> 00:14:06,040
que no está dentro del diccionario en vez de lanzar unos error, nos da el valor por defecto

161
00:14:06,040 --> 00:14:10,600
0. Por eso podemos directamente en la última línea, podemos incrementar el valor de C

162
00:14:10,600 --> 00:14:14,760
en 1 y no pasa nada, porque bueno, pues C no está, entonces vale 0, lo incremento en

163
00:14:14,760 --> 00:14:18,640
1, ahora vale 1. Nuestro código entonces se simplifica y se queda simplemente en que

164
00:14:18,640 --> 00:14:22,920
tengo que recorrer los elementos de la cadena e incrementar el contador para esa letra en

165
00:14:22,920 --> 00:14:29,200
1, hacerlo para la otra cadena y comprar. Pero es que lo podemos hacer aún mejor, porque

166
00:14:29,200 --> 00:14:33,600
de hecho incluso este patrón es muy habitual, el de quiero contar cosas, por eso en el mismo

167
00:14:33,600 --> 00:14:38,720
módulo collections, por eso de que hay que leerse la documentación, tenemos la clase

168
00:14:38,720 --> 00:14:44,560
contador, con un nombre súper obvio y entonces solamente tenemos que darle, de hecho no tenemos

169
00:14:44,560 --> 00:14:47,880
que darle una palabra, tenemos que darle un iterable y entonces se lo va a recorrer y

170
00:14:47,880 --> 00:14:51,640
nos va a dar el contador. Con lo cual sencillamente tenemos que decir muy bien, tomá palabras

171
00:14:51,640 --> 00:14:54,960
y dime cuántas veces está, puedo consultar en ese diccionario cuántas veces está cada

172
00:14:54,960 --> 00:14:58,320
cosa, con una parte de una diferencia, si el elemento no está no da que error cuántas

173
00:14:58,320 --> 00:15:03,960
veces sabemos no da cero, porque de hecho está respondiendo una pregunta cuántas veces está

174
00:15:03,960 --> 00:15:06,680
0. Por lo cual nuestro código se simplifica aún más, simplemente importa el módulo

175
00:15:06,680 --> 00:15:11,480
collections, compara las dos cadenas y los dos contadores y si los dos contadoras son

176
00:15:11,480 --> 00:15:17,040
iguales es que hay una premutación una de otra, aún mejor en una única línea podríamos

177
00:15:17,040 --> 00:15:21,800
decir si el contador de una palabra es igual al contador de la otra es que son una premutación

178
00:15:21,800 --> 00:15:29,440
una de otra y nos encanta el país. De hecho estamos en la paica así que nos encanta y

179
00:15:29,440 --> 00:15:36,200
no hay ningún aspecto negativo. Yo prefiero esta solución y aquí es donde entra la polémica.

180
00:15:36,200 --> 00:15:42,720
Yo preferiría hacerlo de esta forma y voy a ordenar las dos cadenas de texto y si el

181
00:15:42,720 --> 00:15:48,480
resultado de ordenarlas es la misma cadena es que una es una premutación de la otra.

182
00:15:48,480 --> 00:15:56,400
Por cierto, esto aquí predomina por supuesto aquí la complejidad de la ordenación que

183
00:15:56,400 --> 00:16:02,320
es TeamSort y entonces es N logaritmo de N. Yo considero que esta solución es más

184
00:16:02,320 --> 00:16:08,560
pitónica, paisónica, porque creo firmemente que se acerca mucho más a como nosotros como

185
00:16:08,560 --> 00:16:14,520
seres humanos pensamos. A mí si me dices Roma y amor son una premutación una de otra,

186
00:16:14,520 --> 00:16:19,080
pero cuando miro las cuatro letras yo creo que en mi cabeza no estoy pensando. Creo que

187
00:16:19,080 --> 00:16:22,320
he notado la ha si me recorro los elementos y entonces engraviento el contador y entonces

188
00:16:22,320 --> 00:16:28,800
y pero domina N, D, N. Yo creo que sencillamente lo que yo hago, intento hacer es que digo

189
00:16:28,800 --> 00:16:33,400
si muevo la R aquí, muevo la M aquí tengo la misma palabra. Lo cual realmente yo creo

190
00:16:33,400 --> 00:16:37,440
que como me parece mucho más natural como ser humano limitado creo que estoy haciéndolo

191
00:16:37,440 --> 00:16:42,800
ordenando. Con lo cual yo defiendo que simplemente ordenar y comprar es mucho más sencillo

192
00:16:42,800 --> 00:16:48,680
y por eso es más pitónico. Pero también es más lento. Mucha gente que está muy

193
00:16:48,680 --> 00:16:55,000
obsesionada con la velocidad y es cierto es lento. Y aquí voy a apelar al argumento

194
00:16:55,000 --> 00:17:01,880
de autoridad. Hay una gran persona y Barbara Liskov en una de sus charlas dice no necesitas

195
00:17:01,880 --> 00:17:07,560
la rendimiento óptimo, necesitas el suficiente para cada problema. Típico ejemplo, tenemos

196
00:17:07,560 --> 00:17:11,520
un objetivo crítico en nuestra vida. Vamos a hacer un programa que abre un fichero, lee

197
00:17:11,520 --> 00:17:16,280
la primera línea y la muestra por pantalla. Pues lo podríamos hacer en ensamblador y

198
00:17:16,280 --> 00:17:20,640
podríamos ahorrarnos cinco milisegundos con esta llamada. Ya, pero es que realmente

199
00:17:20,640 --> 00:17:25,560
es que tu programa tarde dos segundos o un segundo punto nueve nueve nueve realmente

200
00:17:25,560 --> 00:17:32,640
no es crítico. Con lo cual, lo que necesito yo creo que es mucho más importante el alcanzar

201
00:17:32,640 --> 00:17:37,640
lo que necesitamos no tanto el obsesionarnos con la velocidad. Pero voy a hacer una pausa

202
00:17:37,640 --> 00:17:45,400
para meterme con gente. Ya que estamos hablando de notación Big O y rayos en el horizonte,

203
00:17:45,400 --> 00:17:51,160
esta solución también se ve mucho, donde mucho es más que cero. Y es que gente dice

204
00:17:51,160 --> 00:17:56,480
bueno, que quieres saber si una cada una premutación de otra en el módulo Intertools tengo una

205
00:17:56,480 --> 00:18:05,240
función que me calcula todas las premutaciones de un elemento. Y llevan razón, ¿tos preguntado?

206
00:18:05,240 --> 00:18:09,760
Genero todas las premutaciones, voy comparando con la otra cadena y si en algún momento

207
00:18:09,760 --> 00:18:16,120
hay un encaja son iguales, es que era una premutación. Esto es listo porque luego está la categoría

208
00:18:16,120 --> 00:18:22,840
de tonto motivado que lo que implementa su propio método de calcular todas las premutaciones.

209
00:18:22,840 --> 00:18:33,800
Y se puede hacer con recursividad. ¿Cuál es la complejidad de esto? Es n-factorial.

210
00:18:33,800 --> 00:18:48,200
N-factorial básicamente es esto. De hecho si buscáis imágenes de gente alejándose

211
00:18:48,200 --> 00:18:56,800
de explosiones, hay un montón. Pero está un montaje. Sí, funciona, son cuatro líneas

212
00:18:56,800 --> 00:19:00,360
y de hecho resuelve el caso que me preguntaron porque era Roma y amor, al final capo tampoco

213
00:19:00,360 --> 00:19:09,600
hay tantas premutaciones de cuatro caracteres. El problema es que sí, la palabra recluta,

214
00:19:09,600 --> 00:19:16,040
tiene 5.040 premutaciones diferentes que se puede hacer y es hecho ese gente cuando

215
00:19:16,040 --> 00:19:21,800
hace el problema ve que funciona. El problema es que si tenemos una cadena de 32 caracteres

216
00:19:21,800 --> 00:19:30,480
con... ¿Verdad que tardará mucho? Entonces dirá... Quizá con 8 coras en más funciones

217
00:19:30,480 --> 00:19:35,040
arrojaré un par de universos al problema, quizá me de tiempo. Y no da tiempo, ese es

218
00:19:35,040 --> 00:19:39,600
un número muy grande. No sé ni siquiera cuánto es. Y la cadena tampoco es tan grande.

219
00:19:39,600 --> 00:19:47,160
Yo solo he visto como compañero de trabajo de... Tenemos 80 factoriales, lo dejamos el

220
00:19:47,160 --> 00:19:56,160
fin de semana ejecutando. Si no, el fin de semana y un rato más. Pero hay que tenerlo

221
00:19:56,160 --> 00:20:02,160
muy presente, volviendo de todas formas al objetivo que nos trae. Yo creo que es mucho

222
00:20:02,160 --> 00:20:05,680
más sencillo y mucho más intuitivo. Y eso lo podríamos lanzar con otra pregunta, que

223
00:20:05,680 --> 00:20:10,000
es ¿por qué no gusta Python? Porque si podríamos hablar durante mucho tiempo, he hecho el objetivo

224
00:20:10,000 --> 00:20:16,760
original y hablar de esto. ¿No gusta Python? Yo creo... Bueno, ¿saben por qué no molapaisan?

225
00:20:16,760 --> 00:20:21,720
Porque lo oímos siempre. Python no mola porque es muy lento. El sangrado de 4 espacios

226
00:20:21,720 --> 00:20:26,200
es horrendo. Yo quiero mis parentes y el tipado dinámico, el parámetro self explícito, que

227
00:20:26,200 --> 00:20:30,840
hay muchas conversaciones del respecto. Vale, sí, sabemos por qué Python no mola, pero

228
00:20:30,840 --> 00:20:34,720
aquí casi que no da igual. Y además lo hemos respondido una y otra vez. Respondiéndolo

229
00:20:34,720 --> 00:20:40,200
de que el lento, porque siempre se oye, hay una cita de una de las máximas autoridades

230
00:20:40,200 --> 00:20:44,120
y es del tema de la optimización, que de hecho Pablo lo ha dicho hace un momento. ¿Ostimización

231
00:20:44,120 --> 00:20:48,440
no lo hagas? Y la segunda regla no lo hagas todavía y solamente si sabes lo que te estás

232
00:20:48,440 --> 00:20:55,880
metiendo. Primero, es que funcione. Y cuando funcione, si es lo suficientemente lento,

233
00:20:55,880 --> 00:21:00,160
si es demasiado lento, solamente entonces nos planteamos el tema de optimizarlo. De

234
00:21:00,160 --> 00:21:03,480
hecho, yo metería una tercera regla, que sería primero que sea bonito, después que

235
00:21:03,480 --> 00:21:09,880
funcione y después se optimiza. Porque, de hecho, creo que todo Python gira en torno

236
00:21:09,880 --> 00:21:13,640
a la sencillez. Y como no nos podamos parar a verlo todo, voy a intentar luego ilustrarlo

237
00:21:13,640 --> 00:21:18,960
con un pequeño ejemplo. Por ejemplo, esta cita. Esta cita la ama mucho la documentación,

238
00:21:18,960 --> 00:21:22,480
pero de que leíso, pero lo da más fácil pedir perdón que permiso. Cuando uno dice

239
00:21:22,480 --> 00:21:27,680
cómo compruebo si una variable de un tipo, a un entero, te responde, no, no, es que tú

240
00:21:27,680 --> 00:21:31,360
no lo compruebas. Tú simplemente operas y haces lo que quieras hacer. Y nosotros, oh,

241
00:21:31,360 --> 00:21:34,720
qué bien, es más fácil pedir perdón que permiso, sino tenemos que hacer, eh, pero

242
00:21:34,720 --> 00:21:39,960
¿por qué es eso bueno? Probablemente la idea es que esto simplifica un montón la

243
00:21:39,960 --> 00:21:43,720
nuestra línea de pensamiento. Porque si yo quiero leer un fichero, ¿cómo lo hacemos

244
00:21:43,720 --> 00:21:49,420
en Python? Lo leo. No me planteo si existe. Es un fichero y no una carpeta. Si tengo

245
00:21:49,420 --> 00:21:53,720
permisos de lectura, si hay conduciones de carrera, principalmente lo abro. Esto, por

246
00:21:53,720 --> 00:21:58,280
ejemplo, y solamente, además, me permite poner la cita, es solamente un ejemplo de

247
00:21:58,280 --> 00:22:02,480
cómo creo que todas las propiedades, las características que nos gustan de Python,

248
00:22:02,480 --> 00:22:08,120
su última esencia es que hacen mucho más sencillos todo el tema, todo el proceso de

249
00:22:08,120 --> 00:22:13,720
dar vida a nuestro programa. Y no es casualidad que el mismo thing de Python, cuando hacemos

250
00:22:13,720 --> 00:22:19,440
import this, nos diga como primera cosa es mejor bonito que feo y que la tercera línea

251
00:22:19,440 --> 00:22:24,600
sea es mejor que sea sencillo que complejo. He hecho un poquito más abajo, nos dice que

252
00:22:24,600 --> 00:22:29,000
solamente debería haber una forma de hacerlo que debería ser la obvia de hacer las cosas.

253
00:22:29,000 --> 00:22:32,480
Esto está en clara contraposición si le damos un poco sobre el tema con Perl, porque Perl

254
00:22:32,480 --> 00:22:38,320
tiene un lema que es hay más de una forma de hacerlo. En el mundo de Python, realmente

255
00:22:38,320 --> 00:22:43,040
no, hay solamente una forma que es la correcta y la correcta es la superobvia, la super sencilla.

256
00:22:43,040 --> 00:22:49,480
Y la sencilla es muy importante. De hecho, primera cita de Dijkstra, Dijkstra decía

257
00:22:49,480 --> 00:22:55,600
que el que sea sencillo es un prerequisito para la fiabilidad. Creo que es bastante indiscutible

258
00:22:55,600 --> 00:23:00,880
en el sentido de que yo preferiría que el software del avión en el que monto no tenga

259
00:23:00,880 --> 00:23:07,080
puntero, apuntero, apuntero, apuntero. Yo prefiría que fuera un poquito más lento

260
00:23:07,080 --> 00:23:13,840
y que tuviera un entero simplemente así fácil. Porque por eso todas las cosas de diseño,

261
00:23:13,840 --> 00:23:20,040
cuanto más componentes es más fácil que algo falle. Y aquí termina el capítulo 1.

262
00:23:20,040 --> 00:23:23,640
Son varios capítulos. Porque voy a hablar de una cosa que realmente no nos importa,

263
00:23:23,640 --> 00:23:31,960
pero tenemos que aprendernosla. Y es la heap. La heap es la estructura de datos más importante

264
00:23:31,960 --> 00:23:38,160
conocida por la humanidad después de la tabla hash. La tabla hash es la adicional. Y la heap

265
00:23:38,160 --> 00:23:45,760
resuelve un problema. Bueno, la heap se traduce a veces horriblemente como montículo. Pero

266
00:23:45,760 --> 00:23:49,040
me niego a utilizar la palabra montículo, sobre todo porque cuando buscaba imágenes

267
00:23:49,040 --> 00:23:55,960
de montículo me salían montañitas con césped. Y no podía poner nada aquí. La heap resuelve

268
00:23:55,960 --> 00:24:00,320
un problema. Y es si nosotros tenemos una serie de elementos y queremos mantenerlos

269
00:24:00,320 --> 00:24:04,440
no ordenados en todo momento, sino queremos poder saber cuál es el mínimo elemento en

270
00:24:04,440 --> 00:24:11,080
cada momento o cuál es el máximo elemento en cada momento, cómo lo hacemos. Un ejemplo.

271
00:24:11,080 --> 00:24:15,360
Tenemos un montón de trabajos que queremos imprimir y queremos que siempre cuando vayamos

272
00:24:15,360 --> 00:24:19,640
a imprimir el siguiente siempre sea el más importante porque tienen sus prioridades. Pues

273
00:24:19,640 --> 00:24:23,840
yo quiero coger siempre el de máxima prioridad, pero nos van a ir entrando trabajo en todo

274
00:24:23,840 --> 00:24:27,200
momento. Con lo cual tengo que llevar la cuenta siempre de cuál es el elemento más grande.

275
00:24:27,200 --> 00:24:30,120
Y de forma análoga podríamos estar en el escenario, en lo cual es que si éramos saber

276
00:24:30,120 --> 00:24:35,040
el que tiene menos prioridad. Por ejemplo, si fuera un proceso en un ordenador. Pues podríamos

277
00:24:35,040 --> 00:24:40,880
hacerlo de una forma. Podríamos decir muy bien, pues tengo mi lista de números y lo que voy a hacer

278
00:24:40,880 --> 00:24:46,720
es que por cada número que me des voy a hacer un append, meto el número, ordeno toda la lista de

279
00:24:46,720 --> 00:24:53,000
nuevo y cuando me pida el siguiente digo pop0 y entonces pues cojo el primer elemento de la lista.

280
00:24:53,000 --> 00:24:58,560
El problema de esto es que si bien insertar el coste ha amortizado de insertar y eso es

281
00:24:58,560 --> 00:25:02,080
fundamental, sabernos las complejidades de las operaciones que utilizamos en el día a día.

282
00:25:02,080 --> 00:25:07,600
Si bien insertar un elemento, añadir un elemento al final de una lista es o de uno,

283
00:25:07,600 --> 00:25:13,880
tenemos que ordenarlo y aún peor, tenemos que al sacar el último elemento la complejidad de

284
00:25:13,880 --> 00:25:19,400
eso es lineal. ¿Por qué? Porque tenemos que mover todos los elementos una posición a la izquierda

285
00:25:19,400 --> 00:25:24,920
de memoria, por así verlo. Simplificándolo. Entonces eso tiene una complejidad de n,

286
00:25:24,920 --> 00:25:30,240
logaritmo de n. ¿Por qué? Porque la operación más costosa de estas tres es la ordenación.

287
00:25:30,240 --> 00:25:37,480
En logaritmo de n no está mal, pero sigue siendo más de lo que nos gustaría. Otra forma de hacerlo

288
00:25:37,480 --> 00:25:42,200
sería, vamos a aprovechar el hecho de que la lista está ya ordenada en sí, vamos a aprovecharla y

289
00:25:42,200 --> 00:25:47,000
entonces la búsqueda no la hacemos con Timsort que es un n, logaritmo de n. Podemos hacerlo mejor.

290
00:25:47,000 --> 00:25:52,360
Lo que vamos a hacer es hacer una búsqueda binaria, como ya sé que está ordenado, tengo que iterar

291
00:25:52,360 --> 00:25:58,600
mucho menos y entonces eso es simplemente el logaritmo de n. El problema que volvemos a lo

292
00:25:58,600 --> 00:26:03,080
de antes, tenemos que insertar en la posición adecuada, que eso en el peor de los casos podría

293
00:26:03,080 --> 00:26:07,440
tener que desplazarlo todo hacia el otro lado y luego tenemos que extraer de la primera posición,

294
00:26:07,440 --> 00:26:13,720
con lo cual nos sigue limitando el o de n. Entonces la pregunta es no hay esperanza,

295
00:26:13,720 --> 00:26:19,080
no podemos hacerlo de ninguna forma mejor. De hecho es curioso porque parece un problema muy sencillo,

296
00:26:19,080 --> 00:26:22,960
en esencia. Yo estaba preparando las transparencias y dije, no, seguro se puede hacer de otra forma.

297
00:26:22,960 --> 00:26:27,840
Entonces intenté utilizar una lista enlazada en la cual hacía parte, no se puede, pero si hay esperanza,

298
00:26:27,840 --> 00:26:36,080
podemos utilizar la hip. ¿Será la hip mucho para la última charla de la picon? No. La hip,

299
00:26:36,080 --> 00:26:40,840
lo que hace básicamente es una estructura en la cual no garantiza que el elemento de más arriba,

300
00:26:40,840 --> 00:26:46,440
porque un árbol sea siempre el máximo o el mínimo, dependiendo de si estamos hablando de una max

301
00:26:46,440 --> 00:26:51,400
hip o una min hip. Una máxima o una mínima. Por simplificar y por qué es lo que utiliza

302
00:26:51,400 --> 00:26:55,920
Python, vamos a considerar que es una min hip. El elemento de arriba, la raíz del árbol,

303
00:26:55,920 --> 00:27:00,560
va a ser siempre el elemento más pequeño. Y también en Python, y también hay muchos

304
00:27:00,560 --> 00:27:05,080
tipos de implementaciones, muchísimas, pero la más tip uno muy habitual y que tenemos en Python

305
00:27:05,080 --> 00:27:10,520
es la hip binaria, en la cual cada nodo tiene máximo dos hijos. Y bueno, también es un árbol

306
00:27:10,520 --> 00:27:13,800
completo porque lo vamos rellenando derecha izquierda y de arriba, de izquierda derecha y de

307
00:27:13,800 --> 00:27:21,800
arriba abajo, pero no hace falta saber tanto. La hip siempre se reordena después de una ordenación.

308
00:27:21,800 --> 00:27:26,440
Pongamos que introducimos el elemento 11. Entonces lo que va a hacer la hip es decir muy bien,

309
00:27:28,440 --> 00:27:33,040
cada nodo es siempre más pequeño que sus hijos, esa es la única regla que importa. Con lo cual,

310
00:27:33,040 --> 00:27:38,360
cuando yo añado un nuevo elemento, por ejemplo, 11, dice Python, es 11, es 9 más grande que su

311
00:27:38,360 --> 00:27:43,720
hijo, que es 11, sí. Con lo cual, todo fantástico. Ahí te quedas. ¿Qué pasa si añadimos algo que,

312
00:27:43,720 --> 00:27:47,920
si rompe lo que se llama como la invariante? ¿Qué pasa si añado un 5? Que lo que entonces

313
00:27:47,920 --> 00:27:54,080
tenemos que decir es 9 más pequeño que su hijo, 5 no. Pues entonces lo invertimos. Y entonces,

314
00:27:54,080 --> 00:27:59,880
seguimos por aquí. Es ahora 5 más grande que su padre, o al revés, es 7 más pequeño que su

315
00:27:59,880 --> 00:28:05,360
hijo, no. Entonces reórdenalo. Y tenemos que llegar hasta esta posición en la cual ya sí se cumple

316
00:28:05,360 --> 00:28:10,280
lo que se conoce como la invariante, que es muy matemático, y es que es 3 es menor que su hijo,

317
00:28:10,280 --> 00:28:15,040
que es 5. Y hemos terminado. Cuando eliminamos un elemento, cuando queremos coger cuál es el

318
00:28:15,040 --> 00:28:19,640
mínimo, dame el elemento mínimo de la hip, pues simplemente cojo el 3 y lo quito. Y entonces,

319
00:28:19,640 --> 00:28:23,840
bueno, pero necesito ahora algo en la raíz, ¿no? Pues lo que se hace es que se coge el último

320
00:28:23,840 --> 00:28:29,480
elemento, porque la vamos rellenando hacia acá y de arriba abajo y lo movemos a la raíz. Y entonces,

321
00:28:29,480 --> 00:28:35,600
ahora comprobamos si se vuelve a mantener la invariante. Entonces, 9 tiene dos hijos, 5 y 4. Es

322
00:28:36,600 --> 00:28:43,360
más pequeño que los dos. No, no lo es. De hecho, el más pequeñito de su hijo es 4. Entonces,

323
00:28:43,360 --> 00:28:48,640
lo invierto. Así hemos conseguido que el pequeño, que es 4, ahora esté en la raíz. Y volvemos a

324
00:28:48,640 --> 00:28:54,800
repetir en el siguiente nivel. Y como se cumple, aunque sí 9 es más pequeño que 13, no lo es

325
00:28:54,800 --> 00:29:01,080
que 8, lo invertimos. Y cuando hemos acabado de propagar los cambios, tenemos una hip que vuelve

326
00:29:01,080 --> 00:29:05,440
hasta cumplir su invariante y en la cual se cumplir lo que queríamos, que era que todos los nodos

327
00:29:05,440 --> 00:29:09,000
son siempre más pequeños que su hijo y que el más pequeño, por definición, está en la raíz.

328
00:29:09,000 --> 00:29:16,000
Y eso me volvó un montón, porque la hip tiene todas las operaciones que nos importan que son

329
00:29:16,000 --> 00:29:22,160
añadir y extraer en tiempo logarítmico. Y el salto de tiempo lineal, tiempo logarítmico, es muy,

330
00:29:22,160 --> 00:29:28,000
muy, muy grande. En Python tenemos un módulo que implementa la hip, aunque nadie lo usa nunca. También

331
00:29:28,000 --> 00:29:33,200
una propiedad que pensaba meter, pero mi consejo de sabios me dijo no y me lo vetaron y quería

332
00:29:33,200 --> 00:29:38,800
enseñar que es que realmente una característica muy chula de las hip es que se puede representar

333
00:29:38,800 --> 00:29:44,040
como una RAI, es decir, como una lista de Python. Se puede básicamente aplanar y entonces podemos

334
00:29:44,040 --> 00:29:47,640
trabajar en vez de que un árbol que es muy complejo con una simple lista. De hecho, es lo que hace

335
00:29:47,640 --> 00:29:51,720
Python. Cuando quedas a trabajar con una hip y no necesitamos saber cómo funciona, le dice muy bien,

336
00:29:51,720 --> 00:29:58,240
esta lista vacía, por ejemplo, aquí H, tú vas a ser la hip aplanada y entonces con los métodos

337
00:29:58,240 --> 00:30:04,000
del módulo hip queue podemos añadir elementos. Por ejemplo, añado 4, añado 2, añado 7. Podéis

338
00:30:04,000 --> 00:30:07,880
imprimirlo por pantalla para ver lo que sale, pero nos da igual. Lo que importa es que cuando hagamos

339
00:30:07,880 --> 00:30:14,000
un pop nos va a dar el elemento más pequeño, en este caso es 2. Pero eso yo creo que es un poco

340
00:30:14,000 --> 00:30:20,120
feo, lo de crear la lista y tener que pasarla como argumento. A mí me gusta utilizar una simplificación

341
00:30:20,120 --> 00:30:25,280
que es una clase hip que simplemente engloba esos métodos de antes. Entonces en el constructor creo

342
00:30:25,280 --> 00:30:31,160
mi lista vacía y cuando hago un push y un pop, pues llamo los dos métodos que hay por debajo. Con

343
00:30:31,160 --> 00:30:35,800
esto es otra capa de abstracción más y que nos lo simplifica mucho porque podemos pensar en una hip

344
00:30:35,800 --> 00:30:40,560
como nos importa a nosotros, que es algo en lo cual se puede añadir elemento y se puede extraer.

345
00:30:40,560 --> 00:30:47,480
Y lo que sé es que siempre pop me devuelve al elemento más pequeño. Que por cierto, si que

346
00:30:47,480 --> 00:30:53,760
si hablamos almacenar en varias distancias, por ejemplo, en una hip, eso tendríamos propondría yo

347
00:30:53,760 --> 00:30:57,840
hacerlo así. Definiríamos una tupla nombrada que es una tupla que nos permite acceder a no solamente

348
00:30:57,840 --> 00:31:02,360
proposición sino por nombre y tendríamos por ejemplo la distancia en kilómetros y el nombre de la

349
00:31:02,360 --> 00:31:07,820
ciudad de destino. Pues yo a mi hip añado tres distancias, por ejemplo, asumiendo que las calculara

350
00:31:07,820 --> 00:31:12,880
bien, la distancia a Barcelona a Madrid y a Santiago de Compostela desde Valencia y cuando le

351
00:31:12,880 --> 00:31:16,560
diga muy bien, dame la ciudad más cercana haciendo un pop, pues me dice por la ciudad más cercana,

352
00:31:16,560 --> 00:31:21,080
desde aquí, aparentemente en Madrid. Y la pregunta, ¿y por qué estás poniendo los

353
00:31:21,080 --> 00:31:26,880
kilómetros antes que el nombre? Pues porque cuando le digamos a la hip, dame el elemento más pequeño,

354
00:31:26,880 --> 00:31:30,920
va a comparar las tuplas como se comparan las tuplas en paisa, aunque hay que tenerlo siempre presente,

355
00:31:30,920 --> 00:31:35,360
se comparan elemento a elemento, es decir, va a irse al primer elemento de las dos tuplas que

356
00:31:35,360 --> 00:31:39,120
estamos comparando y nos va a decir cuál de los dos elementos es más pequeño. Y como en este caso,

357
00:31:39,120 --> 00:31:46,320
302 es más pequeño que 349 nos devuelve esa tupla. Solamente si los valores fueran iguales en el

358
00:31:46,320 --> 00:31:50,480
primer elemento, nos iríamos a la segunda y sino a la tercera. Es decir, la comparación va a ganar

359
00:31:50,480 --> 00:31:56,000
el primer elemento en el cual sean diferentes los valores. Y llegamos a la tercera parte. Y es el

360
00:31:56,000 --> 00:32:01,160
algoritmo de Dijkstra. El algoritmo de Dijkstra, si se hubiera inventado hoy día, se conocería

361
00:32:01,160 --> 00:32:11,240
como el algoritmo del GPS, porque es básicamente lo que hace. 30 minutos, perfecto. Una cosa muy

362
00:32:11,240 --> 00:32:18,600
guay, que te va dando mucho. Dijkstra inventó el algoritmo de Dijkstra, aparentemente según

363
00:32:18,600 --> 00:32:24,000
cuenta contaba el mismo en 20 minutos. Al parecer, se había inventado en Holanda un nuevo ordenador

364
00:32:24,000 --> 00:32:30,760
y quería, le dijeron, ¿con qué probamos esto? Nuestro holamundo. Dijkstra ha no un holamundo para

365
00:32:30,760 --> 00:32:36,640
este super ordenador que queremos probar. Y entonces cogió un papel y se inventó un algoritmo que

366
00:32:36,640 --> 00:32:43,560
era un problema interesante. Y básicamente, da que pensar acerca de qué pasa cuando eres uno de los

367
00:32:43,560 --> 00:32:47,720
grandes genios de la ciencia de la computación. Que haces algo en un trozo de papel para probar

368
00:32:47,720 --> 00:32:52,640
una nueva máquina y se siga utilizando en todo el mundo de cada después. El algoritmo de Dijkstra

369
00:32:52,640 --> 00:32:59,200
se utiliza para calcular la distancia más corta entre dos puntos. Formalmente, que es lo que no nos

370
00:32:59,200 --> 00:33:04,360
importa, cuando tenemos un grafo y tenemos una vértice que nos conectan los nodos,

371
00:33:04,360 --> 00:33:11,200
podemos calcular la distancia entre dos nodos, la más corta. Pero es muy aburrido. Lo que quiere decir

372
00:33:11,200 --> 00:33:15,720
es que si tenemos un mapa con ciudades y tenemos distancia entre las ciudades, podemos calcular

373
00:33:15,720 --> 00:33:19,880
cuál es la ruta más corta para llegar de una ciudad a otra. Eso si lo preferí, no decimos

374
00:33:19,880 --> 00:33:25,720
nodos, decimos ciudades solamente. Poniéndonos un poquito más formales, realmente el algoritmo de

375
00:33:25,720 --> 00:33:30,320
Dijkstra no calcula la distancia más corta entre dos nodos o ciudades. Lo que hace dar la distancia

376
00:33:30,320 --> 00:33:35,320
más corta desde un nodo a todos los demás. Es decir, desde una ciudad, desde Valencia,

377
00:33:35,320 --> 00:33:41,440
Dijkstra nos daría la ruta más corta a todas las ciudades. Pero bueno, como una de las ciudades

378
00:33:41,440 --> 00:33:48,640
está dentro del conjunto de todas las ciudades, nos sirve para calcularlo. Y el algoritmo de Dijkstra

379
00:33:48,640 --> 00:33:53,280
es muy sencillo. De hecho, pasé horas haciendo esta animación. Así que ahora tengo que explicarla.

380
00:33:54,560 --> 00:34:00,240
El algoritmo de Dijkstra intimida mucho, pero es muy muy sencillo porque la distancia en su esencia.

381
00:34:01,560 --> 00:34:08,600
Si quisiéramos llegar del nodo S al nodo T, ¿cómo lo haríamos? Pues si quisiéramos

382
00:34:08,600 --> 00:34:14,680
hacerlo por fuerza bruta, nos encontraríamos con el mismo problema. Calcular por fuerza bruta todas

383
00:34:14,680 --> 00:34:19,280
las rutas posibles se parece un montón, lo que hicimos antes y es factorial. Con lo cual,

384
00:34:19,280 --> 00:34:24,920
cuando tenemos 100, 250,000 ciudades, ya se convierten en algo que no se puede calcular por

385
00:34:24,920 --> 00:34:31,200
fuerza bruta. Dijkstra lo hacía de esta forma. Lo que hacía era ir calculando en cada momento

386
00:34:31,200 --> 00:34:36,760
cuál era la forma más rápida de llegar a cada uno de los nodos. Y entonces Dijkstra hubiera

387
00:34:36,760 --> 00:34:42,680
empezado por la salida y hubiera dicho, estoy en el nodo S. ¿A qué nodos puedo llegar desde el nodo

388
00:34:42,680 --> 00:34:48,640
S? Porque tengo flechitas, creo carreteras que me llevan a esas ciudades y entonces hubiera dicho

389
00:34:48,640 --> 00:34:53,760
muy bien, puedo llegar a P y a U. Si llegó a P, ¿qué distancia llevaré en total cuando haya

390
00:34:53,760 --> 00:34:59,440
llegado allí? Pues llevaré dos, ¿no? Que es la distancia que hay de S a P y de S a U hay tres,

391
00:34:59,440 --> 00:35:05,520
con lo cual puedo llegar a esas dos ciudades y habré tardado tanto en recorrerlo. He terminado

392
00:35:05,520 --> 00:35:09,600
porque ya no tengo más vecinos a los que puedo ir desde S y lo marco como visitado. Ya he estado

393
00:35:09,600 --> 00:35:14,400
aquí, no me importa. Y ahora Dijkstra lo hubiera preguntado, de todas las ciudades que no he visitado

394
00:35:14,400 --> 00:35:21,480
aún, pero las que sé cómo llegar, que son P y U, ¿cuál es la que está más cerca del origen?

395
00:35:21,480 --> 00:35:26,520
Pues bueno, dos es menor que tres, con lo cual es P, ¿verdad? Entonces Dijkstra se hubiera ido a P.

396
00:35:26,520 --> 00:35:31,080
Y entonces al llegar a P hubiera respondido la misma pregunta, desde P, ¿a qué ciudades puedo

397
00:35:31,080 --> 00:35:35,600
llegar en las cuales no he estado aún y cuánto me va a costar llegar a ellas? Puedes decir,

398
00:35:35,600 --> 00:35:41,800
pues mira, Dijkstra, puedes llegar a Q. Si vas a Q desde P, como llegar a P te costó dos y vas a

399
00:35:41,800 --> 00:35:49,280
tardar cinco más, llegar a Q mínimo, la mejor ruta que conocemos ahora es siete. X va a tardar,

400
00:35:49,280 --> 00:35:54,520
pues lo que llevas ya, que es dos, más cuatro, es X. Y bueno, no puedes llegar a ninguna otra,

401
00:35:54,520 --> 00:36:00,040
porque en S ya he estado, de hecho, viene de allí. Termino, marco P como visitado y vuelvo a

402
00:36:00,040 --> 00:36:05,600
responder la misma pregunta, ¿qué es? ¿A qué ciudad puedo llegar ahora? ¿Cuál es la ciudad que tengo más

403
00:36:05,600 --> 00:36:18,000
cerca del origen en la que no he estado? Y es... muy bien, es U, porque no he estado en U, no he estado

404
00:36:18,000 --> 00:36:22,880
en X y no he estado en Q. Y bueno, la más cerca es U porque está a tres. Entonces, Dijkstra volvería

405
00:36:22,880 --> 00:36:28,000
a hacer lo mismo, desde U puedo llegar, ahora puedo llegar a X también. Llegar a X, de hecho,

406
00:36:28,000 --> 00:36:36,560
por U me cuesta cuatro, porque en U, en U estoy atrás del origen y con uno más, llegó a X,

407
00:36:36,560 --> 00:36:42,480
entonces digo, eh, puedo mejorar la ruta a X, porque yo a X sabía llegar tardando seis yendo por allí,

408
00:36:42,480 --> 00:36:46,720
pero si vengo por aquí, tardo mucho menos, tardo cuatro. Entonces bueno, pues actualizo cuatro y

409
00:36:46,720 --> 00:36:52,840
digo cuatro, mola mucho. Entonces, ahora X tengo una mejor ruta conocida que es cuatro y la marco.

410
00:36:52,840 --> 00:36:59,160
Y repito, bueno, pues llegar de U, llegar a V es tres, tres más tres es seis y en esencia,

411
00:36:59,160 --> 00:37:04,800
el algoritmo procede todo el rato igual. Voy calculando las distancias a un nodo,

412
00:37:04,800 --> 00:37:09,520
a todos los nodos desde el que estoy ahora, voy calculando la distancia a todos los que puedo

413
00:37:09,520 --> 00:37:16,360
llegar que no he visitado aún y en caso de que encuentre una pues una ruta mejor actualizo. Y repito,

414
00:37:17,600 --> 00:37:21,920
este ejemplo intenta entrar por abajo y en un momento dado se da cuenta de que es mejor por

415
00:37:21,920 --> 00:37:28,400
arriba, entonces nos vamos por allí. Y si seguimos repitiéndolo, hay un momento en el cual llegamos

416
00:37:28,400 --> 00:37:32,760
a T y de hecho es muy fácil, cuando llegamos a un vecino, la demostración matemática también

417
00:37:32,760 --> 00:37:38,640
era muy elegante, pero no nos hace falta saberla. Se puede demostrar que la ruta más corta la va a

418
00:37:38,640 --> 00:37:43,880
saber alcanzado en el momento en el cual ya que es a visitarte por primera vez. Ese es el camino

419
00:37:43,880 --> 00:37:51,440
más corto y de hecho con Dijkstra lo hemos calculado. La complejidad y esto es una simplificación atroz,

420
00:37:51,440 --> 00:37:58,880
podemos dejarlo en que es n logaritmo de n, donde n es el número de nodos. Entonces eso es muy,

421
00:37:58,880 --> 00:38:03,480
muy rápido. El único problema de Dijkstra y que yo me lo encontré cuando intenté implementarlo la

422
00:38:03,480 --> 00:38:10,040
primera vez por curiosidad es que las implementaciones son horrendas, os desafío que intentáis encontrar

423
00:38:10,040 --> 00:38:14,680
algo comprensible respecto a Dijkstra. Esta es la implementación que hay en la Wikipedia, en

424
00:38:14,680 --> 00:38:20,760
seguros códigos. Y esto me recuerda que a mí me pasa siempre que es que yo a donde voy, cuando

425
00:38:20,760 --> 00:38:25,320
cada vez que ponen un tocho, un bloque de código así en las transparencias, veo que todo el mundo

426
00:38:25,320 --> 00:38:30,720
hace, mmm, sí, sí. Y de hecho por eso mismo yo estuve toda la vida convencido que era muy tonto,

427
00:38:30,720 --> 00:38:36,200
porque era el único que no me enteraba todo el mundo, oh, sí, evidente, de hecho ahí. Aquí en

428
00:38:36,200 --> 00:38:44,480
esta matriz hago un infinito y un defined. Bueno, yo confieso que a partir de la línea 7 no sé

429
00:38:44,480 --> 00:38:49,760
lo que pasa. No sé lo que pasa en el sentido de que deje de leer porque no. Esta es la que está

430
00:38:49,760 --> 00:38:54,680
en la Wikipedia y es triste porque yo dependo mucho de la Wikipedia, pero es que hay un caso aún peor

431
00:38:54,680 --> 00:38:59,040
que es Rosetta Code, que es una página web donde hay implementaciones de muchos algoritmos,

432
00:38:59,040 --> 00:39:02,920
de muchas ayudas, en muchos lenguajes para que puedas comprar lenguaje, idiomas de lenguaje de

433
00:39:02,920 --> 00:39:11,240
programación y demás. La implementación en Rosetta Code es esto. Por favor, cargando. Esta es la

434
00:39:11,240 --> 00:39:18,560
implementación de Rosetta Code, que bueno, no llevo ni siquiera a línea 7 y me hace sentirme muy mal.

435
00:39:19,560 --> 00:39:24,240
De hecho, puntos extra por el detalle del único comentario que hay en todo el programa.

436
00:39:24,240 --> 00:39:35,360
Es un ejemplo de por qué hay que comentar un código, no? Claro, ahora lo entiendo todo. Relax,

437
00:39:35,360 --> 00:39:44,040
u, v, a. Es un problema muy fácil. Esto claramente calcula la distancia más corta en un grafo.

438
00:39:45,040 --> 00:39:51,040
Horrible, horrible. Y de hecho costó mucho buscar ejemplos de cómo puedo encontrar una forma de

439
00:39:51,040 --> 00:39:55,600
verdad de implementar distra. ¿Cuál es la esencia de lo que hemos visto que es muy tonto? ¿Dónde no

440
00:39:55,600 --> 00:40:00,640
he estado aún allí? Pues mira, a ver cuánto tardan a llegar a eso. Pues voy a proponer que lo hagamos

441
00:40:00,640 --> 00:40:07,960
muy, muy fácilmente en Python. Y como excusa pensé, ¿dónde es la próxima Python US? Es en Oregon,

442
00:40:07,960 --> 00:40:15,000
en Portland. Entonces pensé, ¿y si pudiéramos ir a Portland? ¿Y si cogiéramos el avión privado de

443
00:40:15,000 --> 00:40:24,120
Python España, el jet? Y como somos 40 y poco de momento, cabemos y nos bajamos al aeropuerto de

444
00:40:24,120 --> 00:40:29,080
Portland, donde quiera que esté eso. Pues más, no voy a utilizar ninguna un vocado de bueno,

445
00:40:29,080 --> 00:40:34,880
lo implementas yo, la ruta más corta. Por supuesto, la ruta más corta en la vida real,

446
00:40:34,880 --> 00:40:38,520
cuando nos montamos el avión por primera vez, decimos, eh, el avión no va en línea directa,

447
00:40:38,520 --> 00:40:44,000
ya está yendo el polo norte cuando está yendo hacia medio. Sí, porque por esas cosas de geometría

448
00:40:44,000 --> 00:40:51,040
raras, cuando tienes una esfera, la ruta más corta no va a atravesar la tierra. Entonces trazas una cosa

449
00:40:51,040 --> 00:40:54,240
con una cuerda, te lo enseñan y no te enteras cuando eres pequeño, que resulta que la ruta más

450
00:40:54,240 --> 00:40:58,080
corta en un mapa es en una esfera de verdad es esto, el avión haría esto cuando despegaramos

451
00:40:58,080 --> 00:41:03,120
desde Valencia y fuéramos hasta Oregon, el avión haría esto. Pero la vida real no intentamos

452
00:41:03,120 --> 00:41:10,600
minimizar distancia, porque como lamentablemente no tenemos un avión privado aún. En la vida real,

453
00:41:10,600 --> 00:41:18,160
el grafo se parece a esto. Salvo que pague otro, cuando nos matamos en un buscador de vuelos,

454
00:41:18,160 --> 00:41:23,760
lo que estamos es minimizando el precio, aunque implique volar a las 4 de la mañana en un sitio

455
00:41:23,760 --> 00:41:31,080
donde no hay luz, ni sanidad, ni policía, da igual. Me han dicho que vale un euro, ya voy.

456
00:41:31,080 --> 00:41:35,880
En la vida real, queremos minimizar el precio. Entonces el grafo de verdad, aunque nunca lo

457
00:41:35,880 --> 00:41:40,000
hayamos pensado, se parece a esto, puedo ir a un montón de ciudades, cada conexión tiene un

458
00:41:40,000 --> 00:41:44,640
precio, digamos que el mejor precio que ofrece a la compañía aérea o el más barato entre

459
00:41:44,640 --> 00:41:49,120
varias ofertas de varias compañías aéreas, ¿cómo minimizo eso? Y entonces haremos esta búsqueda.

460
00:41:49,120 --> 00:41:54,720
De hecho, el ejemplo de antes con unos, dos, tres, se puede más o menos resolver a ojo. Yo creo

461
00:41:54,720 --> 00:41:58,600
que este no. Y estamos hablando de que ya son muy poquitas ciudades, el mundo real tiene mucho

462
00:41:58,600 --> 00:42:05,560
aeropuerto. Pense cómo lo hacemos y entonces como hay gente para todo y la gente tiene hobbies

463
00:42:05,560 --> 00:42:11,560
increíbles porque el mundo es un lugar fantástico y no va con ironía. No, no lo digo completamente

464
00:42:11,560 --> 00:42:15,800
en serio, me parece que es precioso que cualquier cosa, hay mucha gente que lo hace y lo hace

465
00:42:15,800 --> 00:42:20,160
muy bien. Hay una página web que se llama OpenFlight y hay gente que recopila información

466
00:42:20,160 --> 00:42:24,240
de todos los aeropuertos del mundo, de todas las rutas aéreas del mundo, de todas las compañías

467
00:42:24,240 --> 00:42:29,760
aéreas, todo. Y te lo puedes bajar, puedes hacer una donación y dir, ¡eh, genial! Te puedes bajar un

468
00:42:29,760 --> 00:42:35,040
fichero que tiene todos los aeropuertos del mundo y lo van actualizando con muchísimo, muchísimo

469
00:42:35,040 --> 00:42:43,760
enmero. Y puedes utilizarlo para... Un segundo, puedes utilizarlo igual que puedes utilizar el fichero

470
00:42:43,760 --> 00:42:49,600
que tienen con toda la ruta aérea. Y de hecho utilizarlo es muy fácil, es simplemente, eso ni

471
00:42:49,600 --> 00:42:54,840
40. Utilizarlo es muy fácil. Yo propongo, vamos a crear una tupla nombrada que se llama, bueno,

472
00:42:54,840 --> 00:43:01,320
que se llama aeropuerto, donde vamos a almacenar el código IATA, que es eso de VLC para Valencia o

473
00:43:01,320 --> 00:43:09,920
BCN para Barcelona. Y vamos a guardar las coordenadas del aeropuerto, el nombre del aeropuerto y el país

474
00:43:09,920 --> 00:43:15,440
en el que está. Creo que aquí ya se puede enseñar un par de detalles que son muy paisónicos, como

475
00:43:15,440 --> 00:43:19,280
por ejemplo, el argumento por defecto. Porque el argumento por defecto lo que nos permite es que,

476
00:43:19,280 --> 00:43:25,360
para qué vamos a pasarle otra vez un parámetro cuando es siempre el mismo. El argumento por defecto

477
00:43:25,360 --> 00:43:30,120
está muy bien, pero no tanto como el gestor de contexto quiz, que en esencia una abstracción de

478
00:43:30,120 --> 00:43:34,720
la entrada y la salida. Hay una cosa muy habitual, que es que quiero leer un fichero, pero tengo que

479
00:43:34,720 --> 00:43:41,000
garantizarme que lo cierro aunque haya una excepción. Esto sería el típico try, except, finally. El

480
00:43:41,000 --> 00:43:45,640
width, que es como abrimos un fichero, de forma recomendada, lo que nos permita es que nosotros

481
00:43:45,640 --> 00:43:49,680
nos tengamos que olvidar por completo de cerrar el fichero. Sabemos que cuando abandonamos el bloque,

482
00:43:49,680 --> 00:43:57,080
se nos va a cerrar, sea porque los acontecimientos sigan su curso o porque hay algún error. Y del

483
00:43:57,080 --> 00:44:03,000
mismo módulo, y eso es genial, tenemos pilas incluidas y podemos, con el módulo csv, podemos

484
00:44:03,000 --> 00:44:08,040
simplemente leer el fichero y entonces generar esto de hecho no es una función, pero no va

485
00:44:08,040 --> 00:44:12,760
a haber un generador, porque estamos utilizando yield. Lo bueno de eso es que vamos congelamos el estado

486
00:44:12,760 --> 00:44:18,200
de la función y cada vez que llamemos a la función con su next no va a haber la otra. Y si lo hacemos

487
00:44:18,200 --> 00:44:22,920
así, de hecho, podemos utilizar una lista de procomprición, porque no pasa en brifar las cosas. Yo no

488
00:44:22,920 --> 00:44:26,880
quería introducir las coordenadas de valencia a mano, lo que dije es muy bien. Voy a crear una

489
00:44:26,880 --> 00:44:32,520
variable que se llama airport, que va a tener un diccionario en el cual asocio el código de cada

490
00:44:32,520 --> 00:44:37,240
ciudad de cada aeropuerto, lo asocio con el objeto aeropuerto, donde tengo toda la información

491
00:44:37,240 --> 00:44:42,640
que me importa. Si hago esto, el código funciona, que siempre es mi maravilla cuando mi programa

492
00:44:42,640 --> 00:44:48,800
funciona. Y podemos decir muy bien, aeropuertos, dame vlc, pues nos dice en efecto, ese aeropuerto

493
00:44:48,800 --> 00:44:53,200
corresponde a valencia y ahí tenemos unas coordenadas que son las nuestras, donde estamos ahora mismo.

494
00:44:53,200 --> 00:44:58,400
Y bueno, Portland tiene un código que nunca hubiera adivinado, que es PDX y ese es el aeropuerto que

495
00:44:58,400 --> 00:45:03,720
está en Oregon, en Estados Unidos. Pero todo consiste en añadir capas de extracción. Tenemos otra,

496
00:45:03,720 --> 00:45:08,680
que son un fichero que son los vuelos. Y los vuelos tienen mucha información, pero lo que nos importa

497
00:45:08,680 --> 00:45:14,280
es el código de aeropuerto de origen, el de salida, y si tiene escala o no, porque este fichero

498
00:45:14,280 --> 00:45:19,000
también guarda si el vuelo tiene paradas. Nosotros queramos considerar vuelos directos. Entonces digo,

499
00:45:19,000 --> 00:45:23,880
bueno, voy a hacer lo mismo. Voy a abrir el fichero de vuelos, que aquí lo guardé como flights.dat,

500
00:45:23,880 --> 00:45:29,360
y voy a tener otra tupla nombrada, en la cual almaceno origen y destino. Entonces cada uno de esos objetos

501
00:45:29,360 --> 00:45:34,760
de la clase vuelo, lo que va a almacenar es una conexión entre dos ciudades. Si lo hacemos así,

502
00:45:36,360 --> 00:45:41,440
lo mismo que antes, solo tenemos que tener en cuenta que como puede ser que hubiera vuelos comparadas,

503
00:45:41,440 --> 00:45:46,880
pues queremos que la variación, que ese valor sea cero. Solamente si tenemos el vuelo 100 escala,

504
00:45:46,880 --> 00:45:51,720
devuelvo esos objetos y si no lo ignoro en el fichero. Y bueno, podemos ver que entonces si digo

505
00:45:51,720 --> 00:45:56,000
muy bien Valencia, qué objeto es Valencia, pues de todos los aeropuertos, el que corresponde a

506
00:45:56,000 --> 00:46:01,160
esta ciudad. Y quiero que me diga todos los vuelos a los que puedo ir desde Valencia, pues simplemente

507
00:46:01,160 --> 00:46:11,200
itero sobre lo que me devuelve en GetFlights, que es un generador, y comprobo que el código de

508
00:46:11,200 --> 00:46:16,200
la cidad de origen, en efecto Valencia, podemos obtener fácilmente una lista con todos los vuelos

509
00:46:16,200 --> 00:46:19,000
a los que podemos ir desde Valencia. Tenemos un montón de destinos, ¿cómo elegimos ahora?

510
00:46:19,000 --> 00:46:23,520
Bueno, si estamos en un grafo. Y los grafos suelen ser la implementación es muy muy muy fea,

511
00:46:23,520 --> 00:46:28,440
porque lo que suelen hacer son más complejas de entender, porque lo que hacen es muy bien,

512
00:46:28,440 --> 00:46:31,520
pues tengo la clase nodo y la clase nodo tiene una clase vértice, tiene una clase de distancia,

513
00:46:31,520 --> 00:46:36,760
lo podemos hacer mucho más sencillo y es con una tabla hash, porque como la tabla hash es la

514
00:46:36,760 --> 00:46:42,200
estructura de datos más importante conocida por la humanidad, lo digo siempre, podemos resolverlo

515
00:46:42,200 --> 00:46:46,560
muy sencillo. Yo lo que propongo es hacer una cosa, voy a crear un diccionario por defecto,

516
00:46:46,560 --> 00:46:51,960
que ya lo conocemos, en lo cual lo que tengo es un conjunto para cada uno de los elementos

517
00:46:51,960 --> 00:46:57,880
del diccionario. Entonces cuando tú me digas que conecte el nodo A y el nodo B, lo que voy a

518
00:46:57,880 --> 00:47:03,160
decir es muy bien, pues A es uno de los vecinos, uno de los nodos a los que puedo llegar desde B y

519
00:47:03,160 --> 00:47:09,000
B lo es de A. Con lo cual tengo que ocupar más memoria, pero simplifican muchísimo la implementación,

520
00:47:09,000 --> 00:47:14,760
del mismo modo cuando me digas a qué nodo está conectado este nodo aquí, pues simplemente te

521
00:47:14,760 --> 00:47:19,920
devuelveré todo el conjunto de nodos vecinos que yo guardé. Si lo hacemos así, podemos ver que

522
00:47:19,920 --> 00:47:23,640
funciona, porque si digo conecta A con B, A con C y B con C, entonces cuando yo le diga muy bien,

523
00:47:23,640 --> 00:47:28,440
cuáles son los vecinos de A, pues nuestra clase se va a ir el diccionario por defecto, va a ver

524
00:47:28,440 --> 00:47:34,320
donde está conectado, va a ver la entrada de A y a le va a llevar a un conjunto donde están

525
00:47:34,320 --> 00:47:43,240
B y C. Aquí se nos devuelve como C y B, porque los sets no tienen orden en Python, verdad. Entonces

526
00:47:43,240 --> 00:47:49,640
bueno, para simplificarlo aún más, porque no quiero pensar, dije muy bien pues dime, vamos a tener

527
00:47:49,640 --> 00:47:53,280
un método que nos devuelva un grafo con directamente ya toda la información del mundo, pues entonces

528
00:47:53,280 --> 00:47:57,040
cuando llamo a mi método a esta función, lo que hace es crear un grafo vacío y lo que hace es que

529
00:47:57,040 --> 00:48:01,680
para cada uno de los vuelos que hay en el fichero de vuelos conecta las dos ciudades y me devuelve

530
00:48:01,680 --> 00:48:07,280
el grafo, con lo cual ya puedo trabajar con un grafo, un objeto muy abstraído que me dice mundo y

531
00:48:07,280 --> 00:48:11,280
entonces yo puedo decir muy bien, para cada uno de los destinos a los que puedo llegar desde Valencia,

532
00:48:11,280 --> 00:48:15,640
imprimemelo y se nos va simplificando aún más el código. Ahora ya obtener todos los vuelos

533
00:48:15,640 --> 00:48:19,160
que puedo llegar desde Valencia con información real, que está súper chulo, se hace así.

534
00:48:21,000 --> 00:48:26,160
Pero claro, los precios, lo que nos importamos y para los precios tenemos un problema y es que la

535
00:48:26,160 --> 00:48:30,000
información de los vuelos es la de verdad difícil de conseguir. Estuve hablando con uno de los

536
00:48:30,000 --> 00:48:34,720
patrocinadores ayer, agentes de SkyScanner y me dijeron que hay compañías que si te permiten

537
00:48:34,720 --> 00:48:39,440
que vean los precios, pero hay otras que no, porque es parte de su juego. Entonces,

538
00:48:39,440 --> 00:48:43,960
tienes que, esa es una pelea realmente. Entonces en este caso, por simplificar lo que dije es muy

539
00:48:43,960 --> 00:48:48,600
bien, pues vamos a hacer una cosa, vamos a asumir que nos cobran de forma proporcional a la distancia,

540
00:48:48,600 --> 00:48:52,960
que la vida real nunca es así, pero si lo hiciéramos así y dijéramos muy bien, pues vamos a tener,

541
00:48:52,960 --> 00:48:57,600
nos van a cobrar 10 céntimos por kilómetro. Entonces, para calcular la distancia entre

542
00:48:57,600 --> 00:49:01,680
los dos nodos, lo único que tengo que hacer es ver la distancia que hay entre los dos nodos y

543
00:49:01,680 --> 00:49:07,800
multiplicarlo por esa constante. La distancia de Javersine, esta que yo no la conocía, ni siquiera

544
00:49:07,800 --> 00:49:13,160
sé cómo se pronuncia bien, es bueno, por la distancia curva que no es recta porque una

545
00:49:13,160 --> 00:49:16,800
esfera funciona así. Y podemos ver que, por ejemplo, de Valencia está Heathrow, pues si

546
00:49:16,800 --> 00:49:23,280
dejamos cuáles el precio, pues nos diría pues 133 euros en este modelo simplificado. Y ya llegamos

547
00:49:23,280 --> 00:49:31,480
a Dijkstra. Y en tres minutos podemos implementarlo, porque Dijkstra, lo que está haciendo otro código,

548
00:49:31,480 --> 00:49:36,320
es exactamente lo que estábamos haciendo a mano y es voy a utilizar una hip, por eso teníamos que

549
00:49:36,320 --> 00:49:40,880
conocerla. Y entonces voy a empezar por el origen. ¿Cuál es el origen? El argumento que se llama

550
00:49:40,880 --> 00:49:47,680
origen. Para cada uno de los vecinos a los que puedo llegar desde el origen, voy a calcular cuánto

551
00:49:47,680 --> 00:49:54,480
me cuesta llegar al origen con getPrice y voy a añadirlo a la hip. ¿Por qué necesito añadirlo a la

552
00:49:54,480 --> 00:50:00,800
hip? Porque esto no lo simplifica un montón. Yo simplemente arrojo cosas a la hip y en cada momento

553
00:50:00,800 --> 00:50:05,960
diré, dame el más cercano, dame el más cercano. Si no lo haces con la hip, hay gente que lo que

554
00:50:05,960 --> 00:50:10,800
dice es muy bueno, pues voy a tener una tabla en la cual voy almacenando la distancia a cada sitio,

555
00:50:10,800 --> 00:50:14,680
pero tú lo complica muchísimo, porque luego tienes que irte allí y decir muy bien, ¿cuándo tardaba

556
00:50:14,680 --> 00:50:19,720
antes? ¿Cuándo tardó ahora? Es mucho más sencillo con una hip. Yo simplemente para cada una distancia la

557
00:50:19,720 --> 00:50:24,040
voy añadiendo a la ciudad, porque tengo la garantía a la hip, porque tengo la garantía de que siempre

558
00:50:24,040 --> 00:50:29,600
tendré la más baja. Necesito llevar la cuenta de que he visitado y que no he visitado. Eso lo

559
00:50:29,600 --> 00:50:34,760
podríamos hacer con un set y digo muy bien en el origen ya he estado, con lo cual añadete al conjunto

560
00:50:34,760 --> 00:50:40,480
de elementos visitados. Según de transparencia de tres de Dijkstra. Y ahora voy a repetir lo mismo

561
00:50:40,480 --> 00:50:45,280
que lo que estábamos haciendo antes todo el rato. Dime cuál es el aeropuerto más cercano a los que

562
00:50:45,280 --> 00:50:51,760
no he llegado aún. Entonces me voy a la hip y le digo, dame el elemento más cercano. Y entonces

563
00:50:51,760 --> 00:50:55,960
nos dirá el precio, porque estamos almacenando la información de cuánto ya hemos gastado para

564
00:50:55,960 --> 00:51:00,480
llegar a este vecino y nos dirá qué aeropuerto es. Y entonces decimos muy bien, he estado ya en este

565
00:51:00,480 --> 00:51:07,320
aeropuerto, si ya he estado, continúe y paso a la siguiente iteración. Esto es muy sencillo, porque

566
00:51:07,320 --> 00:51:11,320
simplemente lo que voy diciendo, dame otro, dame otro, dame otro. Y si ya he estado, dame otro,

567
00:51:11,320 --> 00:51:16,800
dame otro. Y repito hasta que encuentro uno en el cual todavía no he estado. Esto es la forma

568
00:51:16,800 --> 00:51:20,800
muy eficiente y muy sencilla del punto de vista conceptual de lo que estábamos haciendo a

569
00:51:20,800 --> 00:51:23,920
nosotros a mano, que de hecho en esencia era lo mismo, porque nosotros mirábamos todos los vecinos.

570
00:51:25,440 --> 00:51:29,440
Hemos llegado, pues ya está, si el aeropuerto en el que el aeropuerto más cercano que había

571
00:51:29,440 --> 00:51:35,880
ahora era el destino he terminado, dime cuánto me he gastado en total. Y si no, pues repito lo que

572
00:51:35,880 --> 00:51:40,320
habíamos hecho antes, que se parece un montón a las primeras líneas del método. Digo muy bien,

573
00:51:40,320 --> 00:51:45,680
para cada uno de los vecinos de este aeropuerto que me has dado ahora, si el vecino aún no lo he

574
00:51:45,680 --> 00:51:50,000
visitado, porque si no es molestarse para nada, cálculame el precio que me costaría llegar

575
00:51:50,000 --> 00:51:54,000
hasta allí. Es decir, lo que llevo ya gastado, más lo que me costaría llegar ahora a este nuevo

576
00:51:54,000 --> 00:51:59,880
vecino y añádemelo a la hip y repetimos. Bueno, por supuesto hay que marcar como que hemos visitado

577
00:51:59,880 --> 00:52:10,720
este sitio. En total, el código de Dijkstra es esto. Y bueno, por supuesto es una simplificación,

578
00:52:10,720 --> 00:52:14,720
porque la vida real tendemos que tener en cuenta otra vez, como por ejemplo, y si no se puede

579
00:52:14,720 --> 00:52:17,960
llegar de un destino a otro, con lo aviones si se puede, pero si no podríamos llegar,

580
00:52:17,960 --> 00:52:22,240
pues entonces ese guay trué tendría que tener en cuenta, no sería un guay trué,

581
00:52:22,240 --> 00:52:26,760
sería mientras nos quedaran cosas que visitar. Se podría retocar un poco, pero la esencia de

582
00:52:26,760 --> 00:52:32,520
todo el algoritmo es ese. Por ejemplo, si dice muy bien, de Valencia por Lancajo, ¿cómo podemos

583
00:52:32,520 --> 00:52:39,400
llegar? No dice, se puede llegar por 917 euros, pero eso no sirve de mucho. Una modificación de

584
00:52:39,400 --> 00:52:43,720
dos líneas es que no quiero saber el precio, quiero saber la ruta. Pues para la ruta lo

585
00:52:43,720 --> 00:52:48,840
único que tenemos que hacer es, en vez de tener en cuenta el precio, tenemos también en cuenta

586
00:52:48,840 --> 00:52:53,440
otra cosa, que es los nodos que ya he visitado. Entonces si lo que tengo es una cosa que sea ruta,

587
00:52:53,440 --> 00:52:59,240
donde es una lista, lo que puedo hacer es ir añadiendo para cada una de las rutas posible,

588
00:52:59,240 --> 00:53:02,560
añado siempre el siguiente elemento que he visitado. Con lo cual lo que tengo en la lista,

589
00:53:02,560 --> 00:53:07,360
con todo el camino que hice. Si lo cambiamos a eso, podemos ver que funciona y cuando calculamos

590
00:53:07,360 --> 00:53:11,800
la ruta desde Valencia hasta Porlan, nos dice exactamente, podemos hacerlo haciendo escala

591
00:53:11,800 --> 00:53:16,520
en Islandia, después tenemos que parar en Seattle y en Estados Unidos y llegaríamos a Porlan.

592
00:53:17,440 --> 00:53:21,160
Por supuesto, como hemos utilizado una simplificación que es que los precios son

593
00:53:21,160 --> 00:53:25,520
directamente proporcionales y a la distancia este algoritmo nos está calculando una ruta que

594
00:53:25,520 --> 00:53:31,680
misteriosamente va por aquí. En la vida real no sería así, en la vida real tenemos economías y

595
00:53:31,680 --> 00:53:35,440
entonces tendríamos algunas rutas que son muy baratas, otras las cuales es muy poca demanda y

596
00:53:35,440 --> 00:53:41,280
la ruta real no sería así. De hecho hice pruebas intentando, utilizando páginas de verdad y una

597
00:53:41,280 --> 00:53:47,600
ruta real sería ir a Holanda y de Holanda hay ruta directa, un vuelo directo a Porlan. Así que tendremos

598
00:53:47,600 --> 00:53:57,440
que hacer eso. Dijkstra decía que la elegancia es un lujo de que puedas prescindir, sino que es un

599
00:53:57,440 --> 00:54:03,600
elemento que decide entre el éxito y el fracaso y cuando Dijkstra decía elegancia, lo he estado

600
00:54:03,600 --> 00:54:07,720
mirando antes para asegurarme, él se refería a elegancia en su sentido matemático que es el de

601
00:54:07,720 --> 00:54:21,480
claridad y sencillez. Como último ejemplo, alguien sabe qué hace esto. Esto multiplica por 320 porque

602
00:54:21,480 --> 00:54:30,920
2 elevado a 8 más 2 elevado a 6 es 320 y podría ser más rápido, puede que sea más rápido. De hecho

603
00:54:30,920 --> 00:54:35,280
hay un principio de la gente de bajo nivel que no ayuda a ese compilador, que me encanta, porque el

604
00:54:35,280 --> 00:54:41,240
compilador es mucho más listo que tú por definición y menos feo. Así que tú pones que quede multiplicado

605
00:54:41,240 --> 00:54:45,160
por 320 y toda esa gente mucho más lista que nosotros que ya lo he hecho antes en cargar de

606
00:54:45,160 --> 00:54:51,040
optimizarlo, puede que fuera en algún escenario mucho más rápido eso y puede que fuera la diferencia

607
00:54:51,040 --> 00:54:56,240
entre la vida y la muerte. Normalmente no lo es y yo creo que es mucho más sencillo decir x por 360.

608
00:54:57,720 --> 00:55:04,120
Y para cerrar conmigo estaría de acuerdo Douglas Jones que decía que el algoritmo más rápido

609
00:55:04,120 --> 00:55:08,240
que hace siempre se puede reemplazar por uno un poquito más despacio pero que es mucho más fácil

610
00:55:08,240 --> 00:55:13,360
de entender. Yo prefiero multiplicar por 320 que trabajar con potencias de 2 desplazando la de

611
00:55:13,360 --> 00:55:34,920
al izquierda y cosas así. Y eso es todo, muchas gracias.

