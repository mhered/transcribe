1
00:00:00,000 --> 00:00:10,620
Vale, ya amamos más de tiempo, no sé si alguien ha visto eso, pero me gustaría empezar

2
00:00:10,620 --> 00:00:11,620
con una cita...

3
00:00:11,620 --> 00:00:17,540
Vamos mal, me gustaría empezar con una cita de Dijkstra, que está muy chula, que de

4
00:00:17,540 --> 00:00:21,140
hecho es falsa, y si la miráis en internet básicamente se la atribuyó una cita que

5
00:00:21,140 --> 00:00:25,460
no dijo nunca, que era que la formación orientada a objeto era una cosa que era muy mala idea,

6
00:00:25,460 --> 00:00:28,100
que solamente podía haber ocurrido en California, por supuesto.

7
00:00:28,100 --> 00:00:32,540
La cita realmente de verdad es esta, que quizá es más o menos lo mismo, pero no del

8
00:00:32,540 --> 00:00:33,540
todo.

9
00:00:33,540 --> 00:00:38,100
Y bueno, Dijkstra mola muchísimo, lo sabéis, y los artículos aquellos que escribían mano,

10
00:00:38,100 --> 00:00:43,060
que se escaneban en PDF, merecen la pena echarle un vistazo porque son siempre muy reveladores.

11
00:00:43,060 --> 00:00:47,780
El objetivo de la clase de esta charla es intentar que consigamos hacer clases que

12
00:00:47,780 --> 00:00:49,460
sean un poquito más bonitas.

13
00:00:49,460 --> 00:00:53,380
El título de la charla no buscaba ofender a nadie, como hoy quien me ha dicho en el

14
00:00:53,380 --> 00:00:58,380
descanso era simplemente provocar un poco, porque muchas veces vemos cosas que son un

15
00:00:58,380 --> 00:00:59,380
poco feas.

16
00:00:59,380 --> 00:01:01,540
Y de hecho el objetivo es intentar sentirnos así.

17
00:01:01,540 --> 00:01:07,460
Ya sea viendo el código nuestro, viendo el código de terceros que hayan perpetrado.

18
00:01:07,460 --> 00:01:11,220
Un requisito indispensable, estamos viendo una cosa orientada a clase, se supone que sabemos

19
00:01:11,220 --> 00:01:14,460
al menos trabajar un poquitín con clases, que alguna vez hemos hecho algo que tiene

20
00:01:14,460 --> 00:01:18,020
un init y que hemos guardado un atributo en un objeto nuestro.

21
00:01:18,020 --> 00:01:20,180
Es una obviedad, pero era por comentarlo.

22
00:01:20,180 --> 00:01:23,580
Pero podamos hacer un repaso muy breve.

23
00:01:23,580 --> 00:01:29,060
Básicamente lo que es clase, que nos enseñaron o miramos en la Wikipedia, la clase de la reversación

24
00:01:29,060 --> 00:01:31,860
abstracta de un concepto ya sea perro o número entero.

25
00:01:31,860 --> 00:01:37,180
Y entonces se componen de atributos y de métodos, aunque luego podríamos hablar de eso.

26
00:01:37,180 --> 00:01:40,700
Y bueno, entonces tenemos una clase que puede ser la clase perro y entonces luego tenemos

27
00:01:40,700 --> 00:01:43,860
objetos que es cada una de esas identidades perro, como por ejemplo lasji.

28
00:01:43,860 --> 00:01:46,020
Lasji sería un objeto de la clase perro.

29
00:01:46,020 --> 00:01:48,860
Se podría hablar muchísimo más, pero con esto podemos empezar a andar hacia adelante.

30
00:01:48,860 --> 00:01:50,340
Por ejemplo, clase perro.

31
00:01:50,340 --> 00:01:54,780
Pues yo tengo un perro que cuando se crea, lo que llamamos el constructor, en verdad,

32
00:01:54,780 --> 00:01:57,300
init por recibir nombre, raza y edad.

33
00:01:57,300 --> 00:01:59,940
Y guardamos eso en atributos de la clase.

34
00:01:59,940 --> 00:02:04,300
Y luego tenemos métodos que son operaciones que trabajan con esos datos.

35
00:02:04,300 --> 00:02:07,140
Y entonces por ejemplo aquí tenemos un método que es ladra, que lo que hace es que por pantalla

36
00:02:07,140 --> 00:02:08,300
por el lasji nos diga...

37
00:02:08,300 --> 00:02:12,340
Cuando esto le ajustamos, por el lasji, porque su nombre nos diría Woof.

38
00:02:12,340 --> 00:02:15,580
Me gustó mucho la charla de programación funcional en Python, porque las críticas

39
00:02:15,580 --> 00:02:19,100
de programación orientadas a objetos también son muy interesantes.

40
00:02:19,100 --> 00:02:20,100
Sí, claro.

41
00:02:20,100 --> 00:02:48,420
A ver, ahí que está el joven de tu chip ha perdido la tarjeta para entrar a la audiencia.

42
00:02:48,420 --> 00:02:55,420
Gracias.

43
00:02:55,420 --> 00:03:00,360
Sube ser muy aburrido escuchar a las varias partes de la gente y solo es cierto, me ha

44
00:03:00,360 --> 00:03:03,620
aburrido escucharlo durante una hora, así que me encantaría levantar la mano a alguien

45
00:03:03,620 --> 00:03:05,220
y dijera eso es una tontería.

46
00:03:05,220 --> 00:03:08,340
El año pasado no ocurrió, aunque ocho meses después alguien me envió un parche porque

47
00:03:08,340 --> 00:03:09,340
había un fallo en las transparencias.

48
00:03:09,340 --> 00:03:10,340
Y me dice muchísima ilusión.

49
00:03:10,340 --> 00:03:13,700
De hecho iba a poner su foto aquí dándole las gracias, pero no le pregunte.

50
00:03:13,700 --> 00:03:14,700
Así que no lo hice.

51
00:03:14,700 --> 00:03:18,700
Y al final del repositorio, tenéis la presentación que es un maquefile con scripts y tal que

52
00:03:18,700 --> 00:03:20,780
generan las 230 transparencias.

53
00:03:20,780 --> 00:03:25,460
Si queráis bajar el PDF, como queráis utilizarlo de base por algún día o simplemente señalar

54
00:03:25,460 --> 00:03:28,860
algún error, me encantaría escuchar de vosotros, ya sea aquí o después de la charla.

55
00:03:28,860 --> 00:03:32,020
Y básicamente se me ha ocurrido que podíamos ver 10 cosas.

56
00:03:32,020 --> 00:03:33,860
El aire original era muchas más, pero...

57
00:03:33,860 --> 00:03:37,140
Pasada las 200 transparencias me di cuenta de que había algo mal.

58
00:03:37,140 --> 00:03:39,540
Y empezamos numerando por cero.

59
00:03:39,540 --> 00:03:42,740
Eso es un homenaje a Dijkstra también, que tiene un articulito muy corto que dice por

60
00:03:42,740 --> 00:03:45,980
qué la numeración debería empezar en cero y que merecería apenas echarle un vistazo.

61
00:03:45,980 --> 00:03:47,900
Lo primero es por qué heredamos de objetos.

62
00:03:47,900 --> 00:03:51,700
Porque nosotros cuando creamos una clase y llegamos al mundo de Python 2000, como la

63
00:03:51,700 --> 00:03:55,740
más parte de la gente, nos decían que para que nuestra clase sea de estilo nuevo, tenemos

64
00:03:55,740 --> 00:03:56,740
que heredar de objetos.

65
00:03:56,740 --> 00:04:00,860
Y aquí lo vemos por ejemplo, tenemos la clase perro y entonces hacemos que herede de objetos.

66
00:04:00,860 --> 00:04:01,900
Y siempre tenemos que hacerlo así.

67
00:04:01,900 --> 00:04:02,900
¿Por qué?

68
00:04:02,900 --> 00:04:06,740
Es decir, ¿qué significa exactamente que sea esto de New Style?

69
00:04:06,740 --> 00:04:13,740
Esta cosa apareció en diciembre de 2001, que hace ya una pecha tiempo, y fue en Python

70
00:04:13,740 --> 00:04:14,740
2.2.

71
00:04:14,740 --> 00:04:18,260
No es poner demasiado técnico, ni demasiado profundo, pero es que hasta Python 2.1 el

72
00:04:18,260 --> 00:04:20,860
concepto de clase no tenía relación con el tipo.

73
00:04:20,860 --> 00:04:24,340
Es decir, todos los objetos de todas las clases, cuando tú mirabas con type, ¿qué eran?

74
00:04:24,340 --> 00:04:25,340
Te decían type instance.

75
00:04:25,340 --> 00:04:30,420
De hecho, esta vez en alguna librería que no ha cambiado todavía se sigue viendo.

76
00:04:30,420 --> 00:04:34,660
Lo que hicieron básicamente con las clases New Style es que lo que estamos definiendo

77
00:04:34,660 --> 00:04:36,900
son nuestros propios tipos.

78
00:04:36,900 --> 00:04:39,620
¿Qué pasa si no tenemos de objetos?

79
00:04:39,620 --> 00:04:43,340
Pues efectivamente cuando miramos el tipo con type, nos dice, tú no eres como ya hemos

80
00:04:43,340 --> 00:04:45,260
visto antes, que eres de clase perro.

81
00:04:45,260 --> 00:04:50,660
Perdón, no eres de clase perro, sino que tú tienes una clase, pero tu tipo es diferente.

82
00:04:50,660 --> 00:04:53,460
Pero no solamente una cuestión de que devuelve type, por supuesto, si no sería simplemente

83
00:04:53,460 --> 00:04:54,460
estético.

84
00:04:54,460 --> 00:05:00,700
Antes no existía super, no existía los descriptores, no existía slots, el orden de resolución

85
00:05:00,700 --> 00:05:04,020
de métodos, cuando estamos trabajando con herencia, trabajaba de otra forma.

86
00:05:04,020 --> 00:05:06,820
Y también podemos hacer una cosa muy fea, que siempre venía los manuales y nunca entendíamos

87
00:05:06,820 --> 00:05:10,260
para qué, de lanzar una clase como si fuera una excepción, aunque no era de Aramos, como

88
00:05:10,260 --> 00:05:12,460
es que era hora de excepción.

89
00:05:12,460 --> 00:05:15,180
Yo estoy enganchado a Stack Overflow totalmente.

90
00:05:15,180 --> 00:05:19,060
De hecho, calculo que últimamente estoy como 6 horas de área allí, solo leyendo, nunca

91
00:05:19,060 --> 00:05:20,060
portando nada.

92
00:05:20,060 --> 00:05:25,700
Y tengo cientos de enlaces a Stack Overflow, porque el concepto de karma y el concepto de

93
00:05:25,700 --> 00:05:30,300
reputación hace que la gente se ocurre de verdad unas explicaciones muy chulas.

94
00:05:30,300 --> 00:05:33,060
Así que está plagado esto de un montón de enlaces.

95
00:05:33,060 --> 00:05:36,700
Yo recomiendo que le eche un ojo si os interesa un tema.

96
00:05:36,700 --> 00:05:41,180
Básicamente, ¿qué ocurre cuando teníamos una clase New Style ya no nos deja país aunque

97
00:05:41,180 --> 00:05:42,980
hagamos esa cosa tan fea como lanzar como una excepción?

98
00:05:42,980 --> 00:05:45,580
No, es decir, no tienes que le dar de exception para poder lanzarme.

99
00:05:45,580 --> 00:05:49,940
Sin embargo, las clases antiguas, las que no eran de Object, en efecto, podíamos decir

100
00:05:49,940 --> 00:05:52,700
Throw y se lanzaban.

101
00:05:52,700 --> 00:05:58,020
Por compatibilidad, bueno, en Payson 3 todas las clases ya...

102
00:05:58,020 --> 00:06:01,700
Por compatibilidad, cuando se añadieron las clases New Style y en 2.2 se decidió que

103
00:06:01,700 --> 00:06:03,620
todo sigiera siendo All Style por defecto.

104
00:06:03,620 --> 00:06:06,060
O sea, que tenemos que hacer de forma explícita heredar de Object.

105
00:06:06,060 --> 00:06:11,700
En Payson 3 no tenemos por qué especificar que heredamos de Object porque todo es New

106
00:06:11,700 --> 00:06:16,740
Style, pero he leído por ahí que alguien recomienda que por ser explícito se siga heredando.

107
00:06:16,740 --> 00:06:19,380
La moral deja y lo único interesante de la última 5 minutos hay que heredar de Object

108
00:06:19,380 --> 00:06:22,140
porque sí, desde hace un montón de tiempo.

109
00:06:22,140 --> 00:06:23,140
Super.

110
00:06:23,140 --> 00:06:27,580
La función Super es lo que sabemos que cuando estamos trabajando con herencia, Super lo

111
00:06:27,580 --> 00:06:30,380
utilizamos para llamar a un método de la clase base.

112
00:06:30,380 --> 00:06:31,860
Ahora vamos a ver un ejemplo.

113
00:06:31,860 --> 00:06:34,900
Y formalmente lo que nos devuelve a un objeto proxy es que lo que haces es delegar la llamada

114
00:06:34,900 --> 00:06:38,900
en alguien que está por arriba, en alguno de mis ancestros.

115
00:06:38,900 --> 00:06:39,900
Vamos a ver un ejemplo.

116
00:06:39,900 --> 00:06:45,420
Nosotros tenemos una clase lista y vamos a hacer una subclase de lista que nos va a permitir

117
00:06:45,420 --> 00:06:49,980
trabajar con listas, pero cada vez que añadamos un append, cada vez que añadamos algo, al

118
00:06:49,980 --> 00:06:52,340
final de la lista lo que haces es que nos dis por pantalla.

119
00:06:52,340 --> 00:06:53,900
He añadido algo.

120
00:06:53,900 --> 00:06:58,100
Pues esto no funciona porque nosotros podíamos decir muy bien, pues entonces append me va

121
00:06:58,100 --> 00:07:02,300
a añadir y lo que voy a hacer va a ser imprimir y entonces ya hago el append de verdad.

122
00:07:02,300 --> 00:07:05,740
El problema es que eso entra en un problema de recursión infinita porque el método está

123
00:07:05,740 --> 00:07:06,740
llamándose a sí mismo.

124
00:07:06,740 --> 00:07:11,580
Entonces nosotros cuando queremos, este es un escenario en el cual lo que queremos hacer

125
00:07:11,580 --> 00:07:14,980
es utilizar un método de la clase base de la que hemos heredado.

126
00:07:14,980 --> 00:07:21,020
Entonces cuando usamos Super, Super tiene esta sintasi que en Python 3 como otras tantas

127
00:07:21,020 --> 00:07:24,700
cosas mejoró y lo que tenemos que decirle a Super es muy bien, yo soy una clase lista

128
00:07:24,700 --> 00:07:28,500
logger, estoy en self y me vas a llamar a append.

129
00:07:28,500 --> 00:07:31,940
Esto es lo que hace básicamente que cuando en vez de ejecutarse el append, el método

130
00:07:31,940 --> 00:07:34,140
del mismo nombre, aquí lo que hace es irse arriba.

131
00:07:34,140 --> 00:07:39,060
Se va a la clase de la que he heredado que es lista y entonces ya inserto el elemento

132
00:07:39,060 --> 00:07:41,820
en la lista utilizando el método de la clase de la que he heredado.

133
00:07:41,820 --> 00:07:44,180
Y aquí ya vemos que sí funciona.

134
00:07:44,180 --> 00:07:48,100
Un segundo ejemplo sería que tuviéramos una clase punto que recibe por el constructor

135
00:07:48,100 --> 00:07:51,780
tanto x como y y luego definimos círculo que es lo que tiene un punto que nos da en el

136
00:07:51,780 --> 00:07:54,900
centro del círculo y el radio.

137
00:07:54,900 --> 00:07:59,060
Bueno, entonces decimos muy bien cómo inicializo el punto.

138
00:07:59,060 --> 00:08:03,500
El centro es lo que hago a llamar a estoy en círculo, super círculo self y llamo al

139
00:08:03,500 --> 00:08:08,580
init de la clase de círculo.

140
00:08:08,580 --> 00:08:09,580
No deja de ser otro ejemplo.

141
00:08:09,580 --> 00:08:14,180
En Python 3 ha mejorado un montón y ya simplemente tenemos que decirle super, no tenemos que,

142
00:08:14,180 --> 00:08:17,180
porque esto era un poco redundante, porque tengo que decirle dónde estoy y porque tengo

143
00:08:17,180 --> 00:08:18,580
que decirle pasarle self.

144
00:08:18,580 --> 00:08:22,380
Bueno, tiene su explicación, pero en Python 3 se mejoró y ya simplemente digo super,

145
00:08:22,380 --> 00:08:23,700
es decir, vete arriba.

146
00:08:23,700 --> 00:08:27,620
En este caso yo hago una pend, pero aquí no estoy llamando a la pend en self en mi

147
00:08:27,620 --> 00:08:32,300
mismo, sino que le digo vete a super, vete a mi papá, a mi mamá y al lo allí.

148
00:08:32,300 --> 00:08:37,100
Y entonces ya ese pend se hace en la clase base que es lista.

149
00:08:37,100 --> 00:08:40,380
Pero donde super, de verdad, me da un montón en esa cosa que nadie hace nunca realmente,

150
00:08:40,380 --> 00:08:42,260
que es la herencia múltiple.

151
00:08:42,260 --> 00:08:44,980
Y entonces es decir, cuando le damos de un montón de cosas.

152
00:08:44,980 --> 00:08:48,100
Yo creo que plantara un ejemplo de que tenemos un humano del cual se deriva un dos clase,

153
00:08:48,100 --> 00:08:51,180
se deriva la clase Cíborg y se deriva la clase Ninja.

154
00:08:51,180 --> 00:08:55,220
Y en homenaje a Terminator 2, que es una de mis peores favoritas, de mi adolescencia,

155
00:08:55,220 --> 00:08:59,660
pues tenemos el T-Mil y el T-Mil, según mis criterios, es un Cíborg y es un Ninja, porque

156
00:08:59,660 --> 00:09:00,660
también tienen.

157
00:09:00,660 --> 00:09:04,540
Y lo podemos discutir, pero tenía eso de metal líquido, ¿no?

158
00:09:04,540 --> 00:09:05,540
De que salía el mano.

159
00:09:05,540 --> 00:09:09,180
O sea, para mí es un Ninja.

160
00:09:09,180 --> 00:09:12,180
Entonces, vamos a decirlo podemos explicar cómo vamos de tiempo.

161
00:09:12,180 --> 00:09:14,580
Bueno, vamos mal.

162
00:09:14,580 --> 00:09:15,580
Tenemos la clase humano.

163
00:09:15,580 --> 00:09:17,060
La clase humano cuando ataca da un puñetazo.

164
00:09:17,060 --> 00:09:19,300
La clase Cíborg cuando ataca lanza un láser, por supuesto.

165
00:09:19,300 --> 00:09:22,020
Y la clase y el Ninja, por lo que tiras son Suriken, ¿no?

166
00:09:22,020 --> 00:09:23,020
Que son las estrellitas de ese.

167
00:09:23,020 --> 00:09:27,180
Entonces yo ahora defino una clase T-Mil que hereda tanto de Cíborg como de Ninja.

168
00:09:27,180 --> 00:09:28,420
El T-Mil lo tiene todo.

169
00:09:28,420 --> 00:09:31,860
Y cuando ataca, lo que hace es que recibe un parámetro que es cuántas veces voy a atacar

170
00:09:31,860 --> 00:09:34,980
y entonces lo que hace es lanzarte un montón de ataques de lo que he heredado.

171
00:09:34,980 --> 00:09:38,220
Entonces yo digo, muy bien, vamos a atacar cinco veces.

172
00:09:38,220 --> 00:09:40,460
T-Mil, ¿queres cargarte a John Connor?

173
00:09:40,460 --> 00:09:43,180
Pues antes de eso, vamos a ver qué ocurre con el M-Reo.

174
00:09:43,180 --> 00:09:48,860
Es decir, cuando el M-Reo lo que nos dice es no aplana el diagrama de...

175
00:09:48,860 --> 00:09:51,860
Siempre se me olvidó el diagrama de clase.

176
00:09:51,860 --> 00:09:55,740
El M-Reo lo que hace es que no aplana el diagrama de casi no dice exactamente quién es nuestro

177
00:09:55,740 --> 00:09:57,180
papá, quién es nuestro abuelo.

178
00:09:57,180 --> 00:09:58,580
Cuando le decimos T-Mil, ¿de quién viene?

179
00:09:58,580 --> 00:10:02,860
Pues nos dice, pues mira, vengo, soy heredo de Cíborg, heredo de Ninja y heredo de humano,

180
00:10:02,860 --> 00:10:07,060
que últimamente, en última instancia, hereda de objeto.

181
00:10:07,060 --> 00:10:10,300
Todo esto para decir que si nos fijamos el T-Mil ha lanzado lásers.

182
00:10:10,300 --> 00:10:14,460
Y entonces, muy bien, yo heredo tanto de Cíborg como de Ninja, Cíborg, Ninja.

183
00:10:14,460 --> 00:10:15,580
Y ha atacado con lásers.

184
00:10:15,580 --> 00:10:19,300
Es decir, la parte de la oma, no ha hecho el ataque que más nos gustaba que era el del

185
00:10:19,300 --> 00:10:20,300
Ninja.

186
00:10:20,300 --> 00:10:21,300
¿Por qué?

187
00:10:21,300 --> 00:10:27,380
Es decir, porque en primer lugar, lo que podríamos pensar cuando vemos esto al principio es que,

188
00:10:27,380 --> 00:10:30,940
vale, súper lo que hace es que se va hacia arriba, coge el método que define el papá

189
00:10:30,940 --> 00:10:31,940
y entonces lo usa.

190
00:10:31,940 --> 00:10:35,500
Y si mi clase base no define, me voy hacia arriba, ¿no?

191
00:10:35,500 --> 00:10:37,540
Así hasta que llegue a un punto de decir...

192
00:10:37,540 --> 00:10:41,940
Si Cíborg no definiera ataque, ¿qué va a ocurrir?

193
00:10:41,940 --> 00:10:44,580
Porque hemos heredado en primer lugar de Cíborg.

194
00:10:44,580 --> 00:10:50,700
Entonces yo le digo T-Mil, ataca, y con súper se va a la clase base y dice, muy bien, pues...

195
00:10:50,700 --> 00:10:51,700
coge.

196
00:10:51,700 --> 00:10:55,700
Dice, muy bien, Cíborg ataca, pero Cíborg no tiene el método ataque, entonces podríamos

197
00:10:55,700 --> 00:10:56,700
razonar.

198
00:10:56,700 --> 00:11:00,620
Bueno, pues entonces, a su vez ahora, Cíborg va a irse a la clase base y va a definir y

199
00:11:00,620 --> 00:11:02,260
va a ver cuál es el método ataque.

200
00:11:02,260 --> 00:11:04,540
Pero sin embargo, cuando lo ejecutamos, lo que vemos es que nos lanza suriken.

201
00:11:04,540 --> 00:11:07,700
Es decir, no se ha ido a la clase base y luego se ha ido a la clase base y luego se ha ido

202
00:11:07,700 --> 00:11:09,940
a la clase base, se ha ido al hermano.

203
00:11:09,940 --> 00:11:12,780
Entonces, es una cosa que vi un texto súper...

204
00:11:12,780 --> 00:11:17,060
Estaba muy enfadado que lo escribió y decía que el concepto realmente de súper clase

205
00:11:17,060 --> 00:11:19,500
no tiene sentido en un contexto de herencia múltiple.

206
00:11:19,500 --> 00:11:24,540
Y eso es lo que da mucho miedo de súper y también es súper guay.

207
00:11:24,540 --> 00:11:29,140
Y es que nos permite que construyamos clases componiendo...

208
00:11:29,140 --> 00:11:34,820
Bueno, con herencia múltiple, lo que podemos es componer nuestras clases...

209
00:11:34,820 --> 00:11:36,820
Sí, vamos, vamos.

210
00:11:36,820 --> 00:11:39,700
No, realmente es una excusa para pensar lo que iba a decir.

211
00:11:39,700 --> 00:11:42,100
Pero me he parado por vosotros.

212
00:11:42,100 --> 00:11:45,180
Los chulos de súper es que nos permite que compongamos otras clases que ya existen y

213
00:11:45,180 --> 00:11:49,700
la funcionalidad venga determinada por cómo hemos definido el orden de la herencia.

214
00:11:49,700 --> 00:11:53,820
Y eso es muy, muy, muy potente.

215
00:11:53,820 --> 00:11:57,540
Este otro ejemplo y básicamente lo que nos enseña es que el orden importa.

216
00:11:57,540 --> 00:12:00,300
Primero heredamos de Sieborg y luego de Ninja.

217
00:12:00,300 --> 00:12:03,580
Con lo cual, cuando decimos defiende, buscamos el defiende en el padre y dice,

218
00:12:03,580 --> 00:12:05,060
exactamente, tengo la armadura.

219
00:12:05,060 --> 00:12:08,260
Pero cuando hagamos ataca, vemos que nosotros no tenemos ataca, lo buscamos en el papá y

220
00:12:08,260 --> 00:12:09,620
entonces Sieborg.

221
00:12:09,620 --> 00:12:11,740
Sieborg no tiene ataca, entonces lo hemos buscado en el hermano.

222
00:12:11,740 --> 00:12:13,300
Por eso lanzamos Suriken.

223
00:12:13,300 --> 00:12:18,900
Es decir, en herencia múltiple, el orden importa y nos permite hacer unas cosas muy poderosas.

224
00:12:18,900 --> 00:12:23,140
Raymond Hettinger, que es uno de los enlaces que he enlazado aquí, lo tiene muy bien explicado

225
00:12:23,140 --> 00:12:28,140
y enseña como simplemente heredando de dos clases que ya tenemos en la librería Standard.

226
00:12:28,140 --> 00:12:31,460
Podemos hacer cosas como diccionarios, ordenados, que a su vez nos guardan un log de todo lo

227
00:12:31,460 --> 00:12:32,460
que hemos hecho.

228
00:12:32,460 --> 00:12:34,180
Es decir, es muy poderoso.

229
00:12:34,180 --> 00:12:35,180
La práctica nos da igual.

230
00:12:35,180 --> 00:12:38,420
Lo que utilizamos súper es para llamar a un método que está definido en alguna de

231
00:12:38,420 --> 00:12:41,660
las clases de las que heredamos, que casi siempre suele ser solamente una.

232
00:12:41,660 --> 00:12:44,700
Y el primer parámetro, que es self.

233
00:12:44,700 --> 00:12:47,340
Sabemos que cuando definimos el método de una clase, el primer parámetro tenemos que

234
00:12:47,340 --> 00:12:48,340
llamarlo self.

235
00:12:48,340 --> 00:12:51,180
Esto viene desde la primera página del manual y nosotros lo hacemos.

236
00:12:51,180 --> 00:12:54,180
Y sabemos que hay una referencia al objeto de la clase que ha llamado al método.

237
00:12:54,180 --> 00:12:55,180
¿Qué quiere decir eso?

238
00:12:55,180 --> 00:12:58,180
Bueno, sí, y es como el Dish, que no sonaba de otro lenguaje de programación.

239
00:12:58,180 --> 00:13:01,540
Pues, por ejemplo, aquí tenemos una clase punto que cuando llamamos al constructor,

240
00:13:01,540 --> 00:13:03,180
Init recibe tanto x como y.

241
00:13:03,180 --> 00:13:05,180
Y tiene un método que es la distancia, que es una tontería.

242
00:13:05,180 --> 00:13:08,700
Realmente lo que hace es que nos calcula la distancia entre los dos puntos y nos la

243
00:13:08,700 --> 00:13:09,700
devuelve.

244
00:13:09,700 --> 00:13:11,620
Pues nosotros esto no nos sorprende.

245
00:13:11,620 --> 00:13:22,620
Cuando hacemos el self.x, la pregunta es por qué.

246
00:13:22,620 --> 00:13:24,820
Bueno, lo primero es self es una convención.

247
00:13:24,820 --> 00:13:28,140
De hecho, podemos llamarlo de cualquier forma, aunque alguien se ofende si no lo llaméis

248
00:13:28,140 --> 00:13:30,140
self, porque es lo que hace todo el mundo.

249
00:13:30,140 --> 00:13:33,780
Aquí, por ejemplo, podemos llamarlo Dish y funciona exactamente igual.

250
00:13:33,780 --> 00:13:38,940
Es decir, no deja de ser el nombre de un parámetro que está recibiendo el método.

251
00:13:38,940 --> 00:13:40,740
¿Y por qué tenemos que definirlo?

252
00:13:40,740 --> 00:13:45,980
Pues, hay que ir propuso y era muy razonable aquí.

253
00:13:45,980 --> 00:13:48,500
Pues dijo vamos a hacer una cosa.

254
00:13:48,500 --> 00:13:49,500
No tenemos que definir self.

255
00:13:49,500 --> 00:13:54,580
Self siempre va a ser como una keyword, por ejemplo, que nos va a dar acceso al objeto

256
00:13:54,580 --> 00:13:57,460
en el que estamos ahora mismo, que es como vemos en otro lenguaje de programación.

257
00:13:57,460 --> 00:14:02,980
Entonces, lo que proponía era, pues yo propongo esto, que self recibe, no recibe el método,

258
00:14:02,980 --> 00:14:03,980
no recibe self.

259
00:14:03,980 --> 00:14:06,420
Pero yo simplemente digo, pues, Init recibe x y.

260
00:14:06,420 --> 00:14:08,500
Pero luego dentro puedo utilizar self.x.

261
00:14:08,500 --> 00:14:11,500
Y eso quería decir, pues, de donde estoy ahora mismo, pues, en la equitamela equitamela

262
00:14:11,500 --> 00:14:14,500
y lo que sea.

263
00:14:14,500 --> 00:14:15,500
Tendría muchas ventajas.

264
00:14:15,500 --> 00:14:18,780
De hecho, la principio, bueno, el argumento que decía este hombre es eso de que explícito

265
00:14:18,780 --> 00:14:21,940
no quiere decir redundante, bla, bla.

266
00:14:21,940 --> 00:14:24,580
Una ventaja que tendría, pues, el mensaje de error, porque nos ha pasado muchas veces

267
00:14:24,580 --> 00:14:28,580
que le pasamos un número incorrecto de argumento a un método y nos dice una cosa como recibe

268
00:14:28,580 --> 00:14:30,100
3, pero le hemos dado 2.

269
00:14:30,100 --> 00:14:32,220
Pero tú dices no, realmente recibe solamente 2.

270
00:14:32,220 --> 00:14:33,220
Aquí y ahí.

271
00:14:33,220 --> 00:14:35,820
Y, o sea, tenía cosas.

272
00:14:35,820 --> 00:14:37,820
Era muy razonable lo que este hombre propuso.

273
00:14:37,820 --> 00:14:41,420
Tuvo la mala suerte de que Guido Van Rossum vio lo que habías propuesto y le respondió.

274
00:14:41,420 --> 00:14:44,980
Hasta que ya lo hizo llorar y en el suelo.

275
00:14:44,980 --> 00:14:48,860
O sea, no haga eso.

276
00:14:48,860 --> 00:14:51,540
Entonces, hay que volar por debajo del rodar.

277
00:14:51,540 --> 00:14:57,180
Entonces, bueno, la respuesta corta y termina ya atabada a tu casa, es que explícite mejor

278
00:14:57,180 --> 00:14:58,180
que implícito.

279
00:14:58,180 --> 00:15:00,140
Si decís importe, dices no interpretes, eso es el cn de payzone.

280
00:15:00,140 --> 00:15:03,420
Así que ya estábamos terminados a tu casa.

281
00:15:03,420 --> 00:15:09,580
Guido Van Rossum, la idea era hacer daño y entonces lo razonó y lo explicó muy bien.

282
00:15:09,580 --> 00:15:12,700
Una cosa super teórica y esto en todas cosas no termino de entender.

283
00:15:12,700 --> 00:15:18,340
Hay un argumento muy fuerte del nivel teórico, ciencia de la computación, de que estas dos

284
00:15:18,340 --> 00:15:22,980
formas de llamar a un método, si tenemos la clase distancia, que recibe como segundo

285
00:15:22,980 --> 00:15:28,060
argumento otro objeto de esa clase, pues esto es equivalente a esto y de hecho si lo ejecutáis

286
00:15:28,060 --> 00:15:29,580
funciona, dice que es verdadero.

287
00:15:29,580 --> 00:15:34,660
El pasar self como argumento nos permite en otras cosas mantener esta equivalencia.

288
00:15:34,660 --> 00:15:37,980
Pero ahora algo más práctico, una cosa que nos permite self es que podamos añadir sobre

289
00:15:37,980 --> 00:15:39,740
la marcha método a una clase.

290
00:15:39,740 --> 00:15:45,460
Es decir, nosotros hacemos una clase que no hace nada, pero podemos definir un método

291
00:15:45,460 --> 00:15:48,100
que por ejemplo aquí nos lo hemos llamado self, solamente para que veamos que podemos

292
00:15:48,100 --> 00:15:51,460
llamarlo como queramos y que le decimos muy bien va a recibir un objeto de la clase, va

293
00:15:51,460 --> 00:15:55,740
a recibir un valor y lo que va a hacer es que al atributo de la clase va a añadirle

294
00:15:55,740 --> 00:15:56,740
el valor.

295
00:15:56,740 --> 00:16:02,860
Como un set X y entonces pues podemos ver que podemos enchufarle a la clase con el nombre

296
00:16:02,860 --> 00:16:05,740
que queremos, le podemos añadir ese método y ya podemos utilizarlo como un método más

297
00:16:05,740 --> 00:16:06,740
de la clase.

298
00:16:06,740 --> 00:16:10,860
Pero hay un método que es definitivo y es el de los decoradores.

299
00:16:10,860 --> 00:16:17,740
Básicamente con los decoradores aparentemente sin hacer magia negra y sacrificar primogénitos

300
00:16:17,740 --> 00:16:22,940
no es posible, no sería fácil trabajar si self no se recibirá como argumento.

301
00:16:22,940 --> 00:16:26,220
De otras cosas cuando decora una función no se sabe si va a devolver un método estático,

302
00:16:26,220 --> 00:16:28,380
no se sabe si va a dar devolver un método de clase.

303
00:16:28,380 --> 00:16:31,940
Entonces al parecer cuando esto se propuso fue cuando ya había salido Python 3.1 y

304
00:16:31,940 --> 00:16:35,420
entonces hubiera roto la compatibilidad de hacer todos esos cambios que en otras cosas

305
00:16:35,420 --> 00:16:38,980
no estaban dispuestos a hacer, así que ya empezó cruel pero terminó razonable y no

306
00:16:38,980 --> 00:16:39,980
se podía hacer.

307
00:16:39,980 --> 00:16:44,300
Este es el artículo y está muy chulo leerlo y bueno la moral deja que lo único que merece

308
00:16:44,300 --> 00:16:48,500
la pena recordar es que utilicemos self para acceder a los atributos del objeto.

309
00:16:48,500 --> 00:16:52,460
Por cierto sí, atributos porque un método es un atributo que se puede ejecutar, de

310
00:16:52,460 --> 00:16:56,780
hecho tenemos la función callable que nos dice si nos dice un método es executable

311
00:16:56,780 --> 00:16:59,460
o no y esto es para que yo me llevas agua mientras.

312
00:16:59,460 --> 00:17:14,180
Y es verdad, yo paso el 80% del tiempo en la derecha hasta que sale no cuando llega un

313
00:17:14,180 --> 00:17:18,140
compañero de trabajo y te dice no puedo sumar dos variables y tú ya estás escribiendo en

314
00:17:18,140 --> 00:17:19,580
un punto doc el código fuente.

315
00:17:19,580 --> 00:17:26,580
Y entonces como soy un dios.

316
00:17:26,580 --> 00:17:31,820
Y vamos por la ita 24 hasta graten, vamos por la mitad, por la mitad vale más rápido.

317
00:17:31,820 --> 00:17:34,580
¿Qué son las variables de clase?

318
00:17:34,580 --> 00:17:37,580
Puede que no nos dé tiempo a cubrirlo todos, entonces saltaré de un tema a otro.

319
00:17:37,580 --> 00:17:40,860
Las variables de clase son aquellas que están ubicadas en tiempo estático, es decir que

320
00:17:40,860 --> 00:17:45,100
se reserva, nos llama la variable estática, aquellas cuyo solamente hay una, así nació

321
00:17:45,100 --> 00:17:49,900
en un sitio de los programas y solamente escribimos hoy.

322
00:17:49,900 --> 00:17:52,900
En Python se llaman estática o de clase como se fueron equivalentes, por ejemplo aquí

323
00:17:52,900 --> 00:17:57,900
yo añado a jefe, digo que no hay jefe del T1000 por supuesto de SkyNet, pues entonces

324
00:17:57,900 --> 00:18:01,620
eso se queda guardado como yo no lo he definido dentro de línit, lo he definido dentro de

325
00:18:01,620 --> 00:18:05,420
la definición de la clase pero fuera de cualquier de ningún de todo método.

326
00:18:05,420 --> 00:18:09,660
Eso es una variable de clase o estática, se ven las dos cosas y básicamente lo que

327
00:18:09,660 --> 00:18:12,940
quiere decir es que es compartida por los dos métodos, perdón por todos los objetos

328
00:18:12,940 --> 00:18:14,580
de la clase se comparte esa variable.

329
00:18:14,580 --> 00:18:19,300
Por ejemplo aquí ya tenga uno el robot 2, los dos instancias de T1000, si yo accedo

330
00:18:19,300 --> 00:18:22,380
a jefe pues me dice es cierto mi jefe es el T1000.

331
00:18:22,380 --> 00:18:27,540
Por tanto la hemos compartido, por supuesto si se comparten pero no pasa nada si yo le

332
00:18:27,540 --> 00:18:33,380
asigno, si yo ahora digo que el jefe de robot 2 es James Cameron, no es SkyNet, no ocurre

333
00:18:33,380 --> 00:18:37,100
nada porque realmente estamos en el ámbito, en el scope de este objeto, con lo cual no

334
00:18:37,100 --> 00:18:40,980
he modificado la variable estática de clase.

335
00:18:40,980 --> 00:18:44,860
Yo ahora en mi diccionario local que es como simplemente todo esto, yo tengo una variable

336
00:18:44,860 --> 00:18:47,100
ahora que es jefe que le he puesto un nuevo valor.

337
00:18:47,100 --> 00:18:50,300
Hay que una costumbra para definir constante, hacer una cosa que es que dice muy bien pues

338
00:18:50,300 --> 00:18:53,780
necesito pi, pues entonces me voy a definir mi clase constantes y entonces esto hay idiomático

339
00:18:53,780 --> 00:18:57,900
y voy a tener dentro de la clase constantes el valor de pi y para acceder a él pues digo

340
00:18:57,900 --> 00:19:01,980
constantes punto pi pero en paín se lo necesitamos eso, simplemente lo que me decimos vale pues

341
00:19:01,980 --> 00:19:05,660
por lo como una variable siguiendo la convención del PEP 8 lo ponemos en mayúsculas y lo vamos

342
00:19:05,660 --> 00:19:09,660
a poner en el fichero y entonces yo simplemente ya pues desde donde cuando me haga falta pues

343
00:19:09,660 --> 00:19:12,660
digo devuelveme pi, este pi no está definido, no es una variable local, no está definido

344
00:19:12,660 --> 00:19:15,820
en la clase pero está definido en el módulo es una variable local y así es simplemente

345
00:19:15,820 --> 00:19:17,500
como en país donde definimos constante.

346
00:19:17,500 --> 00:19:23,060
Hay una mala idea y esto fue atroz y horrendo de llorar un rato en el cuarto de baño que

347
00:19:23,060 --> 00:19:26,700
dice muy bien, a más le pasó una de verdad, tengo a acompañar de trabajo que lo que hace

348
00:19:26,700 --> 00:19:31,060
es que le gusta definir como variable de clase una especie de declaración así rara de los

349
00:19:31,060 --> 00:19:35,660
argumentos que recibe, los atributos que tiene mi clase, mi clase tiene tanto un x como un

350
00:19:35,660 --> 00:19:39,740
y, pues yo la defino en cero como en atributos de la clase y entonces ya solamente cuando

351
00:19:39,740 --> 00:19:44,060
llamo init yo la inicializo, era una especie como declaración de intenciones, no tiene

352
00:19:44,060 --> 00:19:48,140
sentido porque estamos mezclando variable de estática con los objetos sin sentido y

353
00:19:48,140 --> 00:19:51,820
pueden mas cargar errores que lo voy a enseñar ahora pero de todas formas ni es más ni ocupa

354
00:19:51,820 --> 00:19:54,820
más espacio porque realmente solamente la variable de estática solamente está en una

355
00:19:54,820 --> 00:19:58,980
vez que es la definición de la clase y tampoco es más lento porque cuando hacemos ello

356
00:19:58,980 --> 00:20:02,980
estamos solamente cuando a fallar a monalceso o en atributo.

357
00:20:02,980 --> 00:20:06,180
Yo tengo una mala idea por un ejemplo, yo aquí lo he llamado raido al hacer la asignación

358
00:20:06,180 --> 00:20:09,660
y fue que estaba tecleando y no fui cuidadoso y me equivoco pero sin embargo no vamos a

359
00:20:09,660 --> 00:20:13,380
haber ningún error, ¿por qué? porque hay hemos creado otras variables pero sin embargo

360
00:20:13,380 --> 00:20:18,380
la de radio que definimos al principio ya existía, entonces no vamos a ver el error

361
00:20:18,380 --> 00:20:23,380
y hay una forma incesaria de dispararnos en el pie.

362
00:20:23,380 --> 00:20:25,260
¿Cómo lo hacemos para añadir a una variable de clase?

363
00:20:25,260 --> 00:20:28,380
Pues podemos hacerlo, es decir, yo quiero acceder a mi jefe dentro de uno de los métodos

364
00:20:28,380 --> 00:20:33,740
de mi clase, puedo acceder tanto vía self como vía nombre de la clase, los dos sirven,

365
00:20:33,740 --> 00:20:36,140
esto tenemos varios ejemplos de ello, ¿qué es mejor?

366
00:20:36,140 --> 00:20:40,220
Es mejor utilizar el primero self porque si en algún momento, por ejemplo, renombarme

367
00:20:40,220 --> 00:20:44,740
a nuestra clase no tendríamos que hacer un reemplazar y cambiar todas las veces que

368
00:20:44,740 --> 00:20:49,660
aparecerte mil, si en algún momento renombramos a clase, a ti mil cincuenta ese punto self

369
00:20:49,660 --> 00:20:53,700
siempre va a acceder a jefe, por tanto yo considero más elegante que es mejor que

370
00:20:53,700 --> 00:20:58,700
la de vía self.

371
00:20:58,700 --> 00:21:03,700
Sí, sí, también.

372
00:21:03,700 --> 00:21:11,700
No sé por qué, lo voy a hacer pero si te pagan por pulsación de teclado, lo tienes

373
00:21:11,700 --> 00:21:13,700
en la si.

374
00:21:13,700 --> 00:21:17,380
Básicamente la moraleja es que la abrela estática la utilizamos para aquellos atributos

375
00:21:17,380 --> 00:21:24,260
que son comunes a todos los, a aquellos atributos que son comunes a todos los objetos de la

376
00:21:24,260 --> 00:21:29,020
clase y que hay un fallo, que hagan que llenar como un pusho y los atributos lo definimos

377
00:21:29,020 --> 00:21:30,900
en el INIT sin pensar más.

378
00:21:30,900 --> 00:21:33,340
Atributos privados y ocultos, vamos a ver, esto está muy chulo.

379
00:21:33,340 --> 00:21:39,140
Nosotros en país en que nos lo sabemos, las previas privadas tienen un guión bajo, las

380
00:21:39,140 --> 00:21:43,620
variables super privadas, ocultas, mangleadas tienen dos guiones bajos, pero realmente vamos

381
00:21:43,620 --> 00:21:46,540
a empezar por las primeras, las previas y ocultas, sabemos que son ocultas pero realmente

382
00:21:46,540 --> 00:21:47,660
nada nos impide acceder a ellas.

383
00:21:47,660 --> 00:21:54,300
Por ejemplo, aquí tenemos un secreto, tenemos una clase persona que tiene un nombre y un

384
00:21:54,300 --> 00:21:58,580
secreto, yo le puedo asignar nombre y secreto y entonces cuando crea un objeto de la clase

385
00:21:58,580 --> 00:22:03,420
persona que es Raquel y Raquel tiene un secreto es que prefiere Perl.

386
00:22:03,420 --> 00:22:06,300
Hemos dicho, es secreto, de hecho no solamente la variable se llama secreto, es que tiene

387
00:22:06,300 --> 00:22:10,860
un guión bajo, sin embargo si accedemos, accedemos completamente, es decir, no tenemos ningún problema.

388
00:22:10,860 --> 00:22:11,860
¿Por qué?

389
00:22:11,860 --> 00:22:14,420
Porque hay una frase muy chula que se puede aplicar en un montón de escenarios y es la

390
00:22:14,420 --> 00:22:19,740
idea de que somos adultos aquí, eso justifica cualquier cosa, vamos, desde programar en

391
00:22:19,740 --> 00:22:24,260
Max hasta tirarte en paracaída da igual, somos adultos, entonces el guión no quiere

392
00:22:24,260 --> 00:22:27,140
decir que no pueda acceder, el guión quiere decir que no debería acceder porque es un

393
00:22:27,140 --> 00:22:30,660
detalle por ejemplo de implementación y esto puede que en cualquier momento desaparezca.

394
00:22:30,660 --> 00:22:34,260
Por lo tanto no debería depender de ello pero nada te lo impide, esto yo lo tenía esta

395
00:22:34,260 --> 00:22:38,100
conversación he tenido un montón de veces y la conversación es siempre la misma, pero

396
00:22:38,100 --> 00:22:44,540
¿y si tengo mi clase central nuclear y entro en la variable privada y explota mi central

397
00:22:44,540 --> 00:22:45,540
nuclear?

398
00:22:45,540 --> 00:22:46,540
Pues no lo haga.

399
00:22:46,540 --> 00:22:47,540
Vale.

400
00:22:47,540 --> 00:22:54,900
Y ya está, y podemos pasar a otro tema de conversación.

401
00:22:54,900 --> 00:22:57,820
Nada te impide hacerlo pero se asume que no quieres que tu central nuclear explote entonces

402
00:22:57,820 --> 00:23:00,780
no va a cambiar el contador de la...

403
00:23:00,780 --> 00:23:04,660
Y esto aquí lo dice de la zona muy bien y es que la tanto otras cosas que vemos en

404
00:23:04,660 --> 00:23:08,260
programación como el protect y el private y tal de otro lenguaje, de otro, por ejemplo,

405
00:23:08,260 --> 00:23:11,020
Java al cual odio compasión.

406
00:23:11,020 --> 00:23:14,220
El código fuente en el fondo realmente siempre puede hacer, por ejemplo en Java puede usar

407
00:23:14,220 --> 00:23:20,300
esa cosa llamada reflexión y realmente la práctica sí puede acceder y bueno como dijo

408
00:23:20,300 --> 00:23:24,980
otro en StarCoverflow que insisto donde estoy siempre, podrías ir al código fuente modificarlo

409
00:23:24,980 --> 00:23:28,460
y también puede manipular lo que quiera con lo cual es una sensación más bien falsa de

410
00:23:28,460 --> 00:23:35,180
seguridad como ir de pasajero en un coche y agarrarte al...

411
00:23:35,180 --> 00:23:38,140
Algo que no deberías hacer pues por ejemplo ahora aquí digo pues le voy a cambiar el

412
00:23:38,140 --> 00:23:42,140
secreto tiene algo sin duda el pecado de la penitencia y demás es mucho peor que Pearl

413
00:23:42,140 --> 00:23:44,260
que es que le gusta programar en Notepad.

414
00:23:44,260 --> 00:23:47,900
Pues entonces digo pues voy a cambiar el secreto y le cambio el secreto y efectivamente lo

415
00:23:47,900 --> 00:23:48,900
he cambiado.

416
00:23:48,900 --> 00:23:53,500
Otro ejemplo la prueba es privada no solamente es por T de implementación a veces se utilizan

417
00:23:53,500 --> 00:23:57,140
para si queremos tener un método con el mismo nombre que uno de los tributos de la clase.

418
00:23:57,140 --> 00:24:00,820
Por ejemplo no podemos tener un atributo y un método que se ve igual porque de hecho

419
00:24:00,820 --> 00:24:05,140
los métodos son atributos con lo cual tendríamos una colisión.

420
00:24:05,140 --> 00:24:08,140
Lo que haríamos sería pues normalmente se ve y eso es una tontería pero que decimos

421
00:24:08,140 --> 00:24:12,340
muy bien pues guión edad entonces yo guardo la edad como el en sabrable privada y luego

422
00:24:12,340 --> 00:24:16,660
cuando ya ha sido el método de edad pues ya es cuando hace otra vez de ella esto relaciona

423
00:24:16,660 --> 00:24:18,380
con los decoradores que lo vamos a ver luego.

424
00:24:18,380 --> 00:24:22,260
Por ejemplo en este caso lo máximo que estemos dispuestos a reconocer era una edad de 35

425
00:24:22,260 --> 00:24:25,100
pues entonces aquí ya hacedemos a la edad llamando al método y nos dice no no yo tengo

426
00:24:25,100 --> 00:24:27,660
35.

427
00:24:27,660 --> 00:24:32,820
Los guiones, dos guiones bajos significa esto de enmarañar el mangle y lo que hace es que

428
00:24:32,820 --> 00:24:33,820
tú lo haces muy feo.

429
00:24:33,820 --> 00:24:37,540
Esto es como se suele ver por ahí en internet que esto es para abreablar y ocultar de verdad

430
00:24:37,540 --> 00:24:38,540
de verdad.

431
00:24:38,540 --> 00:24:42,580
No es exactamente esto de hecho bueno vamos a ver un caso si yo guardo la edad con dos

432
00:24:42,580 --> 00:24:45,580
guiones bajos cuando intento acceder a ella a diferencia de cuando utilice un guión no

433
00:24:45,580 --> 00:24:49,380
va a decir no puedo de hecho que no existe porque qué es lo que ha ocurrido porque

434
00:24:49,380 --> 00:24:52,900
realmente cuando utilizamos dos guiones bajos eso se reemplaza por otra cosa que es guión

435
00:24:52,900 --> 00:24:56,220
bajo, nombre de clase, guión bajo y atributo.

436
00:24:56,220 --> 00:24:57,620
¿Por qué querías acceder a esto?

437
00:24:57,620 --> 00:25:00,060
Porque hay veces por ejemplo un depurador necesita hacerlo.

438
00:25:00,060 --> 00:25:02,980
Por ejemplo vamos a acceder a spam pues sí puedo.

439
00:25:02,980 --> 00:25:05,340
Guión bajo, clase persona, guión bajo y edad.

440
00:25:05,340 --> 00:25:07,180
O sea que sí puedo hacer realmente de ello.

441
00:25:07,180 --> 00:25:09,620
A ella solamente lo ha hecho más difícil.

442
00:25:09,620 --> 00:25:15,060
El objetivo no solamente que pueda ocultar muy bien algo es que te permite evitar colisiones.

443
00:25:15,060 --> 00:25:18,900
Un ejemplo tenemos la clase pin y yo digo muy bien tengo una variable de clase tengo una

444
00:25:18,900 --> 00:25:21,620
clase habitación que tiene un pin en la puerta para entrar y te dice pues muy bien yo guardo

445
00:25:21,620 --> 00:25:25,660
esa variable guardo el pin y entonces ahora tengo una su clase que es cámara corazada

446
00:25:25,660 --> 00:25:30,220
que es un muro de hormigón fuera detrás de mi cámara de mi habitación y defino otro

447
00:25:30,220 --> 00:25:31,220
pin.

448
00:25:31,220 --> 00:25:32,220
¿Cuál es el problema de esto?

449
00:25:32,220 --> 00:25:34,740
Que cuando yo intento acceder al pin no puedo acceder al pin de habitación porque tengo

450
00:25:34,740 --> 00:25:41,020
una variable que se llama exactamente igual con lo cual sobreescribo, es decir en el ámbito

451
00:25:41,020 --> 00:25:43,940
local no puedo hacer a ella porque le he asignado un nuevo valor.

452
00:25:43,940 --> 00:25:49,100
Entonces lo que hacemos es utilizar dos guiones bajos y entonces ahora ya cuando yo acceda

453
00:25:49,100 --> 00:25:53,460
a las variables súper ocultas aquí dentro pues estoy viendo que realmente no he modificado

454
00:25:53,460 --> 00:25:57,460
ninguno de los valores.

455
00:25:57,460 --> 00:25:59,700
Podríamos hacerlo aún mejor si lo hicieramos así ¿no?

456
00:25:59,700 --> 00:26:04,340
Que es que accedemos vía este acede vía como este es mi objeto súper oculto accedo a él

457
00:26:04,340 --> 00:26:08,540
y el otro pues tiene que llamar al pin 1 llama la clase habitación y dice específicamente

458
00:26:08,540 --> 00:26:09,740
quiero el de mi clase base.

459
00:26:09,740 --> 00:26:14,100
A la mayoría de las ocasiones y es casi siempre no necesito solamente necesitamos un guión

460
00:26:14,100 --> 00:26:15,100
bajo.

461
00:26:15,100 --> 00:26:21,540
Los dos guiones bajos son en caso muy oculto y lo hacemos básicamente cuando tenemos el

462
00:26:21,540 --> 00:26:27,380
riesgo de que utilizan un nombre de variable idéntico al de una clase base y entonces la

463
00:26:27,380 --> 00:26:30,940
tengamos un conflicto.

464
00:26:30,940 --> 00:26:34,700
Como curiosidad si solamente ponen un guión bajo no sé si se oculta una variable pero

465
00:26:34,700 --> 00:26:38,220
si ponen dos no por eso los métodos mágicos funcionan.

466
00:26:38,220 --> 00:26:42,020
Hay quien lo llama Dunder porque eso es decir guión bajo, guión bajo, guión bajo, guión

467
00:26:42,020 --> 00:26:46,460
bajo es muy latazo entonces vi para ahí que hay una forma así pro que es decir Dunder

468
00:26:46,460 --> 00:26:49,780
y ya toda la gente dice sabe un montón.

469
00:26:49,780 --> 00:26:50,780
Debería subir aquí a donar charla.

470
00:26:50,780 --> 00:26:54,820
Dunder init y ya con eso la gente sabe que es lo que estamos hablando.

471
00:26:54,820 --> 00:26:57,980
Básicamente guión bajo es una variable privada doble que guión bajo es una cosa que si nunca

472
00:26:57,980 --> 00:27:02,140
necesitamos y es para enmarañarlo.

473
00:27:02,140 --> 00:27:04,140
Método estático y de clase.

474
00:27:04,140 --> 00:27:07,140
Acá la terminamos.

475
00:27:07,140 --> 00:27:15,260
Los métodos estáticos son aquellos que no necesitan exceso a ningún atributo.

476
00:27:15,260 --> 00:27:21,180
Es decir aquí tenemos una clase calculadora y entonces la clase calculadora nos dice el

477
00:27:21,180 --> 00:27:25,420
nombre de la clase y nos puede hacer la suma y cuando le decimos suma me x, x e i, por

478
00:27:25,420 --> 00:27:27,460
le decimos suma me 4 y 8 nos dice 12.

479
00:27:27,460 --> 00:27:31,580
Realmente no necesitábamos acceder la suma no depende de ninguna propiedad de la calculadora

480
00:27:31,580 --> 00:27:33,540
es decir siempre va a ser la suma igual.

481
00:27:33,540 --> 00:27:39,300
Entonces tenemos el decorador de static method que lo que hace es que nos modifica nuestra

482
00:27:39,300 --> 00:27:42,820
función de forma que ya no necesitamos pasarle self.

483
00:27:42,820 --> 00:27:49,060
Entonces ahora como este método no necesita acceso a ningún atributo de mi objeto pues

484
00:27:49,060 --> 00:27:51,820
yo simplemente le digo muy bien pues tú no recibes self porque no te hace falta.

485
00:27:51,820 --> 00:27:55,260
Tú solamente recibas los argumentos que está utilizando.

486
00:27:55,260 --> 00:28:06,540
Si no necesitamos hacer a ningún objeto de la clase porque no hay ningún atributo

487
00:28:06,540 --> 00:28:09,860
de este objeto de esta clase porque no lo movimos a una función porque tenemos una

488
00:28:09,860 --> 00:28:11,940
función en el módulo que diga suma.

489
00:28:11,940 --> 00:28:15,420
Bueno esto se suele hacer porque yo tengo conceptualmente la suma pertenece a la calculadora

490
00:28:15,420 --> 00:28:20,980
por lo cual aunque no acceda a nada en concreto tiene sentido que la dejemos ahí dentro.

491
00:28:20,980 --> 00:28:23,380
Por supuesto un método estático se puede llamar no solamente sobre un objeto sino

492
00:28:23,380 --> 00:28:25,380
sobre la propia clase calculadora.

493
00:28:25,380 --> 00:28:29,500
Como no recibo ningún objeto en concreto puede utilizarlo y los métodos de clase pueden

494
00:28:29,500 --> 00:28:31,700
visualizarse como una variante de los métodos normales.

495
00:28:31,700 --> 00:28:36,260
Si reciben algo pero no reciben el objeto que ha llamado al método lo que reciben es

496
00:28:36,260 --> 00:28:37,940
la clase a la que pertenezco.

497
00:28:37,940 --> 00:28:41,540
Es decir, todo lo que no haría falta si queremos devolver otro objeto.

498
00:28:41,540 --> 00:28:47,260
Por ejemplo tengo mi clase ameba y la clase ameba tiene un método que es fisión para

499
00:28:47,260 --> 00:28:49,860
partirse en dono y no devuelve dos descendientes.

500
00:28:49,860 --> 00:28:53,980
Entonces yo digo muy bien quiero que me devuelva dos hijos, la clase primogenito y el objeto

501
00:28:53,980 --> 00:28:56,980
primogenito y el objeto benjamín.

502
00:28:56,980 --> 00:29:01,460
Entonces yo creo mi ameba y le digo muy bien pues partete y me dice pues exactamente tengo

503
00:29:01,460 --> 00:29:02,460
dos hijos.

504
00:29:02,460 --> 00:29:03,460
¿Cuál es el problema?

505
00:29:03,460 --> 00:29:06,980
Que hemos arco-deado el tipo ahí tenemos ameba lo hemos especificado dos veces.

506
00:29:06,980 --> 00:29:08,660
¿Qué pasa si luego renombramos la clase?

507
00:29:08,660 --> 00:29:12,660
Pues mal que no nos funciona porque estamos diciendo específicamente el tipo.

508
00:29:12,660 --> 00:29:19,100
Si por ejemplo aquí tenemos la ameba cyborg, la ameba cyborg que es una T-800 que es más

509
00:29:19,100 --> 00:29:20,100
antigua.

510
00:29:20,100 --> 00:29:25,220
Le digo muy bien pues ameba cyborg fisionate y créame dos descendientes y entonces dice

511
00:29:25,220 --> 00:29:26,380
muy bien pues te los creo.

512
00:29:26,380 --> 00:29:29,540
El problema es que no ha devuelto amebas no ha devuelto no ha devuelto amebas cyborg

513
00:29:29,540 --> 00:29:31,900
es lo que nos hace falta porque el código fuente pone devuelve ameba.

514
00:29:31,900 --> 00:29:35,420
Entonces pues bueno pues podríamos decir una cosa vamos a utilizar clase y entonces

515
00:29:35,420 --> 00:29:38,540
pues yo voy a decir muy bien pues accedemos podríamos hacerle por dos métodos podríamos

516
00:29:38,540 --> 00:29:41,700
decirle self punto class eso no devuelve la clase actual o podríamos decirle muy bien

517
00:29:41,700 --> 00:29:47,220
o type self que también funciona y entonces eso no devolvería ahora ya sí funcionaría.

518
00:29:47,220 --> 00:29:50,500
Pero bueno, podíamos hacerlo de los dos métodos de forma casi indiscutible aunque

519
00:29:50,500 --> 00:29:55,900
no funcionan las clases old style no podríamos hacer type self pero es que bueno es precisamente

520
00:29:55,900 --> 00:29:59,020
lo que hacen los métodos de clase no están pasando una referencia a la clase en la que

521
00:29:59,020 --> 00:30:03,140
estamos entonces utilizamos el decorador class method y entonces por convención se

522
00:30:03,140 --> 00:30:07,380
suele llamar CLS y el método fision lo que va a hacer es devolverlo en CLS en la clase

523
00:30:07,380 --> 00:30:11,980
pues yo simplemente diría muy bien pues devuélveme CLS primogénido donde en este caso CLS es

524
00:30:11,980 --> 00:30:16,940
la clase actual que es ameba y entonces estamos creando todos los objetos de la clase ameba

525
00:30:16,940 --> 00:30:22,180
y cuando le damos no servirá perfectamente a veces sin embargo necesitamos type por ejemplo

526
00:30:22,180 --> 00:30:27,060
si los hijos tienen un nombre y dice pues yo me llamo tal y deciendo de tal persona ahí

527
00:30:27,060 --> 00:30:31,100
necesitamos acceder a self nombre por ejemplo en este caso si tenemos que acceder a un atributo

528
00:30:31,100 --> 00:30:34,900
ya no podemos recibir un CLS method porque no necesitamos una referencia al objeto no

529
00:30:34,900 --> 00:30:38,540
la clase entonces ahí tendríamos que utilizar un método normal y utilizar type self por

530
00:30:38,540 --> 00:30:42,740
ejemplo para acceder a ella. La práctica es un static method se utiliza cuando nuestro

531
00:30:42,740 --> 00:30:47,100
método trabaja con la clase no con su objeto y el método de las clases cuando trabajamos

532
00:30:47,100 --> 00:30:51,820
con una clase y casi siempre cuando queremos devolver un objeto de la misma clase. Yo respeto

533
00:30:51,820 --> 00:30:56,660
un montón a la gente que trabaja programando videojuegos y la gente joven dice yo voy a

534
00:30:56,660 --> 00:30:59,940
programar videojuegos y se imaginan que va a ser algo así que va a ir caminando repartiendo

535
00:30:59,940 --> 00:31:04,900
bendiciones a bps y hi fives y demás y luego en la práctica se parece mucho más a esto

536
00:31:04,900 --> 00:31:18,860
¿no? ¡Le compila! Soy un dios. Propiedades, sí nos quedan otras cosas que ves solo. Tenemos

537
00:31:18,860 --> 00:31:23,180
clase círculo en la que ese círculo tiene dos atributos radio y área el problema el

538
00:31:23,180 --> 00:31:26,740
área depende del radio con lo cual hay una relación directa si nosotros simplemente

539
00:31:26,740 --> 00:31:31,100
organizaramos y dijéramos radio igual a radio, área igual a área y la calculamos en el constructor

540
00:31:31,100 --> 00:31:35,500
cuando hicieramos podríamos hacer una cosa así que el problema es que yo crea el círculo

541
00:31:35,500 --> 00:31:39,460
y ahora digo muy bien pues ahora voy a cambiar el radio el área no ha cambiado claro que

542
00:31:39,460 --> 00:31:42,700
no el área la ha asignado en el constructor no va a cambiarse entonces podemos decir muy

543
00:31:42,700 --> 00:31:46,500
bien vamos a convertir el área en una función y entonces podríamos decirle vamos a hacer

544
00:31:46,500 --> 00:31:50,940
esto el área pues tiene que llamarla como método y entonces el área es la que ya accede al

545
00:31:50,940 --> 00:31:55,540
radio y nos calcula el área del círculo el problema que hemos pasado de leer un atributo

546
00:31:55,540 --> 00:32:02,300
a llamar a un método vamos a dejarlo y vale vamos a ver otra cosa ahora tenemos un problema

547
00:32:02,300 --> 00:32:06,140
a este radio le podemos a este círculo le podemos poner un radio negativo que por ejemplo

548
00:32:06,140 --> 00:32:09,220
en este caso pues no tendría sentido entonces yo podría decir muy bien que era un círculo

549
00:32:09,220 --> 00:32:14,980
con radio 13 pero después se lo voy a cambiar a menos 2 y entonces eso tampoco como decían

550
00:32:14,980 --> 00:32:20,180
los robots en los años 80 no computa y explotaban no sé si os acordáis entonces bueno pues

551
00:32:20,180 --> 00:32:22,980
podríamos decir una cosa vamos a crear una variable privada en la que vamos a almacenar

552
00:32:22,980 --> 00:32:26,220
el radio vamos a tener un método que estoy en java por ejemplo donde podáis quebir 10

553
00:32:26,220 --> 00:32:30,620
mil líneas de código sin que ocurra nada pues dentro de esas mil líneas de código

554
00:32:30,620 --> 00:32:34,020
tienes un setter un getter y tienen no sé cuántas cosas más y entonces pues cuando

555
00:32:34,020 --> 00:32:38,100
yo llame a mi método set radio que habría que llamarlo así pues entonces comprebo si

556
00:32:38,100 --> 00:32:41,380
el radio es negativo si es negativo te lanza un error y entonces yo ahora ya te obligo

557
00:32:41,380 --> 00:32:46,140
a que llames al método set radio y entonces ahí ya puedo hacer la comprobación eso son

558
00:32:46,140 --> 00:32:50,540
los setters y los getters que básicamente la forma en la que controlamos el acceso a

559
00:32:50,540 --> 00:32:57,100
una variable vamos a ver otro ejemplo no solamente queramos no solamente queremos compro validar

560
00:32:57,100 --> 00:33:01,140
datos queremos hacer algo más por ejemplo cada vez que haces al pin que pin cada vez

561
00:33:01,140 --> 00:33:05,980
que yo haced al pin de mi contraste de mi caja fuerte voy a lanzar voy a mandar una copia

562
00:33:05,980 --> 00:33:10,340
a la nsa o a la agencia de espionaje que sea pues si quisieramos hacerlo podríamos hacerlo

563
00:33:10,340 --> 00:33:15,060
así preferiblemente no con un print sino que algo más útil esto en python se hace con

564
00:33:15,060 --> 00:33:20,100
las propiedades y esto yo con que esta concluy esto este punto que declaro y el que quiero

565
00:33:20,100 --> 00:33:23,940
ver justo antes de terminar me conformo las propiedades nos permiten implementar a la

566
00:33:23,940 --> 00:33:29,780
funcionalidad que hemos visto ahora mismo pero como si fueran atributos es decir nosotros

567
00:33:29,780 --> 00:33:34,140
lo que estamos viendo son atributos pero entre bastidores son funciones son de los que queramos

568
00:33:34,140 --> 00:33:40,820
y eso mola un montón vamos a ver un ejemplo yo digo pin pues el método pin me va a devolver

569
00:33:40,820 --> 00:33:45,100
el pin de paso avisa a alguien no pero voy a decorar como una propieta y ahora voy a

570
00:33:45,100 --> 00:33:49,260
decir muy bien pin tú eres el setter de pin que es pin lo que vamos a definir arriba

571
00:33:49,260 --> 00:33:55,460
justo ahí hemos definido el el setter y el getter no por llamarlo así pues entonces

572
00:33:55,460 --> 00:34:00,260
yo ahora puedo hacer ucha punto pin y eso lo que ha ido a irse a la property y no ha devuelto

573
00:34:00,260 --> 00:34:05,780
el pin estamos accediendo a un atributo como a métodos como si fueran atributos en este

574
00:34:05,780 --> 00:34:08,860
caso por ejemplo estamos validando lo y no está diciendo no no tiene que tener cuatro

575
00:34:08,860 --> 00:34:12,100
dígitos entonces cuando nosotros hemos hecho simplemente una asignación como le hemos puesto

576
00:34:12,100 --> 00:34:16,420
solamente tres dígitos pues no va a decir no sirve property lo que hace es convertir pin

577
00:34:16,420 --> 00:34:21,660
en un getter para atributos o textura de ese nombre como he visto aquí área property área

578
00:34:21,660 --> 00:34:24,940
pues lo que hace es que ya tenemos un atributo que cada vez que se llama nosotros creo que

579
00:34:24,940 --> 00:34:28,740
para nosotros es un atributo normal realmente una llamada a un método esto es relacionado

580
00:34:28,740 --> 00:34:32,700
con los descriptores que una generación una generalización y aquí ya podemos ver que

581
00:34:32,700 --> 00:34:36,980
aunque modificamos sobre la marcha modificamos el radio pues el área siempre está actualizada

582
00:34:36,980 --> 00:34:40,860
luego también tenemos los setters y los setter es simplemente que yo lo digo muy bien pues

583
00:34:40,860 --> 00:34:46,220
aquí tengo el el getter no en las que el que me permite acceder a él solo lectura pues

584
00:34:46,220 --> 00:34:51,420
yo le digo muy bien pues radio punto setter ahora tú eres el método que se utiliza para

585
00:34:51,420 --> 00:34:56,480
asignarle un valor a esta a esta properti no a radio pues es lo mismo nosotros ahora

586
00:34:56,480 --> 00:35:01,660
ya podemos acceder a él radio igual a menos 2 y estamos validando los datos y nos lanzó

587
00:35:01,660 --> 00:35:05,660
un error si no lo hemos hecho bien hay una tercera property que es el del éter y es exactamente

588
00:35:05,660 --> 00:35:09,900
lo mismo y lo que se hace es que es la que se invoca cuando hacemos del punto algo en

589
00:35:09,900 --> 00:35:15,020
este caso por ejemplo lo que hacemos es que guardamos todas las para mayor gloria de la

590
00:35:15,020 --> 00:35:18,980
nsa guardamos toda la un historial de todas las claves que hemos usado nunca y nosotros

591
00:35:18,980 --> 00:35:22,420
en todo momento lo que hacemos de la última pues si decimos muy bien pues el por seguridad

592
00:35:22,420 --> 00:35:25,940
a veces me pongo pranoico quiero borrarlo pues entonces vale pues el del éter de esta

593
00:35:25,940 --> 00:35:31,100
properti lo que va a hacer es simplemente borrarnos toda la lista en la cual estábamos guardándolos

594
00:35:31,100 --> 00:35:34,460
aquí tenemos un ejemplo y podemos ver efectivamente que después de llamar a del cuando accedemos

595
00:35:34,460 --> 00:35:42,660
a todo el historial de claves pues se ha embarrado y bueno la definición de terminos en la definición

596
00:35:42,660 --> 00:35:45,980
formal no que creo que estamos convirtiéndolo en la función la hemos convertido en un atributo

597
00:35:45,980 --> 00:35:50,180
de solo lectura con el mismo nombre de la función que hemos decorado y tenemos otro y

598
00:35:50,180 --> 00:35:55,460
que tercéter y el del éter también tenemos la bueno y la doc string la documentación

599
00:35:55,460 --> 00:36:01,380
de ese atributo cuando hacemos un help de la clase pues será el de el getter si aquí

600
00:36:01,380 --> 00:36:05,340
yo he hecho propertiaria cuando luego veamos el doc string de la clase podemos ver que

601
00:36:05,340 --> 00:36:11,860
no ha devuelto el doc string del primer método que hemos decorado por supuesto cuando hacemos

602
00:36:11,860 --> 00:36:17,020
lo de decorar con radio punto set radio tal la función decorada tiene que tener el mismo

603
00:36:17,020 --> 00:36:22,180
nombre si no no dar un error muy feo y bueno por saberlo siempre que la sintasi de la sintasi

604
00:36:22,180 --> 00:36:27,580
de decoradores derroba algo en una forma son cinco en la forma rápida de hacer otra cosa

605
00:36:27,580 --> 00:36:31,780
que realmente properti por supuesto una función que nos podemos utilizar como un decorador también

606
00:36:31,780 --> 00:36:38,800
podríamos declararlo así otro ejemplo y bueno por supuesto si intentamos acceder a un atributo

607
00:36:38,800 --> 00:36:41,700
que no hemos definido pues nos va a dar un error aquí por ejemplo no hemos definido el de

608
00:36:41,700 --> 00:36:46,380
letter pues nos dice no no puedo y entonces porque no ha definido ninguna forma de borrar este

609
00:36:46,380 --> 00:36:51,300
atributo con lo cual nos dirá no puedo borrar el atributo entre properti si gaiters está muy muy

610
00:36:51,300 --> 00:36:57,540
claro siempre propertis porque nos permite empezar sencillito nos permite que nosotros primero guardamos

611
00:36:57,540 --> 00:37:02,900
simplemente el área guardemos el radio y en algún momento tendremos un usuario de esto que quiere

612
00:37:02,900 --> 00:37:06,620
hacer volar a la central nuclear o el trapador espacial y entonces pues anda es verdad que

613
00:37:06,620 --> 00:37:10,700
gente que quiere hacer esas cosas entonces ya podemos cambiar nuestro tributo a método sin

614
00:37:10,700 --> 00:37:18,180
que nadie se de cuenta nada nada nada de más cambia de hecho formalmente esto es lo que se llama

615
00:37:18,180 --> 00:37:21,860
el principio de acceso uniforme y es que hay que defender y tiene muchos muchos sentidos que

616
00:37:21,860 --> 00:37:24,900
de hacer todos los atributos debe ser siempre a través de una notación uniforme independientemente

617
00:37:24,900 --> 00:37:29,940
que por debajo sea un método o sea simplemente un ablacionamiento en memoria lectura interesantes y

618
00:37:29,940 --> 00:37:35,660
recomendación no hagáis nunca set x no hagáis nunca get x simplemente vosotros decidimos atributos y

619
00:37:35,660 --> 00:37:40,740
conforme nos vayas haciendo falta más lógica la incorporamos y pasamos a una properti vaya

620
00:37:40,740 --> 00:37:43,980
a tener que mirar a internet y creo que me voy a en un montón los puntos 7 y 8 pero me voy a ir al

621
00:37:43,980 --> 00:37:50,980
último que es mi favorito y ni ni niu asumamos que vamos a trabajar con media esponderada vale 4

622
00:37:50,980 --> 00:37:54,740
minutos verdad vamos a trabajar con media esponderada y entonces queremos almacenar los pesos para

623
00:37:54,740 --> 00:37:58,420
hacer una media ponderada en una clase yo digo muy bien clases pesos que hereda de tupla y entonces

624
00:37:58,420 --> 00:38:04,380
simplemente por defino unos pesos y tengo mis pesos de una tupla por ejemplo uno extra 0.8.0 y 0.25

625
00:38:04,380 --> 00:38:08,660
problemas que los pesos no tienen porque sumar uno podría ocurrir que yo le pasara lo que fuera y

626
00:38:08,660 --> 00:38:12,580
lo recibe por ejemplo aquí tenemos unos pesos que no suman uno eso no tiene sentido entonces

627
00:38:12,580 --> 00:38:16,980
tenemos una idea vamos a hacer que init compruebe los valores y lance error de lo contrario y entonces

628
00:38:16,980 --> 00:38:23,300
yo que mi constructor pues efectivamente si ve que la suma no no es uno bueno lanza un error y funciona

629
00:38:23,300 --> 00:38:29,580
pero no podríamos explicar niu si nos quedamos aquí porque no hacemos una cosa porque no normalizamos

630
00:38:29,580 --> 00:38:33,620
los pesos entonces yo sí le puedo decir 2 1 y eso que sería los pesos relativos y eso no diría vale

631
00:38:33,620 --> 00:38:39,020
pues entonces uno es el 76 por ciento tiene peso 1 y el 36 por ciento es decir yo quiero normalizar

632
00:38:39,020 --> 00:38:43,660
en el constructor pues yo podría podríamos decir muy bien pues voy a crear los valores voy a normalizar

633
00:38:43,660 --> 00:38:47,900
lo y voy a devolver llamó el constructor de la clase base que es la tupla y lo devuelvo ya normalizado y

634
00:38:47,900 --> 00:38:51,500
sin embargo no devuelve lo mismo que le hemos pasado no funciona porque porque hemos heredado

635
00:38:51,500 --> 00:38:56,420
una clase mutable que una tupla y cuando llegamos a init ya es demasiado tarde el objeto ya se ha creado

636
00:38:58,460 --> 00:39:06,620
y ni recibe una instancia y le ajustó sus valores pero cuando llegamos ahí ya la distancia el objeto

637
00:39:06,620 --> 00:39:12,220
ya existe es decir init lo que hace e inicilizar no crea podríamos intentar hacer otra cosa que

638
00:39:12,220 --> 00:39:15,900
sería muy bien pues voy a modificar esto lo visto y se podría hacer en otro sitio voy a cambiar el

639
00:39:15,900 --> 00:39:19,820
valor de self voy a hacer que self apunte a otro sitio pero no porque realmente self es una variable

640
00:39:19,820 --> 00:39:24,060
se podría llamar cualquier cosa y de hecho aparte no va a funcionar porque hay otros problemas

641
00:39:24,060 --> 00:39:28,620
y tiene que devolver nones y vuestro init no devuelve nones va a obtener un error porque aquí

642
00:39:28,620 --> 00:39:31,980
no lo lanzado porque ese súper devuelven a un con lo cual a su vez nosotros también lo hemos devuelto

643
00:39:31,980 --> 00:39:38,180
entonces init no puede crear nada si vemos que si intentan hacer esto no diría no no puede devolver

644
00:39:38,180 --> 00:39:42,420
una tupla tiene que devolver nones la pregunta de dónde viene ese objeto que hemos creado pues viene

645
00:39:42,420 --> 00:39:47,460
de new que new uno puede nacer crecer reproducirse y morirse y no haberse enterado nunca de que

646
00:39:47,460 --> 00:39:53,180
new existía porque casi nunca nos hace falta pero new es un método mágico que el papa de init new

647
00:39:53,180 --> 00:39:58,860
recibe la clase nos crea el objeto y nos lo devuelve entonces después de llamar a new que siempre se

648
00:39:58,860 --> 00:40:05,180
llama cuando init inicializa los valores una cosa súper tonta init y lo prendí el otro día init y

649
00:40:05,180 --> 00:40:10,140
el método init de la clase inmutable no hace nada de hecho es un no en cuanto lo llamamos pasa

650
00:40:10,140 --> 00:40:15,180
porque porque si no podríamos hacer esto yo digo tengo mi variable ahora hago variable init haba

651
00:40:15,180 --> 00:40:19,180
y cambiaría mi cadena de texto a otros valores pero eso sabemos que no puede ser por definición

652
00:40:19,180 --> 00:40:23,220
porque son inmutables pues si escutamos esto vemos que no ha ocurrido nada es decir init que nosotros

653
00:40:23,220 --> 00:40:26,980
asumiríamos que iba a ser el valor de la cadena la cadena no lo hace entonces lo que tenemos que

654
00:40:26,980 --> 00:40:32,900
hacer es hacerlo en new y es tan fácil como que en new recibo un objeto de la clase reciba los valores

655
00:40:32,900 --> 00:40:36,820
que por supuesto init en new recibe los mismos argumentos y argumentos nombrados que recibe

656
00:40:36,820 --> 00:40:42,380
init ahí es donde hacemos la normalización y ya devuelvo el objeto que he creado y ya init de hecho

657
00:40:42,380 --> 00:40:47,460
no hace falta y así ya si funciona por supuesto que pasar en la clase hay que pasar en la clase a

658
00:40:47,460 --> 00:40:52,780
new si no se la pasáramos nos daría un error aún mejor por supuesto que tengo una sesión con los

659
00:40:52,780 --> 00:40:56,860
generadores y ahora hay una charla muy chula podemos en vez de utilizar una lista por comprensión

660
00:40:56,860 --> 00:41:02,420
podríamos utilizar un generador esto porque siempre queda mejor hacerlo para sumar y otro ejemplo

661
00:41:02,420 --> 00:41:06,300
muy tonto una clase que siempre devuelve 42 pues no podríamos hacerlo en el que en el constructor

662
00:41:06,300 --> 00:41:12,580
nosotros eramos de un ente, perdón, si nosotros intentáramos hacer que nuestra clase siempre

663
00:41:12,580 --> 00:41:17,460
devolviera 42 podríamos hacerlo así pero esto había mejor que lo hagamos así es decir para que

664
00:41:17,460 --> 00:41:23,540
vamos a dar de object, eramos de in de, perdón mejor si, si exactamente lo que podíamos hacer

665
00:41:23,540 --> 00:41:28,060
sencillamente que en vez de utilizar una variable interna para almacenar el valor y mostrar por

666
00:41:28,060 --> 00:41:31,980
pantalla el valor de esa variable interna que son muy cutre pues no vamos a hacer simplemente que

667
00:41:31,980 --> 00:41:37,060
new devuelva siempre un 42 con lo cual pase lo que pase en el limit siempre aunque le pasemos ahora

668
00:41:37,060 --> 00:41:41,980
un 23 como new ha devuelto un entero que es 42 siempre será un 42 independientemente de lo que

669
00:41:41,980 --> 00:41:48,100
intentáramos hacer en limit cuestión semántica es un constructor o un inicializador esto es una

670
00:41:48,100 --> 00:41:51,860
guerra perdida porque realmente un inicializador es decir él no está construyendo el objeto pero

671
00:41:51,860 --> 00:41:56,540
en toda la documentación de python se llama constructor así que en el fondo da igual es una

672
00:41:56,540 --> 00:42:00,020
cuestión semántica lo único que tenemos que tener claro es que el orden en el que ocurren las

673
00:42:00,020 --> 00:42:04,860
cosas que nosotros llamamos la clase para crear un objeto new entonces se ejecuta y no te vuelve

674
00:42:04,860 --> 00:42:09,660
el objeto y entonces es in it cuando ya inicializa el objeto casi nunca nos hace falta pero puede que

675
00:42:09,660 --> 00:42:14,220
algún día nos veamos en este escenario y en vez de perder semanas intentando encontrar que estaba

676
00:42:14,220 --> 00:42:22,220
pasando mal no viene muy bien saberlo y básicamente lo vamos a tener que dejar ahí porque hay otro

677
00:42:22,220 --> 00:42:28,660
cita de enero dos minutos hay una cita de dictra muy chula y es que para él la inmortalidad era

678
00:42:28,660 --> 00:42:33,380
suficiente con que si algún día estamos haciendo una de esas cosas rápida y sucia que no lo imaginemos

679
00:42:33,380 --> 00:42:37,340
aquí encima del hombro mirándonos y que pensáramos que él no le gustaba no le hubiera gustado eso

680
00:42:37,340 --> 00:42:43,900
en hubiera negado así con la cabeza de hecho hay una cita muy chula que era eso que el problema con

681
00:42:43,900 --> 00:42:50,380
el quick en dirt y este no que a veces se ve es que el dirt y el sucio sí que mucho tiempo después

682
00:42:50,380 --> 00:42:55,460
de que el quick haya dejado de ser importante como si eso me salvó la vida hace 35 años

683
00:42:55,460 --> 00:43:00,900
y eso te queda la sociedad y realmente esto la transparencia del código fuente sigue estando

684
00:43:00,900 --> 00:43:04,660
ahí no más o tiempo a cubrir dos puntos a cubrir los puntos que me da un poquito de pena y si

685
00:43:04,660 --> 00:43:26,060
tenéis alguna pregunta pues estamos.

