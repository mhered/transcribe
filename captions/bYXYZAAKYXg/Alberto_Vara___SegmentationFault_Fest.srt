1
00:00:00,000 --> 00:00:21,000
A continuación, Alberto Vara nos trae Segmentation Fold Fest.

2
00:00:21,000 --> 00:00:22,000
Alberto, todo tuyo.

3
00:00:22,000 --> 00:00:41,000
Hola, se me oye. Bien, bienvenidos a esta charla. Los que hayáis venido de la charla de Fede de Fasterpizon, que ha estado vendiéndome esta charla como cuatro veces, lo siento por el hype.

4
00:00:41,000 --> 00:01:03,000
La charla es así, así que tampoco... No me encarguen con todas las expectativas como esa, ¿vale? Bueno, un poco lo que quiero reflejar con esta charla es la fiesta de los errores, como esas noches de madrugada de estar mirando código que no funciona y estas al final pues me abro una cerveza ya las son las dos, ya llegué de mañana.

5
00:01:03,000 --> 00:01:30,000
Bueno, me presento muy rápido, yo soy Alberto Vara, yo he programado muchos años en MundoWeb, unos ocho en Python y para lo que ocupa hoy, pues el último año yo cambié trabajo y me he dedicado más al mundo web y ahora he estado más en, digamos lo que sería la parte de librerías, al final pues un módulo que al final los clientes van a instalar y tú estás ahí encordeando para hacer cosas y darle servicios.

6
00:01:30,000 --> 00:01:47,000
Eso sí, yo me he ido el último año. Y bueno, para descargar la presentación la tenéis aquí, es un poco larga, al final lo de GitHub, lo pondré luego en el Discord, así que no os preocupéis, no os si queréis hacer alguna foto o lo que sea.

7
00:01:47,000 --> 00:02:02,000
Ahí tenéis pues la slide esta, que va a ser todo slide, pero ahí hay mucho código fuente de todo lo que voy a mostrar para que lo podáis reproducir y si queréis me podáis abrirse una iso de implant de lo que has dicho es mentira, ya me sale esto, así que ahí espero vuestras isos si queréis.

8
00:02:02,000 --> 00:02:17,000
Y bueno, ¿por qué esta charla? Esta charla viene dada un poco pues eso, yo he empezado este último año en este mundo de librerías y llegamos, que pena ser un poco pequeñeja.

9
00:02:17,000 --> 00:02:31,000
Empecé con este mundo y había un momento en que la velocidad de ejecución con Python era un poco lenta, entonces dijimos se nos ocurrió la gran diosidad de decir, y si lo migramos hace más más, no puede dar problema.

10
00:02:31,000 --> 00:02:41,000
Aquí quería hacerle al ejemplo de una viñeta de KXKCD, de eso de compilando que va a pasar mal y pues básicamente es un poco mi día a día.

11
00:02:41,000 --> 00:02:56,000
Al escenario que os voy a plantear un poco hoy va a ser eso, en nuestras librerías tenemos que instrumentar código y al interferir en el código del cliente, en las librerías, en las webs que podéis hacer cualquiera de vosotros,

12
00:02:56,000 --> 00:03:09,000
pues nuestro problema es reducir al mínimo ese tiempo extra, ese overhead y pues dado que muchas veces tienes que reemplazar ese código pues ya hay un punto que Python no más de sí.

13
00:03:09,000 --> 00:03:24,000
Y por aclarar, yo cuando hablo de instrumentar código, me refiero a lo que nos llamamos grapear, el código que es muchas veces pues, decirlo muy muy pocas líneas, es como decorar todo el código,

14
00:03:24,000 --> 00:03:36,000
digamos, en vez de ir poniendo cada función, arroba, voy a hacer cosas extra en tu función, digamos con magia negra que hacemos, hacemos que eso automáticamente lo haga en todo tu módulo y en todo tu proyecto.

15
00:03:36,000 --> 00:03:45,000
Y pues eso implica que digamos se van a realizar muchas, muchas, muchas operaciones y nos hemos encontrado con este problema.

16
00:03:45,000 --> 00:03:59,000
Y para un poco un ejemplo anecdótico de lo que puede pasar con Python, de que los problemas que nos hemos encontrado con Python, cuando estamos hablando de escalas de nanosegundos o microsegundos,

17
00:03:59,000 --> 00:04:09,000
pues no sé, hay un ejemplo muy chorra que medimos, pues puede ser este, si nosotros tenemos la función 1, que simplemente es, vamos a hacer un G,

18
00:04:09,000 --> 00:04:18,000
3 variables, pues le hacíamos un time meet, va a haber cuánto es la media de la ejecución de esto, pues nos daba 3 nanosegundos, microsegundos, perdón.

19
00:04:18,000 --> 00:04:29,000
Si ejecutamos la función 6, que básicamente es llamar, la 6 llama la 5, la 5 la 4, la 4 la 3, la 2, la 1, pues ya se había un incremento de, ¿qué estáis viendo?

20
00:04:29,000 --> 00:04:42,000
Que sí, son, es casi el doble y con esto de los tiempos tampoco se nota, pero lo que digo, cuando estamos hablando de mejor esta escala de que a mejor esto se ha ejecutado,

21
00:04:42,000 --> 00:04:50,000
medio millón de veces, pues ya ese incremento, vas multiplicando por 10 por 10 los tiempos y pues este tipo de cosas que nos fuimos encontrando,

22
00:04:50,000 --> 00:04:54,000
pues nos hicieron hacer esa migración a otro lenguaje.

23
00:04:54,000 --> 00:05:04,000
Para lo que voy a enseñar, quiero, voy a intentar que sea muy práctico, aunque sea todo slide, pero básicamente, durante esto, va a haber mostrado estas cosas,

24
00:05:04,000 --> 00:05:21,000
pues como juntamos C++ con Zyton, una librería Babel's Marking que es Pay Perf, para hacer profiling Pay Spy, y luego ya, pues cuando con C++ no sabes qué hacer con tu vida, pues GDP.

25
00:05:21,000 --> 00:05:28,000
Y nada, esto es un poco la introducción y vamos ya en materia, así que nada, pues eso.

26
00:05:28,000 --> 00:05:38,000
Un ejemplo de cómo mejorar el performance en Python, utilizando C++, pues teníamos una función, una búsqueda binaria, pues por resumirlo muy rápido,

27
00:05:38,000 --> 00:05:46,000
pues tú tienes una lista ordenada, que lo que quieres buscar, quieres buscar un valor, que es el value, buscar dónde está en la lista, que está para arriba,

28
00:05:46,000 --> 00:05:52,000
pues te quedas con esa mitad, que no, coge la otra, vuelves a buscar y así, hasta quedas con el resultado.

29
00:05:52,000 --> 00:06:04,000
Si alguno, pues bueno, esto lo cogiste, creo que piedra Rosetta, Rosetta Code, perdón, si esto se puede optimizar muchísimo, así que, por lo mismo,

30
00:06:04,000 --> 00:06:07,000
si alguien no le gusta, que me haga un perre, por favor.

31
00:06:07,000 --> 00:06:21,000
Luego, eso, para medir un poco todo este tiempo, pues tenemos una lista, pues una lista así pequeñita, de c mil elementos, y luego para medirlo, pues eso, vamos a ejecutar esta misma función,

32
00:06:21,000 --> 00:06:26,000
x número de veces, diez veces, cien, lo que vayamos pasándole a la parámetro loop.

33
00:06:26,000 --> 00:06:37,000
Esto es una adaptación con Zyton, que básicamente, pues es un poco, como veis, es prácticamente igual, básicamente tiene la coletilla de CDF,

34
00:06:37,000 --> 00:06:42,000
y bueno, y luego hay un poco de notaciones de emplande, pues esto va a devolver un entero y demás.

35
00:06:42,000 --> 00:06:48,000
Zyton, básicamente, si Fede lo ha explicado en la otra charla, pero yo me voy a repetir, si no habéis estado,

36
00:06:48,000 --> 00:06:57,000
básicamente Zyton nos ayuda, digamos, con las entaxis de Python, generar código en C, o sea, básicamente tú cuando coges este código,

37
00:06:57,000 --> 00:07:02,000
lo tienes que compilar primero y debajar un fichero,.c o.cpp, si es C más más.

38
00:07:02,000 --> 00:07:10,000
O sea, para cor, si alguna más de la parte JavaScript es como el cofieScript, que digamos tú lo hacias,

39
00:07:10,000 --> 00:07:18,000
puedes utilizar las clases y cosas así en JavaScript y luego te lo compilaras con pilación a JavaScript nativo.

40
00:07:18,000 --> 00:07:26,000
Creo que era más o menos así, o sea, si me podía equivocar porque JavaScript, igual que de C más más, es una mierda.

41
00:07:26,000 --> 00:07:41,000
Y luego tenemos la misma función en C más más, lo mismo, o sea, si a lo mejor paso como a mí cuando empecé con esto,

42
00:07:41,000 --> 00:07:51,000
de hace 10 o más años, pues casi todos recordamos, bueno, yo recordaba códigos que al final para hacer una moñada,

43
00:07:51,000 --> 00:07:56,000
pero no lo he hecho en un código que era infumable. Y ahora ya con cosas de C moderno, pues, oye,

44
00:07:56,000 --> 00:08:02,000
fijaos que el número de líneas es prácticamente es idéntico al otro código que hemos visto.

45
00:08:02,000 --> 00:08:09,000
Aquí lo podéis ver. Casi lo que aumenta las líneas son las malditas llaves estas.

46
00:08:09,000 --> 00:08:15,000
Vale, este es nuestro escenario, pues ya está. Ahora lo que vamos a hacer es medirlo.

47
00:08:15,000 --> 00:08:23,000
Lo mismo que hemos visto en el ejemplo anterior, esta función de C más más le importamos desde Zayton,

48
00:08:23,000 --> 00:08:28,000
con las primeras dos líneas, y luego, digamos ya, con una función de Zayton,

49
00:08:28,000 --> 00:08:35,000
vamos a recorrer, igual que la otra función, un montón de veces, este bucle para medirlo.

50
00:08:35,000 --> 00:08:42,000
Lo dicho, esto, digamos, la gracia que tiene Zayton en este caso es que nosotros podemos importar directamente

51
00:08:42,000 --> 00:08:47,000
una función de C más más y utilizarla tal cual. Luego lo compilamos y ya lo podemos utilizar

52
00:08:47,000 --> 00:08:53,000
en el código Python ya sin compilar y nos olvidamos de estas cosas.

53
00:08:53,000 --> 00:08:58,000
Y nada, ahora sí, lo que decía, para ejecutar este benchmark,

54
00:08:58,000 --> 00:09:03,000
yo he utilizado Piper, que es una herramienta de benchmarking. Yo he hecho aquí un pequeño script,

55
00:09:03,000 --> 00:09:06,000
que es lo tenéis también en el repositorio, que es para tunear un poco este runner,

56
00:09:06,000 --> 00:09:12,000
y lo que yo luego he hecho es ejecutar esta herramienta de benchmarking contra los ficheros

57
00:09:12,000 --> 00:09:16,000
y me va a generar unos JSON donde me va a sacar toda la media.

58
00:09:16,000 --> 00:09:20,000
Lo mismo, si tenéis curiosidad, podéis ejecutar los ambos de ordenador,

59
00:09:20,000 --> 00:09:28,000
y esto empieza a hacer muchas iteraciones de ejecutar muchísimas veces el fichero que le estamos pasando

60
00:09:28,000 --> 00:09:35,000
y ahí saca sus medias y una Average y demás valores.

61
00:09:35,000 --> 00:09:40,000
Yo voy a sacar un poco de tabla simplificada, porque tampoco aporta mucho para lo que quiere enseñaros.

62
00:09:40,000 --> 00:09:44,000
Y bueno, con estas líneas, y en plan de ejecuto el benchmark para estas veces,

63
00:09:44,000 --> 00:09:49,000
el menos sí que lo paso un poco rápido, es el número de loops que vamos a hacer.

64
00:09:49,000 --> 00:09:54,000
Y luego, ya cuando saco los tres resultados, la gracia que tiene por ejemplo esta herramienta de Piper,

65
00:09:54,000 --> 00:10:01,000
es que me genera, le paso lo que dice el comando de Comperto, le puedo decir, digo,

66
00:10:01,000 --> 00:10:05,000
sacame una tabla que me diga los valores.

67
00:10:05,000 --> 00:10:09,000
Y entonces, pues ahora veríamos en plan de qué bien ha quedado nuestro código en C++.

68
00:10:09,000 --> 00:10:15,000
O no, porque en este caso, cuando le ejecutarlo, me digo que es son,

69
00:10:15,000 --> 00:10:19,000
tenga que haber puesto un punto más, mil 300 veces más lento.

70
00:10:19,000 --> 00:10:26,000
Digo, pues bueno, pues esto de migrar a C++, pues no chuta.

71
00:10:26,000 --> 00:10:30,000
Así que, entonces, pues yo qué hice en este caso, digo, bueno, pues vamos a indagar,

72
00:10:30,000 --> 00:10:34,000
vamos a indagamos aquí a ver qué he hecho mal, qué seguro que ha hecho mal, que obviamente,

73
00:10:34,000 --> 00:10:38,000
me piqué otra función, igual que un poco como rollo, hacer timings de una función,

74
00:10:38,000 --> 00:10:44,000
que en plan, no aporta mucho, porque aquí somos de país, esto es mierda de los decimas más.

75
00:10:44,000 --> 00:10:49,000
Aquí hacemos un timings para lo mismo, juzgar la función varias veces,

76
00:10:49,000 --> 00:10:55,000
y nada, lo compilo, y lo ejecuto, y me sale estos números, digo, vale, efectivamente,

77
00:10:55,000 --> 00:10:58,000
en la parte de decimas más, ha hecho algo mal.

78
00:10:58,000 --> 00:11:03,000
Pues bueno, como yo ya llevo tiempo con C++, yo ya sé un montón de esto,

79
00:11:03,000 --> 00:11:07,000
y cae en la cuenta de que, vale, digo, en país no estamos acostumbrados,

80
00:11:07,000 --> 00:11:14,000
de que los objetos mutables, país no nos ayuda, que no tengamos que pensar,

81
00:11:14,000 --> 00:11:18,000
y dices, pues si es mutable, yo te lo paso por referencia, tú no te preocupes.

82
00:11:18,000 --> 00:11:26,000
Pero en C++, ahí no estás a magia, así que, entonces, dije, bueno, pues nada,

83
00:11:26,000 --> 00:11:33,000
decimos, en plan, esa cosita de la empresa, pues, no es un vector y myLIS,

84
00:11:33,000 --> 00:11:40,000
que es la referencia, entonces, pues, vuelvo a compilar, y, oye, esto ya pinta mejor,

85
00:11:40,000 --> 00:11:47,000
dos gano segundos, perdón, microsegundos, pues acá se lo vuelvo a decir, ya lo digo una vez,

86
00:11:47,000 --> 00:11:51,000
piso un poco de léxico con estas cosas, sin mezclar gano segundos, microsegundos,

87
00:11:51,000 --> 00:11:59,000
no me lo tengáis en cuenta, fin de la nota. Lo ejecuto y, eh, mierda, pues,

88
00:11:59,000 --> 00:12:04,000
aquí falla algo, o sea, bueno, ya hemos visto, la parte de C++ parece que le hemos arreglado,

89
00:12:04,000 --> 00:12:09,000
pero aquí sigue fallando, porque no ha optimizado, no, o sea, de hecho,

90
00:12:09,000 --> 00:12:17,000
si esto lo ejecuta, o sea, 790 veces peor, no he podido cogerlo, así que vamos a seguir mirando.

91
00:12:17,000 --> 00:12:23,000
Esta vez vamos a utilizar otra herramienta, que es Pi Spy, que, básicamente, es una herramienta de profiler,

92
00:12:23,000 --> 00:12:30,000
hay otras, pues, yo que sé, como una nativa de Python es, perdón, adiós, qué calor,

93
00:12:30,000 --> 00:12:35,000
pues, yo que sé, está, hace profiler, que es, digamos, nativa de Python,

94
00:12:35,000 --> 00:12:40,000
que te puede ayudar para sacar, hacer también profiling de tu aplicación,

95
00:12:40,000 --> 00:12:48,000
y otra, por ejemplo, bueno, es menos conocida, para una que se llama Austin, que es parecida a Pi Spy,

96
00:12:48,000 --> 00:12:53,000
pero tiene algunas fijadillas de acerudif entre los resultados y está chula.

97
00:12:53,000 --> 00:12:58,000
Lo que iba, esta librería, lo que hace es lo mismo, en otro le pasamos una ejecución,

98
00:12:58,000 --> 00:13:04,000
que si se ve aquí, hacemos Python Binary Search Native,

99
00:13:04,000 --> 00:13:09,000
y con todo lo anterior lo que le estamos diciendo es, en plan, cuando se ejecute esto,

100
00:13:09,000 --> 00:13:17,000
captura todo el, digamos, todos los frames, con este ratio de 1000 samples por segundo,

101
00:13:17,000 --> 00:13:23,000
me parece que es, bueno, ahora, ahí me he coglado, no sé si por segundo o por microsegundo,

102
00:13:23,000 --> 00:13:30,000
pero bueno, es un rey tanto, porque lo normal, mejor, puede ser 200, 300, para que capture todo el output.

103
00:13:30,000 --> 00:13:35,000
Y con esto, que va a generarme una Flink Graph, que básicamente es esto,

104
00:13:35,000 --> 00:13:40,000
a pesar de nombre de estos festivaleros, no tiene nada que ver con Inflames o algún grupo así,

105
00:13:40,000 --> 00:13:46,000
esto es un poco pequeñito aquí, pero yo lo traduzco, vale, aquí es en medito.

106
00:13:46,000 --> 00:13:52,000
Todo este lado de la derecha es básicamente la ejecución del script, la búsqueda binaria,

107
00:13:52,000 --> 00:13:57,000
si más o menos se ve, que es Binary Search, que es todo ese meollo que vemos por la izquierda,

108
00:13:57,000 --> 00:14:03,000
todo esto desde la parte naranjita, pues pone Pi Vector from Pi Int,

109
00:14:03,000 --> 00:14:06,000
que ahí lo que nos está diciendo es que está haciendo una conversión

110
00:14:06,000 --> 00:14:14,000
de nuestro código Python al código nativo, y eso, digamos, cada vez que está ejecutando el bucle,

111
00:14:14,000 --> 00:14:20,000
este que vimos al principio, está realizando este proceso, o sea, digamos, ahí es donde tenemos el cuello y botella.

112
00:14:20,000 --> 00:14:24,000
Entonces, ya viendo, por ejemplo, este tipo, en este caso es muy sencillito,

113
00:14:24,000 --> 00:14:30,000
no es tan evidente como en muchos otros casos, pero para el toque académico que le quiero dar sirve.

114
00:14:30,000 --> 00:14:35,000
Nos vamos otra vez a nuestro código, como digo, que es aquí es el maldito donde nos está dando el error.

115
00:14:35,000 --> 00:14:41,000
En la imagen se ve un poco, te dice la línea y tal, pero bueno, creo lo que está señalando esa.

116
00:14:41,000 --> 00:14:47,000
Aquí preparamos eso, que le estamos pasando a nuestro Binary Search, que si recordamos,

117
00:14:47,000 --> 00:14:52,000
es la importación, importamos directamente a la función de CMASMAS,

118
00:14:52,000 --> 00:14:55,000
en nuestro código de Zyton, para luego utilizarlo en Python.

119
00:14:55,000 --> 00:15:00,000
Entonces, aquí estamos pasando un objeto de Python y se produce ese efecto.

120
00:15:00,000 --> 00:15:07,000
Entonces, ¿qué vamos a hacer? Pues, yo he hecho magia aquí y he dicho, bueno, pues ahora lo que hago es

121
00:15:07,000 --> 00:15:13,000
creo un vector de enteros, que es lo que es nuestro search list, y bueno, en este caso,

122
00:15:13,000 --> 00:15:18,000
digamos, Zyton hace un montón de magia por mí, que cuando yo hago simplemente mi vector

123
00:15:18,000 --> 00:15:23,000
igual a mi lista de Python, él por el solito, ya me hace esa magia, conversión magica, una vez por mí.

124
00:15:23,000 --> 00:15:27,000
Entonces, yo ya paso esta lista y ya lo tendríamos.

125
00:15:27,000 --> 00:15:34,000
Además, vamos a añadir un cambio extra, que nuestra función de, ya un poco porrisa el rizo,

126
00:15:34,000 --> 00:15:39,000
de nuestra búsqueda Binary de CMASMAS, pues en estas tres líneas que os destaco,

127
00:15:39,000 --> 00:15:44,000
pues en vez de hacer esto, vamos a pasarlo a un puntero, que es lo de las Terisco,

128
00:15:44,000 --> 00:15:48,000
o sea, no es un argumento de una función, hace otras cosas esto.

129
00:15:48,000 --> 00:15:54,000
Y con esto, pues, ya esto parece que pinta mejor, o sea, ya por fin, ya hemos quitado

130
00:15:54,000 --> 00:16:00,000
ese cuello de botella que hemos visto con Pyspy, perdón, y a ver, qué pasa.

131
00:16:00,000 --> 00:16:07,000
Pues, bueno, hemos quitado otro cerrito, pero, pues nada, ya esto.

132
00:16:07,000 --> 00:16:11,000
Ya digamos, pues nada, pues ya que se va a hacer con esto.

133
00:16:11,000 --> 00:16:17,000
Así que nada, dándole vueltas, dándole vueltas, pues dije, a ver si ya el problema estaba por otro lado.

134
00:16:17,000 --> 00:16:22,000
Así que dije, pues nada, vamos a ejecutar los 1000 bucles, dije, ahí va, ¿qué pasa aquí?

135
00:16:22,000 --> 00:16:28,000
Y en plan de mira, ya no pones Locker, ya pones Faster, y que pasa así luego pongo un cerrete

136
00:16:28,000 --> 00:16:32,000
más al número de bucles, ahí va, y sigue subiendo, y sigue subiendo.

137
00:16:32,000 --> 00:16:38,000
Y si le damos otro cerrito, a los 1100 bucles, en plan, mira, ¿dónde está aquí la magia?

138
00:16:38,000 --> 00:16:43,000
Pues básicamente, todo esto sigue siendo exactamente el mismo problema que hemos analizado antes.

139
00:16:43,000 --> 00:16:48,000
De la parte cuando tenemos el código de, aunque C vaya a toda leche,

140
00:16:48,000 --> 00:16:53,000
cuando pasamos de ese código de Python, al código nativo, digamos,

141
00:16:53,000 --> 00:16:59,000
hay un, dándole un peaje, o sea, digamos, hace una conversión de un lenguaje a otro,

142
00:16:59,000 --> 00:17:04,000
y digamos, pues nos va a meter siempre, hay una cantidad de tiempo que no podemos quitarnos.

143
00:17:04,000 --> 00:17:09,000
Pero como ya estamos haciendo más operaciones, y más, y más, y más, cada vez más, en C más más,

144
00:17:09,000 --> 00:17:16,000
ya digamos, pues bueno, como ese peaje eran unos par de microsegundos, pues ya no,

145
00:17:16,000 --> 00:17:21,000
ya digamos, ya hemos pagado ese peaje, y ya todo lo demás, ya todo esto es regalado.

146
00:17:21,000 --> 00:17:26,000
Así que, pues digamos, pues aquí ponemos un ejemplo de esto.

147
00:17:26,000 --> 00:17:31,000
Y a ver, vamos a pasar, bueno, una puntualización del Python,

148
00:17:31,000 --> 00:17:37,000
que yo he elegido también esa herramienta, porque también tiene una ventaja que,

149
00:17:37,000 --> 00:17:40,000
en este ejemplo, no se ve, pero, por ejemplo, cuando utiliza otras herramientas,

150
00:17:40,000 --> 00:17:44,000
tú pones el plan lo típico como Timeit, tú dices al principio, capturar datos,

151
00:17:44,000 --> 00:17:48,000
al final, parar de capturar, generalmente, fichar un output.

152
00:17:48,000 --> 00:17:53,000
Python, la maravilla que tiene, sobre todo, para, pues si haces proyectos web, por ejemplo,

153
00:17:53,000 --> 00:17:58,000
con Django, con Flash, lo que sea, si tú, por ejemplo,

154
00:17:58,000 --> 00:18:01,000
eso me pasó cuando no conocí esta herramienta, tú quieres capturar el tráfico

155
00:18:01,000 --> 00:18:05,000
con un Django que haces un run server, pues bueno, cuando andes,

156
00:18:05,000 --> 00:18:08,000
donde ves que se arranca la aplicación, ahí se está ejecutando,

157
00:18:08,000 --> 00:18:12,000
y no hay, digamos, un punto de salida, tienes que hacer algunas niapas,

158
00:18:12,000 --> 00:18:16,000
bueno, arrancar al principio el cprofile, pero luego, yo qué sé,

159
00:18:16,000 --> 00:18:21,000
con un handler, un signal, que cuando termine, pues le llamo al otro, y que para la ejecución.

160
00:18:21,000 --> 00:18:26,000
La gracia con PagePy, es que como tú capturas el tráfico, digamos, todo el proceso,

161
00:18:26,000 --> 00:18:31,000
pues, te ahorras un montón de líos de tener que tocar el propio código,

162
00:18:31,000 --> 00:18:34,000
en factura de ejecutas el script normal, y él te va capturando todo el tráfico,

163
00:18:34,000 --> 00:18:38,000
que a lo mejor tú le vas metiendo, caña tu, perdón, el tráfico,

164
00:18:38,000 --> 00:18:42,000
capturando las trazas de tu programa.

165
00:18:42,000 --> 00:18:46,000
Tú vas haciendo petición, por ejemplo, a tu web, y él va capturando cada request,

166
00:18:46,000 --> 00:18:50,000
y tú luego lo puedes ver, lo que sea, la fling, graf, esta que hemos visto antes,

167
00:18:50,000 --> 00:18:54,000
pues lo puedes ver por request, y es muchísimo más cómodo.

168
00:18:54,000 --> 00:18:59,000
Y bueno, ya volviendo, entrando al último punto del segmentation for,

169
00:18:59,000 --> 00:19:02,000
que tenía que meter uno para darle nombre a la charla,

170
00:19:02,000 --> 00:19:06,000
pues nada, digamos, ya cuando, bueno, podemos seguir,

171
00:19:06,000 --> 00:19:10,000
ya hemos optimizado nuestro código, pero podemos encontrar otras situaciones,

172
00:19:10,000 --> 00:19:13,000
como el ejemplo que os voy a enseñar.

173
00:19:13,000 --> 00:19:18,000
En este caso tenemos, tenemos un diccionario,

174
00:19:18,000 --> 00:19:21,000
que es de strings, y lo que hemos convertido en un string,

175
00:19:21,000 --> 00:19:23,000
a un diccionario de bytes.

176
00:19:23,000 --> 00:19:27,000
Pues yo me he hecho una clase en Zyton, por simplificados,

177
00:19:27,000 --> 00:19:29,000
o sea, podemos seguir con código de C más más,

178
00:19:29,000 --> 00:19:33,000
pero bueno, aprovechando la ventaja que da Zyton,

179
00:19:33,000 --> 00:19:36,000
que tiene sus coseillas, que ahora veremos,

180
00:19:36,000 --> 00:19:40,000
pero bueno, digamos, sabiendo paison, digamos,

181
00:19:40,000 --> 00:19:45,000
el cambio mental es muy pequeño, más o menos,

182
00:19:45,000 --> 00:19:48,000
aquí vemos que estamos utilizando un char, y demás.

183
00:19:48,000 --> 00:19:53,000
Entonces, bueno, esta es una función, que lo mismo, puede ser muy mejorable,

184
00:19:53,000 --> 00:19:58,000
pero quería adaptar una cosa que encontramos,

185
00:19:58,000 --> 00:20:01,000
que es un trabajo en datado, que fue un ejemplo real,

186
00:20:01,000 --> 00:20:03,000
de un fallo que tuvimos.

187
00:20:03,000 --> 00:20:06,000
Pues bueno, lo he adaptado obviamente,

188
00:20:06,000 --> 00:20:09,000
porque el código era, no sé si son clientas líneas,

189
00:20:09,000 --> 00:20:12,000
pues aquí en la diapositiva no me entraba.

190
00:20:12,000 --> 00:20:17,000
Vale, teníamos este código, y esa función,

191
00:20:17,000 --> 00:20:20,000
perdón, y que aquí hacemos la conversión de string a bytes,

192
00:20:20,000 --> 00:20:23,000
se lo asignamos al puntero este que hemos creado,

193
00:20:23,000 --> 00:20:26,000
un puntero de char, y actualizamos el diccionario con estos valores.

194
00:20:26,000 --> 00:20:29,000
La función es muy rara, esta parte es un poco rara,

195
00:20:29,000 --> 00:20:32,000
no tiene mucho sentido así, pero era para poder utilizar

196
00:20:32,000 --> 00:20:35,000
donde está el mío yo, que es esta función.

197
00:20:35,000 --> 00:20:38,000
Aquí tenemos un problema, ahora veremos,

198
00:20:38,000 --> 00:20:40,000
usted hace un poco de spoilers, pero aquí tenemos un problema.

199
00:20:40,000 --> 00:20:46,000
Y básicamente, lo mismo, si el objeto que me llega es un string,

200
00:20:46,000 --> 00:20:49,000
pues lo convierto, perdón, si ya de bytes,

201
00:20:49,000 --> 00:20:51,000
pues básicamente lo convierto a char,

202
00:20:51,000 --> 00:20:53,000
y porque luego los char en Zyton,

203
00:20:53,000 --> 00:20:56,000
luego los convierte a bytes automáticamente,

204
00:20:56,000 --> 00:20:58,000
para cuando lo vuelves a recuperar en Python.

205
00:20:58,000 --> 00:21:01,000
Y si era de tipo texto, pues hacemos una conversión intermedia,

206
00:21:01,000 --> 00:21:04,000
que estos son funciones de C, del código fuente de Python,

207
00:21:04,000 --> 00:21:06,000
que los hemos importado aquí.

208
00:21:06,000 --> 00:21:09,000
Y bueno, y aquí lo que estamos haciendo,

209
00:21:09,000 --> 00:21:13,000
que esto es una cosa extraña, PTR de cero,

210
00:21:13,000 --> 00:21:16,000
no es una lista, es la forma que tiene Zyton,

211
00:21:16,000 --> 00:21:22,000
decirle, asigna, o sea, es el valor este,

212
00:21:22,000 --> 00:21:25,000
o sea, es el puntero del objeto,

213
00:21:25,000 --> 00:21:28,000
es decir, que este puntero apunte a este valor,

214
00:21:28,000 --> 00:21:31,000
o sea, es lo que pondré con un asterisco,

215
00:21:31,000 --> 00:21:33,000
pero en Zyton tiene esta sintaxis.

216
00:21:33,000 --> 00:21:39,000
Pues ya con esto, vale, yo compilo Zyton,

217
00:21:39,000 --> 00:21:41,000
que normalmente suele ser un comando así,

218
00:21:41,000 --> 00:21:45,000
para algún setup, build, buildXt,

219
00:21:45,000 --> 00:21:46,000
que es la forma que tiene,

220
00:21:46,000 --> 00:21:48,000
me genera ya el fichero binario,

221
00:21:48,000 --> 00:21:50,000
y ya puedo ejecutar mi programa,

222
00:21:50,000 --> 00:21:53,000
hago un Python, segmentation y boom va.

223
00:21:53,000 --> 00:21:58,000
Y nos miento que con este fallo me he tirado muchas, muchas horas.

224
00:21:58,000 --> 00:22:01,000
¿Qué más?

225
00:22:01,000 --> 00:22:03,000
Entonces, yo para esto, ¿qué hice?

226
00:22:03,000 --> 00:22:05,000
Bueno, después de mucho buscar,

227
00:22:05,000 --> 00:22:08,000
que aquí parece que lo he sacado,

228
00:22:08,000 --> 00:22:09,000
básicamente es un poco la misma línea

229
00:22:09,000 --> 00:22:11,000
que otros comandos que hemos visto.

230
00:22:11,000 --> 00:22:15,000
Ejecuto gdb, le paso arts, y le paso mi programa.

231
00:22:15,000 --> 00:22:18,000
Porque bueno, recalcar que en plan de,

232
00:22:18,000 --> 00:22:20,000
cuando te falla algo en Z++,

233
00:22:20,000 --> 00:22:23,000
no es como en Python, que te da una pequeña tracita,

234
00:22:23,000 --> 00:22:28,000
o como en Java que...

235
00:22:28,000 --> 00:22:30,000
Pero bueno, que por lo menos te da algo.

236
00:22:30,000 --> 00:22:35,000
Aquí es segmentationfall, Oli, y hasta luego.

237
00:22:35,000 --> 00:22:39,000
Y pues dice, pues vale, y dice pongo prints,

238
00:22:39,000 --> 00:22:42,000
pero al final me sigue saliendo eso.

239
00:22:42,000 --> 00:22:44,000
Así que nada, pues eso.

240
00:22:44,000 --> 00:22:46,000
Dije, vamos a utilizar esta maravillosa herramienta.

241
00:22:46,000 --> 00:22:51,000
Gdb ejecuto esto, y me mete en una consola interactiva.

242
00:22:51,000 --> 00:22:55,000
Gdb pone r de run, y me ejecuta el programa.

243
00:22:55,000 --> 00:22:57,000
Que bueno, por aquí no aporta mucho,

244
00:22:57,000 --> 00:23:00,000
hasta que ya me dice, pum, pete, segmentationfall.

245
00:23:00,000 --> 00:23:02,000
Me dice lo que he apetado,

246
00:23:02,000 --> 00:23:06,000
que ha fallado en un momento que ha hecho un bytes de string,

247
00:23:06,000 --> 00:23:07,000
convertirlo a bytes.

248
00:23:07,000 --> 00:23:10,000
Digo, vale, como en los 200 millones de partes

249
00:23:10,000 --> 00:23:12,000
del código de Python, ¿dónde se hace eso?

250
00:23:12,000 --> 00:23:14,000
¿Qué más?

251
00:23:14,000 --> 00:23:16,000
Gdb ejecuta el comando backtrace,

252
00:23:16,000 --> 00:23:19,000
y mira, esto parece casi una excepción de Java.

253
00:23:19,000 --> 00:23:22,000
Pues me saca todo este troncho,

254
00:23:22,000 --> 00:23:25,000
y vamos a ver.

255
00:23:25,000 --> 00:23:27,000
Si empezamos a ver un poco el orden inverso,

256
00:23:27,000 --> 00:23:29,000
que es como saca los frames, nos vamos a esta línea,

257
00:23:29,000 --> 00:23:31,000
que lo siento, intento apañarlo como podido,

258
00:23:31,000 --> 00:23:33,000
pero te tiene que tirar de scroll.

259
00:23:33,000 --> 00:23:35,000
Pues si nos vamos, que a nuestra función,

260
00:23:35,000 --> 00:23:37,000
updateDig, que veíamos visto antes,

261
00:23:37,000 --> 00:23:40,000
está pasando el self, que vemos aquí.

262
00:23:40,000 --> 00:23:46,000
Y el bytes key, que era uno de los parámetros,

263
00:23:46,000 --> 00:23:48,000
y el otro, que ha pasado aquí,

264
00:23:48,000 --> 00:23:51,000
que dice que no puedo acceder a la posición de memoria.

265
00:23:51,000 --> 00:23:53,000
Digo, ajá, pillado.

266
00:23:53,000 --> 00:23:56,000
Entonces, ya hemos visto que el problema estaba aquí.

267
00:23:56,000 --> 00:23:59,000
Y pues, aquí ya fue un poco por descarte,

268
00:23:59,000 --> 00:24:01,000
de como no tengo ni idea de manejarme con punteros,

269
00:24:01,000 --> 00:24:03,000
pues algo he tenido que hacer ahí mal.

270
00:24:03,000 --> 00:24:05,000
Así que digamos, ya por descarte también,

271
00:24:05,000 --> 00:24:07,000
de lo que puede hacer el código,

272
00:24:07,000 --> 00:24:09,000
que es, al final, que esto es una moñada,

273
00:24:09,000 --> 00:24:11,000
que son cinco líneas,

274
00:24:11,000 --> 00:24:13,000
pues era casi el único if que hay.

275
00:24:13,000 --> 00:24:17,000
Que aquí, digamos, se estaba viendo si el valor de ese punter,

276
00:24:17,000 --> 00:24:20,000
lo que apuntaba ese puntero, era nul.

277
00:24:20,000 --> 00:24:22,000
Entonces dije, una solución,

278
00:24:22,000 --> 00:24:24,000
pues digo, bueno, a ver qué estoy haciendo,

279
00:24:24,000 --> 00:24:26,000
digo, vamos a probar.

280
00:24:26,000 --> 00:24:28,000
Y dije, bueno, vamos a iniciar el punter aquí,

281
00:24:28,000 --> 00:24:30,000
antes de asignarle el valor.

282
00:24:30,000 --> 00:24:33,000
Y, voilà, eso, spoiler, funcionó.

283
00:24:33,000 --> 00:24:35,000
Pero, ¿cuál era el problema?

284
00:24:35,000 --> 00:24:37,000
Que lo mismo, en plan, yo vengo de Paíso,

285
00:24:37,000 --> 00:24:40,000
me acostumbraba que, en plan, si os fijáis la línea 3 y 4,

286
00:24:40,000 --> 00:24:42,000
para mí es lo mismo, en plan, de,

287
00:24:42,000 --> 00:24:45,000
inicializo algo a nul, o si no le digo nada, es nul.

288
00:24:45,000 --> 00:24:48,000
Pues no, en C++, pues, como esto lo ponen, perdón,

289
00:24:48,000 --> 00:24:50,000
esto, como luego se convierte,

290
00:24:50,000 --> 00:24:53,000
este caso de código de Zayton se convierte a C++,

291
00:24:53,000 --> 00:24:57,000
nos encontramos esta sorpresa de que no es lo mismo.

292
00:24:57,000 --> 00:25:01,000
¿Por qué? Si tú intentas hacer un print de este char,

293
00:25:01,000 --> 00:25:04,000
pues básicamente era, bueno, siempre me petaba,

294
00:25:04,000 --> 00:25:06,000
pero una vez que os sé, no sé cómo lo conseguía hacer,

295
00:25:06,000 --> 00:25:08,000
pero un print que era como algo, o sea,

296
00:25:08,000 --> 00:25:12,000
barra X, numerito, o algo así, en este caso.

297
00:25:14,000 --> 00:25:17,000
Es básicamente en plan de queso, que apunta basurilla.

298
00:25:17,000 --> 00:25:20,000
De hecho, si este código le ejecutáis en Python 10,

299
00:25:20,000 --> 00:25:25,000
no entiendes, me das un segmentation fall,

300
00:25:25,000 --> 00:25:28,000
me imprimía un poco lo que le salía de las narices

301
00:25:28,000 --> 00:25:30,000
y, de hecho, si ponía un print,

302
00:25:30,000 --> 00:25:34,000
esto almacenaba el valor del print que había metido.

303
00:25:34,000 --> 00:25:36,000
La cosa que se vuelve loco, los normales,

304
00:25:36,000 --> 00:25:38,000
que tenemos un segmentation fall, en el perdón de los casos,

305
00:25:38,000 --> 00:25:40,000
es que de un pete tremenda vento horrible.

306
00:25:42,000 --> 00:25:44,000
Y, bueno, que eso, pues, le ponemos anul,

307
00:25:44,000 --> 00:25:47,000
y si hacemos otra vez esto, chachán,

308
00:25:47,000 --> 00:25:49,000
pues ya tenemos nuestro antiguo diccionario

309
00:25:49,000 --> 00:25:52,000
que habíamos visto, que ahora nos devuelve ya en bytes.

310
00:25:53,000 --> 00:25:56,000
Y, bueno, conclusión, que ya me queda poco tiempo

311
00:25:56,000 --> 00:25:59,000
y me estoy lejando un poquito, conclusión, pues,

312
00:25:59,000 --> 00:26:03,000
vamos a ver, pues eso, que como os quería intentar transmitir,

313
00:26:03,000 --> 00:26:07,000
que en plan de... Yo que vengo de más,

314
00:26:07,000 --> 00:26:10,000
con muy poco, yo llevo trabajando con Paiso muchísimo,

315
00:26:10,000 --> 00:26:13,000
pero es que ya digamos lo de Compilar, que no hemos acordado ni cómo era,

316
00:26:13,000 --> 00:26:15,000
pues me encuentro en muchas de estas cosas

317
00:26:15,000 --> 00:26:17,000
y espero que os pueda ayudar.

318
00:26:17,000 --> 00:26:20,000
Y, bueno, eso, lo primero, lo que hemos visto en la parte de optimizaciones,

319
00:26:20,000 --> 00:26:24,000
es que pasar de un lenguaje a otro, tiene un peaje,

320
00:26:24,000 --> 00:26:27,000
o sea que... que ojo con las operaciones.

321
00:26:27,000 --> 00:26:30,000
Un poco, digamos, y en mi caso, para entenderlo,

322
00:26:30,000 --> 00:26:32,000
que yo también que vengo muchos años de programa en web,

323
00:26:32,000 --> 00:26:34,000
al final cuando estás haciendo una arquitectura de microservicios,

324
00:26:34,000 --> 00:26:37,000
que en plan de si, vale, migro este...

325
00:26:37,000 --> 00:26:41,000
este trozo de huevo a otro y hacemos unas llamadas entre ellos,

326
00:26:41,000 --> 00:26:44,000
pero acá hay una de las atencias de red que te va a meter un coste.

327
00:26:46,000 --> 00:26:49,000
Un poco en esta misma línea, pues al final,

328
00:26:49,000 --> 00:26:51,000
dado este coste no se puede migrar todo.

329
00:26:51,000 --> 00:26:54,000
Y muchas veces, pues al final tienes este problema de que...

330
00:26:54,000 --> 00:26:56,000
Dice, bueno, migro es una función, pues que al final esa función

331
00:26:56,000 --> 00:26:58,000
recibe otro parámetro que tienes que migrar,

332
00:26:58,000 --> 00:27:00,000
que también tienes que migrar, porque si no tienes un peaje,

333
00:27:00,000 --> 00:27:03,000
más otro peaje, más otro peaje, y como hemos visto en el ejemplo,

334
00:27:03,000 --> 00:27:06,000
al final es peor el remedio que la enfermedad.

335
00:27:06,000 --> 00:27:08,000
Luego, en mi caso, pues como digo, en mi caso,

336
00:27:08,000 --> 00:27:12,000
porque pues yo... hay más costomas,

337
00:27:12,000 --> 00:27:15,000
yo vengo más acostumbrada a mojar eso, país en PHP, Javascript,

338
00:27:15,000 --> 00:27:18,000
y si quedamos con ese cambio de cambiar de chica

339
00:27:18,000 --> 00:27:22,000
a lenguajes de como C12 más MAP, pues me está costando un poquito más.

340
00:27:22,000 --> 00:27:26,000
Yo muchas veces lo tomo para ser más natural el cambio.

341
00:27:26,000 --> 00:27:29,000
Y bueno, y luego ya eso me daría para otra charla,

342
00:27:29,000 --> 00:27:32,000
pero al final lo he entendido una vez, porque hasta ahí no he llegado.

343
00:27:32,000 --> 00:27:35,000
El uso de memoria, que eso ya es...

344
00:27:35,000 --> 00:27:40,000
O sea, yo si ya sé en este punto, pero si puedo pasarme a Raste o Go,

345
00:27:40,000 --> 00:27:44,000
o lo que sea, por favor. No, pero, o sea, tienes esos problemas,

346
00:27:44,000 --> 00:27:47,000
pero bueno, luego los pros de que en todos los benchmarks

347
00:27:47,000 --> 00:27:50,000
que hemos hecho de lenguajes, para en estos casos juntando esto,

348
00:27:50,000 --> 00:27:53,000
y como habéis visto en la charla de Fede,

349
00:27:53,000 --> 00:27:56,000
aunque bueno, ahí no ha salido de C++ tan beneficiado,

350
00:27:56,000 --> 00:28:00,000
pero C++ tiene un benchmark increíble.

351
00:28:00,000 --> 00:28:04,000
Y poco más, que muchas gracias por vuestro tiempo,

352
00:28:04,000 --> 00:28:07,000
y bueno, la cuña publicitaria que os tengo que meter,

353
00:28:07,000 --> 00:28:10,000
que en el datadoje estamos contratando, si estáis interesados,

354
00:28:10,000 --> 00:28:13,000
tenemos están ahí fuera, y no podéis preguntar todo lo que queráis,

355
00:28:13,000 --> 00:28:15,000
y a mí también, y de la charla y de todo.

356
00:28:15,000 --> 00:28:18,000
Y no sé si, que voy justo, ¿te daré tiempo para preguntas?

357
00:28:18,000 --> 00:28:20,000
Pues ya está, pues muchas gracias.

358
00:28:20,000 --> 00:28:30,000
Muy bien, ¿tenemos alguna pregunta?

359
00:28:30,000 --> 00:28:31,000
Hola.

360
00:28:31,000 --> 00:28:36,000
Que levante la mano y llevo el micrófono, la pregunta.

361
00:28:36,000 --> 00:28:40,000
Si os da vergüenza, tranquilos,

362
00:28:40,000 --> 00:28:43,000
que luego Alberto está por ahí, le podéis preguntar.

363
00:28:43,000 --> 00:28:50,000
Bueno, te iba a preguntar acerca de,

364
00:28:50,000 --> 00:28:53,000
si te has planteado en lugar de usar Saison,

365
00:28:53,000 --> 00:28:57,000
utilizar, hacer una librería compartida y utilizar CFFI,

366
00:28:57,000 --> 00:28:59,000
y bueno, en esas partes,

367
00:28:59,000 --> 00:29:03,000
y después construir el traspaso del contenido de las variables.

368
00:29:03,000 --> 00:29:05,000
¿Con cuál has dicho? Perdona.

369
00:29:05,000 --> 00:29:09,000
CFFI, o sea, es construir las funciones foráneas al final.

370
00:29:09,000 --> 00:29:16,000
Las partes que yo, con lo que yo he probado,

371
00:29:16,000 --> 00:29:22,000
antes por ejemplo de utilizar Zyton, también utilice PiBin11.

372
00:29:22,000 --> 00:29:27,000
Pero por ejemplo en ese, el coste de pasar de Python a C,

373
00:29:27,000 --> 00:29:33,000
era muchísimo mayor, y de hecho, yo creo que lo ideal,

374
00:29:33,000 --> 00:29:35,000
¿se sigue oyendo? Vale.

375
00:29:35,000 --> 00:29:39,000
Lo ideal, por ejemplo, era de hacer módulos nativos.

376
00:29:39,000 --> 00:29:43,000
Quiere decir, tú en C puedes definir una forma que sea, digamos,

377
00:29:43,000 --> 00:29:47,000
Pi Function o Pi Module, y luego, digamos eso,

378
00:29:47,000 --> 00:29:49,000
cuando lo compilas, se importe directamente en Python.

379
00:29:49,000 --> 00:29:52,000
Y digamos, el resultado, eso es la parte mejor.

380
00:29:52,000 --> 00:29:54,000
Como tú dices, ¿no lo he probado?

381
00:29:54,000 --> 00:29:57,000
O sea, no sé decirte si justo eso,

382
00:29:57,000 --> 00:29:59,000
yo creo que he probado justo todos los casos, menos ese.

383
00:29:59,000 --> 00:30:01,000
O sea, que no sé decir, ¿sabes?

384
00:30:01,000 --> 00:30:07,000
Pues con eso no he probado, pero bueno,

385
00:30:07,000 --> 00:30:09,000
por lo menos, hasta de todos los demás,

386
00:30:09,000 --> 00:30:12,000
lo mejor si quiera, digamos, picarte los binding como a mano,

387
00:30:12,000 --> 00:30:15,000
digamos, de hacer el Pi Module y tal,

388
00:30:15,000 --> 00:30:18,000
y desde ahí ya lo importas en Python con un importe normal.

389
00:30:18,000 --> 00:30:21,000
O sea, hasta ahí lo he visto que es lo mejor.

390
00:30:21,000 --> 00:30:24,000
No sé, me faltaría mucho ese benchmark con eso.

391
00:30:24,000 --> 00:30:28,000
Pero si quieres, luego, pasame,

392
00:30:28,000 --> 00:30:31,000
o nos damos el contacto por Discord y cuando...

393
00:30:31,000 --> 00:30:35,000
De RAS, de RAS, de hecho, lo mediometí para la charla

394
00:30:35,000 --> 00:30:37,000
y era un poquito peor.

395
00:30:37,000 --> 00:30:39,000
¿Por qué está sepáis en la final la conversión?

396
00:30:39,000 --> 00:30:42,000
Con RAS, o sea, si quiera bueno, pero no tanto.

397
00:30:42,000 --> 00:30:44,000
O sea, mejor que Python, pero peor que...

398
00:30:44,000 --> 00:30:47,000
Seguía siendo peor que el nativo, pero por poquito, yo creo.

399
00:30:47,000 --> 00:30:49,000
¿Aguna duda más?

400
00:30:49,000 --> 00:30:51,000
¿Nadie más?

401
00:30:51,000 --> 00:30:55,000
Nadie más, bueno, pues un aplauso grande para Alberto.

402
00:30:55,000 --> 00:30:58,000
Gracias.

