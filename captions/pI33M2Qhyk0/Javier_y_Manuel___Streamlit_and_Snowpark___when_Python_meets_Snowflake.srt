1
00:00:00,000 --> 00:00:27,000
Bienvenidos, gracias por asistir. Supongo que ya lleváis bastante charla y se hace cada vez más valioso que estéis aquí con nosotros.

2
00:00:27,000 --> 00:00:39,000
Me voy a presentar primero, la charla, os vamos a hablar sobre dos tecnologías relacionadas con el NoFly, os contaremos que es el NoFly, el concepto de plataforma de datos Cloud,

3
00:00:39,000 --> 00:00:54,000
y os vamos a hablar de dos capacidades que ofrece un desarrollo rápido de datos, de data apps, y otra para ejecución de código de cualquier tipo, algorítmico en lenguajes de alto nivel,

4
00:00:54,000 --> 00:00:59,000
Python sería uno de ellos, de los principales, pero también otros como Java, que se llama el NoPath.

5
00:00:59,000 --> 00:01:09,000
El reto que tenemos es que os queremos contar muchas cosas en 35 minutos, incluso enseñar algunos demos, para que veáis que esa teoría o esa promesa de valor de esa tecnología es cierta,

6
00:01:09,000 --> 00:01:21,000
quizá vamos a ir un poquito rápido, si queréis me podéis parar, pero lo suyo sería que os guardase las preguntas, dudas para el final, pero si no va a estar un poco apretado, si nos ceñimos al tiempo de las charlas.

7
00:01:21,000 --> 00:01:30,000
Antes de nada, nos presentamos, yo soy Manuel Muñoz y él es mi compañero Javier Mayor Gas.

8
00:01:30,000 --> 00:01:40,000
Nosotros trabajamos en Cívica, Cívica es una empresa, si alguno la conoce o para los que no la conozcais, Granadina, trabajamos en ámbitos nacionales y algunos proyectos internacionales,

9
00:01:40,000 --> 00:01:44,000
y estamos muy enfocados en el mundo especializado en data.

10
00:01:44,000 --> 00:01:53,000
La empresa también se dedica a proyectos de transformación digital, desarrollo de software, empresaria a la medida, pero con un foco potente en lo que sería el mundo del dato.

11
00:01:53,000 --> 00:01:59,000
Yo soy director tecnológico y director de preventa, y Javier es el responsable del área de datasign.

12
00:01:59,000 --> 00:02:09,000
Entonces, sin más, lo que os decía, vamos a hablar de Streamlit y de NoPath, ambos están basados en Python como el lenguaje principal de desarrollo,

13
00:02:09,000 --> 00:02:17,000
pero esas tecnologías tienen cabida dentro de un concepto general o de una tecnología que alguno no se de hecho lo voy a preguntar.

14
00:02:17,000 --> 00:02:25,000
Alguien le suena en NoFle, le suena en los conceptos de plataformas de datos cloud, es bastante famoso a la gente que está en el mundillo,

15
00:02:25,000 --> 00:02:35,000
puede ser equivalente a otras tecnologías que a lo mejor se lo suenen como BigQuery o Redshift o Sign-Ups de Azure, de Microsoft, más o menos algunos si lo conocés.

16
00:02:35,000 --> 00:02:43,000
Pues, ¿qué es el NoFle? La forma más fácil de mirarlo sería pensar que es una base de datos, una base de datos en la nube, es mucho más que eso.

17
00:02:43,000 --> 00:02:50,000
No es solamente una base de datos pensada para uso analítico, para lo que sería montar un sistema informacional, sino que permite trabajar con datos,

18
00:02:50,000 --> 00:02:56,000
no solamente datos estructurados, una base de datos relacionados, sino datos semi-estructurados, datos no estructurados,

19
00:02:56,000 --> 00:03:04,000
y se está convirtiendo al final como en una plataforma, digamos, transversal para cualquier tipo de cargas sobre los datos.

20
00:03:04,000 --> 00:03:10,000
No solamente analíticas, sino incluso están desarrollando un motor específico para datos más o LTP,

21
00:03:10,000 --> 00:03:17,000
y con algunas ventajas fundamentales respecto a tecnologías más tradicionales como que son escalables, un mantenimiento muy fácil, etc.

22
00:03:17,000 --> 00:03:22,000
Eso está cambiando totalmente el mundo, el paradigma de los proyectos de datos.

23
00:03:22,000 --> 00:03:28,000
La arquitectura está evolucionando mucho, de arquitecturas tradicionales, de data warehouse o de data lake,

24
00:03:28,000 --> 00:03:35,000
donde se están fusionando en arquitectura lake house, donde puede hacer prácticamente todo en una única plataforma con un modelo de seguridad unificado, etc.

25
00:03:35,000 --> 00:03:43,000
Y ahí es donde están compitiendo esas tecnologías que ve ahí arriba, en no-flakes del Kaleid Databricks, que sonará por hacerse con ese mercado.

26
00:03:43,000 --> 00:03:51,000
En no-flakes cuando salió a Bolsa hace 2-3 años, creo que ha sido una de las más, si no la mayor, salió a Bolsa de la historia de las compañías de software,

27
00:03:51,000 --> 00:03:57,000
al estilo de la de Self, este tipo de compañías, para crear un poco el potencial de este tipo de tecnologías.

28
00:03:57,000 --> 00:04:07,000
Las ventajas que ofrecen, ya las puedo imaginar, escalables, facilidad de uso, no voy a entrar tanto en el no-flakes como tal,

29
00:04:07,000 --> 00:04:14,000
que si os quedé ahí, ahora lo voy a contar cómo en NOPAC entran dentro de esa solución para ofrecer esa facilidad,

30
00:04:14,000 --> 00:04:24,000
agilidad de desarrollo y montar proyectos grandes del estilo de data, con grandes volumetrías, grandes requerimientos de cómputo, dentro de una plataforma de este estilo.

31
00:04:24,000 --> 00:04:29,000
Entonces lo dejamos y ha aparcado el tema del no-flakes y vamos a hablar ahora de aplicaciones de datos.

32
00:04:29,000 --> 00:04:39,000
Entendiendo aplicaciones de datos como simplemente sacar los resultados de cualquier análisis más tradicional de tipo VI,

33
00:04:39,000 --> 00:04:46,000
de cualquier tipo o de datas hay en, como luego presento esos resultados, hago mi storytelling o mi análisis predictivo o predictivo

34
00:04:46,000 --> 00:04:48,000
de la información que yo estoy analizando.

35
00:04:48,000 --> 00:04:56,000
Hay distintas formas de hacer eso, las tradicionales podrían ser el uso de herramientas de VI, o sonarán Power BI, MicroStrategy, Click,

36
00:04:56,000 --> 00:05:03,000
todas las que se han venido usando de los últimos 20 años, pues es una forma fácil y rápida, más o menos, de hacer tu analítica,

37
00:05:03,000 --> 00:05:12,000
tu analítica o la app o tu presentar determinados resultados en una pantalla sin irte a un lenguaje de programación de propósito general.

38
00:05:12,000 --> 00:05:19,000
Vale, esa sería una opción, otra opción sería irnos al extremo, esa sería digamos fácil y rápida y no necesito ni siquiera programar en un lenguaje de alto nivel.

39
00:05:19,000 --> 00:05:26,000
Si me voy al otro extremo, yo podría hacer cualquier front con cualquier tecnología de propósito general, ángulas, red, la que creais,

40
00:05:26,000 --> 00:05:32,000
y claro, podría hacer cualquier cosa, lo podría hacer muy a medida, pero normalmente me llevaría mucho más esfuerzo y tiempo

41
00:05:32,000 --> 00:05:37,000
sacar y renderizar esos datos usando esas tecnologías en la parte de front.

42
00:05:37,000 --> 00:05:45,000
La parte central lo que os mostramos son framework intermedio, es decir, no voy a tener toda la flexibilidad de poder hacer cualquier cosa exactamente a la medida,

43
00:05:45,000 --> 00:05:54,000
pero las voy a poder desarrollar muy rápido, voy a poder hacer el resultado en pantalla sobre mi dataset, sobre los resultados que yo he tenido de una forma muy ágil,

44
00:05:54,000 --> 00:05:58,000
se trata de eso, os ponemos tres y os vamos a explicar la tercera, Streamly.

45
00:05:58,000 --> 00:06:06,000
La primera, Chinese, para que os quede sonando, está la sada en Erwin, como lenguaje no aplicaría para lo que sería este evento para la Python,

46
00:06:06,000 --> 00:06:14,000
pero la segunda sí, Plotly Dash, bastante común y extendida, y está basada en Python y Streamly también está basada en Python.

47
00:06:14,000 --> 00:06:20,000
Y os voy a contar eso, ¿qué es Streamly? ¿Cómo funcionaría? Básicamente es un framework para el desarrollo rápido de este tipo de aplicaciones de datos.

48
00:06:20,000 --> 00:06:27,000
¿Qué es lo que haríais vosotros? Pues imagina, si tenéis un script en Python donde hacéis cualquier tipo de procesamiento de datos,

49
00:06:27,000 --> 00:06:34,000
como lo venía haciendo normalmente, le vais a usar una librería, que al final lo que va a hacer es una llamada a una API del servicio de Streamly,

50
00:06:34,000 --> 00:06:41,000
donde vais simplemente a decirle, píntame esto, esto que yo he conseguido este DataFrame, si estás trabajando con Spark,

51
00:06:41,000 --> 00:06:49,000
o este objeto de cualquiera de los framework habituales que usáis para Datasign o profesamiento de los datos, píntamelo,

52
00:06:49,000 --> 00:06:58,000
sería como decir, Streamly.write, este objeto que yo ya he preparado, simplemente visualización de los resultados, rápido y directo.

53
00:06:58,000 --> 00:07:05,000
Ese script, como veis, sí, podemos pasar a la siguiente, ese script que veis arriba tan sencillo sería vuestro código Python normal,

54
00:07:05,000 --> 00:07:13,000
importaría la librería de Streamly y le diría el comando st.algo, punto write o punto line chart,

55
00:07:13,000 --> 00:07:18,000
y le pasáis el objeto que queréis que os pinte, el resultado sería directamente como un widget, ¿no?

56
00:07:18,000 --> 00:07:24,000
Tendría en este caso, en general, una aplicación que va a tener widget, un widget puede ser un mapa,

57
00:07:24,000 --> 00:07:31,000
un punto puede ser un diagrama de barra, un diagrama de líneas, puede ser una KPI, voy a pintar widget basado en determinados datos,

58
00:07:31,000 --> 00:07:36,000
¿cómo lo voy a pintar dentro de una aplicación? Lo normal, puedo poner paneles, puedo poner pestañas,

59
00:07:36,000 --> 00:07:40,000
voy a poner un layout, que si quiero dos columnas, quiero tres, todo muy rápido,

60
00:07:40,000 --> 00:07:45,000
es decir, desarrollo extremadamente rápido para pintar aplicaciones de datos.

61
00:07:45,000 --> 00:07:51,000
De esa manera, qué es lo que voy a hacer? Poder iterar de una forma muy sencilla en la presentación de la interfaz de usuario,

62
00:07:51,000 --> 00:07:56,000
encima lo han hecho de la forma más sencilla posible. Yo voy a crear, definir una aplicación,

63
00:07:56,000 --> 00:08:04,000
voy a decir en GitHub en qué repo está, en qué rama está y qué fichero, único fichero punto pi, es mi aplicación.

64
00:08:04,000 --> 00:08:11,000
Y ya se va a encargar de cada vez que yo hago un push de ese fichero, actualizar el servicio para que cualquier consumidor de esa aplicación

65
00:08:11,000 --> 00:08:17,000
vea siempre la versión actualizada. Sistema de desarrollo ya más sencillo y imposible.

66
00:08:17,000 --> 00:08:24,000
Además tiene una cosa buena, como realmente lo único que estás haciendo es sacar el resultado por Stringly,

67
00:08:24,000 --> 00:08:30,000
todo tu cómputo previo, todo lo que tú haces es Python puro, con las librerías que vosotros estáis más acostumbrados.

68
00:08:30,000 --> 00:08:35,000
Además, es capaz de sacar objeto de ese tipo de framework, de todos los que ve ahí.

69
00:08:35,000 --> 00:08:42,000
Si trabajáis con Queras, Pandas, Tensor, Plotlib, Matplotlib, cualquiera de eso,

70
00:08:42,000 --> 00:08:46,000
directamente tú le vas a hacer un pintame esto y ya te va a salir el gráfico.

71
00:08:46,000 --> 00:08:50,000
Parametrizable con distintos tipos de colores, ropciones, etcétera.

72
00:08:50,000 --> 00:08:55,000
Rápide extrema en el desarrollo de aplicaciones de datos basado en Python, ¿vale?

73
00:08:55,000 --> 00:09:00,000
El funcionamiento más o menos ya lo he contado, pues yo tengo un fichero punto pi, que lo voy a subir a mi repo

74
00:09:00,000 --> 00:09:05,000
y el servicio de Stringly automáticamente, o bien porque yo le digo, redeplóyamelo, refrescaló,

75
00:09:05,000 --> 00:09:11,000
o porque he hecho un push, automáticamente lo actualizan y sale el cambio en tu interfaz.

76
00:09:11,000 --> 00:09:14,000
Y ya se consume a través de una URL desde cualquier navegador, ¿vale?

77
00:09:14,000 --> 00:09:20,000
Entonces, rápida y de desarrollo, facilidad, actualización automática, control de acceso a las aplicaciones.

78
00:09:20,000 --> 00:09:24,000
No lo puede ver cualquiera, tú puedes decir que usuarios son los que pueden visualizar esa aplicación.

79
00:09:24,000 --> 00:09:29,000
Entonces, es muy fácil para o acelera mucho el desarrollo colaborativo de aplicaciones

80
00:09:29,000 --> 00:09:35,000
de la parte frontal de visualización y ideal para pintar cosas en proyectos de data size.

81
00:09:35,000 --> 00:09:39,000
Si lo probáis, lo que a lo mejor una aplicación antes os podía, no sé,

82
00:09:39,000 --> 00:09:44,000
depende de cómo seáis de rápido de qué aplicación, pero os voy a llevar día,

83
00:09:44,000 --> 00:09:49,000
son cuestión de una hora, minutos, es decir, súper, súper rápido, pintar aplicaciones de este tipo.

84
00:09:49,000 --> 00:09:53,000
Os lo vamos a enseñar con una demo, voy a dar paso a mi compañero Javier.

85
00:09:53,000 --> 00:09:55,000
Un momento.

86
00:09:55,000 --> 00:09:58,000
Vale, sí, sí, sí.

87
00:09:58,000 --> 00:10:02,000
Bueno, pues, ahora sí, sí, lo tengo juntado mucho, ¿no?

88
00:10:02,000 --> 00:10:08,000
Vale, el caso de uso que queríamos enseñar es, bueno, un data size que me voy a encontrar en internet

89
00:10:08,000 --> 00:10:12,000
que tiene un histórico de básicamente de accidentes.

90
00:10:12,000 --> 00:10:16,000
Vale, sí, se escucha, ¿no? Vale.

91
00:10:16,000 --> 00:10:20,000
De accidentes ocurrió en la ciudad de Nueva York, lo que tenemos datos, pues,

92
00:10:20,000 --> 00:10:24,000
de todo tipo, desde la fecha del accidente, localización, personas que han sido afectadas,

93
00:10:24,000 --> 00:10:26,000
tipo de vehículos, etcétera.

94
00:10:26,000 --> 00:10:32,000
Y en esta demo que vamos a presentar, bueno,

95
00:10:32,000 --> 00:10:37,000
vamos a dar esa facilidad que tiene Strelica que ha comentado a mi compañero Manuel,

96
00:10:37,000 --> 00:10:42,000
que cómo tan fácilmente se pueden disponer los elementos en nuestro web,

97
00:10:42,000 --> 00:10:46,000
nuestra data app, a partir de un layout que distribuimos fácilmente.

98
00:10:46,000 --> 00:10:51,000
En este caso, hemos establecido un site bar aquí a la izquierda,

99
00:10:51,000 --> 00:10:57,000
en lo que son filtros que permanecen y van a permitir hacer filtros

100
00:10:57,000 --> 00:11:01,000
a todo el data que aparecen en todas las siguientes pestañas.

101
00:11:01,000 --> 00:11:03,000
Esa distribución según pestañas que tengo aquí,

102
00:11:03,000 --> 00:11:08,000
esto de geografía, temporalía, vehicles, estos títulos de aquí arriba,

103
00:11:08,000 --> 00:11:11,000
nos facilitan la distribución de los datos a través.

104
00:11:11,000 --> 00:11:15,000
En este caso, hemos decidido dividir el análisis de datos en tres pestañas,

105
00:11:15,000 --> 00:11:18,000
una pestaña dedicada para el enfoque geográfico,

106
00:11:18,000 --> 00:11:21,000
otra pestaña dedicada para el enfoque de la temporalidad,

107
00:11:21,000 --> 00:11:23,000
cómo la temporalidad afecta a los accidentes, etcétera,

108
00:11:23,000 --> 00:11:28,000
y otra pestaña un poco más explicativa de qué tipo de vehículos son los que más afectan o no.

109
00:11:28,000 --> 00:11:33,000
Como bien he comentado, todos los filtros son totalmente dinámicos

110
00:11:33,000 --> 00:11:38,000
y los cambios que hagamos aquí hacen que el filtrado sea on-de-run.

111
00:11:38,000 --> 00:11:44,000
Los gráficos se van actualizando, en este caso, hemos filtrado por el distrito de Brooklyn,

112
00:11:44,000 --> 00:11:48,000
el mapa, ahora veremos cómo se explotea el mapa,

113
00:11:48,000 --> 00:11:50,000
que es simplemente una sola línea.

114
00:11:50,000 --> 00:11:55,000
También tenemos capacidad de poner métrica ahí a la derecha tipo KPI,

115
00:11:55,000 --> 00:11:58,000
igual que tenemos aquí abajo.

116
00:11:58,000 --> 00:12:02,000
Ya darnos al código, espero que lo veáis.

117
00:12:02,000 --> 00:12:06,000
Sí, lo he puesto en la letra un poco más grande.

118
00:12:06,000 --> 00:12:08,000
Títulos y subtítulos, lo hacemos muy fácil,

119
00:12:08,000 --> 00:12:11,000
una línea del código, ST.markdown,

120
00:12:11,000 --> 00:12:13,000
y ahí podemos meter el código que queramos.

121
00:12:13,000 --> 00:12:15,000
Títulos, con su CSS, incluso si queremos.

122
00:12:15,000 --> 00:12:19,000
División en pestaña, ST.tabs,

123
00:12:19,000 --> 00:12:21,000
eso ya le ponemos las pestañas que queramos,

124
00:12:21,000 --> 00:12:25,000
y luego con un weed, dentro de cada pestaña,

125
00:12:25,000 --> 00:12:28,000
ya vamos a tener nosotros para poder distribuir el contenido.

126
00:12:28,000 --> 00:12:30,000
El DataFrame, cogemos el DataFrame,

127
00:12:30,000 --> 00:12:33,000
vamos a manipular el DataFrame, exactamente igual que nosotros manipulamos

128
00:12:33,000 --> 00:12:37,000
nuestro DataFrame con un Jupyter Notebook, es un pandas.

129
00:12:37,000 --> 00:12:42,000
Entonces, cuando queramos plotear ese DataFrame, ¿cómo lo hacemos?

130
00:12:42,000 --> 00:12:45,000
En este momento, un barchar, ese punto barcha,

131
00:12:45,000 --> 00:12:48,000
en el gráfico del mapa.

132
00:12:48,000 --> 00:12:55,000
Muy rápido.

133
00:12:55,000 --> 00:12:59,000
Aquí arriba.

134
00:12:59,000 --> 00:13:04,000
GetMapBata, y ya se ploté el mapa.

135
00:13:04,000 --> 00:13:06,000
ST.map, el mapData.

136
00:13:06,000 --> 00:13:08,000
Solamente necesitaríamos que el mapDataFrame

137
00:13:08,000 --> 00:13:10,000
tuviera esas dos columnas,

138
00:13:10,000 --> 00:13:12,000
latitud y longitud, básico.

139
00:13:12,000 --> 00:13:14,000
Los KPI, simplemente reciben esos,

140
00:13:14,000 --> 00:13:19,000
reciben dos parámetros.

141
00:13:19,000 --> 00:13:22,000
El label primero, y si queramos poner un label secundario,

142
00:13:22,000 --> 00:13:24,000
por ejemplo, el aumento de los últimos meses, etcétera.

143
00:13:24,000 --> 00:13:27,000
¿Qué más cosas podemos hacer con respecto a temporalidad?

144
00:13:27,000 --> 00:13:31,000
Bueno, gráfico del tiempo, de cómo se han distribuido los accidentes,

145
00:13:31,000 --> 00:13:33,000
los accidentes por horas,

146
00:13:33,000 --> 00:13:35,000
incluso lo que ha comentado mi compañero Manuel.

147
00:13:35,000 --> 00:13:37,000
Supongamos que queremos utilizar librería,

148
00:13:37,000 --> 00:13:39,000
porque la librería que me ofrece es Trinly,

149
00:13:39,000 --> 00:13:41,000
tiene una limitación, ¿no?

150
00:13:41,000 --> 00:13:44,000
Y también, porque a mí me gustaría filtrarnos,

151
00:13:44,000 --> 00:13:46,000
hacer un poco de zoom, etcétera.

152
00:13:46,000 --> 00:13:49,000
Me gusta más la tipología de otro framework, etcétera.

153
00:13:49,000 --> 00:13:52,000
Bueno, pues nada, podemos utilizar Proly como en este caso,

154
00:13:52,000 --> 00:13:55,000
y hacemos un gráfico en el que es mucho más dinámico.

155
00:13:55,000 --> 00:13:57,000
Me gusta, lo puedo aprovechar quizás,

156
00:13:57,000 --> 00:14:00,000
porque en otro proyecto lo haya utilizado muy fácilmente.

157
00:14:00,000 --> 00:14:03,000
¿Cómo se hace esto?

158
00:14:03,000 --> 00:14:06,000
Bueno, aquí en este caso,

159
00:14:06,000 --> 00:14:10,000
metemos ST.inchard,

160
00:14:10,000 --> 00:14:13,000
o en este caso, aquí queramos el gráfico de Proly,

161
00:14:13,000 --> 00:14:16,000
y hacemos ST.plotlichard, y la figura directamente.

162
00:14:16,000 --> 00:14:20,000
Por último,

163
00:14:20,000 --> 00:14:23,000
para que veáis que no me miento,

164
00:14:23,000 --> 00:14:25,000
en esta parte de vehículos,

165
00:14:25,000 --> 00:14:28,000
me metí un filtro ahí, para esta página,

166
00:14:28,000 --> 00:14:31,000
del tipo de vehículos,

167
00:14:31,000 --> 00:14:33,000
y teniendo estos datos,

168
00:14:33,000 --> 00:14:35,000
con estos datos, con este tipo de dataframe,

169
00:14:35,000 --> 00:14:37,000
que es básicamente un group-buy del tipo de vehículos,

170
00:14:37,000 --> 00:14:41,000
y el número de accidentes, con un ST.bar chart,

171
00:14:41,000 --> 00:14:44,000
ya tendríamos ese dataframe,

172
00:14:44,000 --> 00:14:47,000
y se actualiza además sobre la marcha.

173
00:14:47,000 --> 00:14:49,000
Ok, intentad hacerlo.

174
00:14:49,000 --> 00:14:52,000
Aquí lo guardamos.

175
00:14:52,000 --> 00:14:56,000
Aquí.

176
00:14:56,000 --> 00:14:58,000
He recargado la página.

177
00:14:58,000 --> 00:15:10,000
Vengan a la pestaña de vehículos.

178
00:15:10,000 --> 00:15:12,000
Con el wifi del móvil.

179
00:15:12,000 --> 00:15:16,000
Y así ya quitamos, y aparece el gráfico rápidamente.

180
00:15:16,000 --> 00:15:18,000
Se va haciendo todo sobre la marcha,

181
00:15:18,000 --> 00:15:20,000
incluso el apartado de deployarlo,

182
00:15:20,000 --> 00:15:22,000
pues desde aquí rápidamente,

183
00:15:22,000 --> 00:15:26,000
deploy DISAV, y eso ya va a llamar a lo que ha dicho Manuel,

184
00:15:26,000 --> 00:15:28,000
que anteriormente, como mi proyecto,

185
00:15:28,000 --> 00:15:30,000
ya lo tengo de ployar en Git,

186
00:15:30,000 --> 00:15:33,000
automáticamente se va a ployar, es muy rápido.

187
00:15:33,000 --> 00:15:35,000
Y con esto, creo que no me dejo nada,

188
00:15:35,000 --> 00:15:37,000
te doy paso a ti, ¿vale Manuel?

189
00:15:37,000 --> 00:15:39,000
Que vamos a explicar la parte de NOPAR.

190
00:15:39,000 --> 00:15:41,000
Vale, a ver, ¿a qué lo importante?

191
00:15:41,000 --> 00:15:42,000
No sé si se ha entendido,

192
00:15:42,000 --> 00:15:44,000
puedes pensar, pon un framework para hacer desarrollo.

193
00:15:44,000 --> 00:15:47,000
Streamlit es un framework open source gratuito.

194
00:15:47,000 --> 00:15:49,000
Lo podéis usar en vuestro equipo,

195
00:15:49,000 --> 00:15:52,000
y ya tendréis la capacidad de pintar toda esa figura.

196
00:15:52,000 --> 00:15:54,000
Si además usáis Streamlit Cloud,

197
00:15:54,000 --> 00:15:57,000
y si hay un servicio de que se conecte a GitHub,

198
00:15:57,000 --> 00:15:59,000
y haga todo automático y el control de acceso,

199
00:15:59,000 --> 00:16:01,000
lo podéis mirar, lo podéis usar,

200
00:16:01,000 --> 00:16:03,000
eso es independiente del NoFly,

201
00:16:03,000 --> 00:16:05,000
¿por qué lo hemos metido en una charla relacionándolo con el NoFly?

202
00:16:05,000 --> 00:16:08,000
Porque el NoFly quiere que se ha descapaz de desarrollar aplicaciones,

203
00:16:08,000 --> 00:16:10,000
sin tener que hacer nada, totalmente SaaS,

204
00:16:10,000 --> 00:16:14,000
sin preocupar, y lo ha metido como un servicio dentro de la plataforma.

205
00:16:14,000 --> 00:16:17,000
Pero podéis usarlo totalmente con la independencia del NoFly.

206
00:16:17,000 --> 00:16:19,000
Y al final, vuestro código, limpio,

207
00:16:19,000 --> 00:16:24,000
lo que hace es simplemente, ST, LineChart, ST, Map,

208
00:16:24,000 --> 00:16:27,000
y pintar esas componentes organizadas en el layout que creáis.

209
00:16:27,000 --> 00:16:31,000
Rápido y fácil, parece sencillo y rápido.

210
00:16:31,000 --> 00:16:34,000
Vale, pasamos al backend.

211
00:16:34,000 --> 00:16:38,000
¿Cómo puedo ejecutar código de alto nivel de cualquier tipo?

212
00:16:38,000 --> 00:16:41,000
Cargas de trabajo WorldLogs, de data engineering,

213
00:16:41,000 --> 00:16:43,000
de data science de cualquier tipo,

214
00:16:43,000 --> 00:16:46,000
de forma escalable, sin preocuparme por la infraestructura,

215
00:16:46,000 --> 00:16:49,000
y de manera automática, que yo no tengo que estar preocupándome

216
00:16:49,000 --> 00:16:52,000
de historias de Kubernetes, de infra, de dimensionales,

217
00:16:52,000 --> 00:16:55,000
cuánto cómputo necesito en mi backend.

218
00:16:55,000 --> 00:16:58,000
Los que te estáis trabajando con Spark o DataBreeze,

219
00:16:58,000 --> 00:17:01,000
lo tenéis más menos fácil, si vais por la interfaz de Spark,

220
00:17:01,000 --> 00:17:04,000
si usáis los DataFrame, os podéis desacoplar,

221
00:17:04,000 --> 00:17:06,000
porque luego hay una escalabilidad de los clusters,

222
00:17:06,000 --> 00:17:09,000
y digamos que podáis tener paralelismo.

223
00:17:09,000 --> 00:17:12,000
Aquí el NoPAR persigue lo mismo, pero va mucho más allá.

224
00:17:12,000 --> 00:17:14,000
Básicamente lo que han hecho los NoFly,

225
00:17:14,000 --> 00:17:18,000
es copiar tal cual Spark, si veis,

226
00:17:18,000 --> 00:17:22,000
es NoPARC, han copiado Spark,

227
00:17:22,000 --> 00:17:24,000
y los han fusilado y han hecho lo mismo.

228
00:17:24,000 --> 00:17:27,000
Si no es exactamente compatible, pero es exactamente igual.

229
00:17:27,000 --> 00:17:30,000
El concepto de DataFrame, podéis coger datos de cualquier origen

230
00:17:30,000 --> 00:17:32,000
y tratarlo sobre el DataFrame,

231
00:17:32,000 --> 00:17:35,000
como si fuese una tabla lógica, de forma paralelizable.

232
00:17:35,000 --> 00:17:37,000
Pero han hecho más todavía.

233
00:17:37,000 --> 00:17:40,000
Lo que permiten es, no solamente en Python,

234
00:17:40,000 --> 00:17:43,000
que va a ser el lenguaje principal y el más usado en el NoPARC,

235
00:17:43,000 --> 00:17:45,000
sino en Java y en Scala,

236
00:17:45,000 --> 00:17:48,000
podréis inyectarles a NoFly cualquier código que queráis.

237
00:17:48,000 --> 00:17:52,000
Cualquier función, cualquier clase, lo que queráis,

238
00:17:52,000 --> 00:17:54,000
se lo vais a registrar.

239
00:17:54,000 --> 00:17:58,000
Como si lo pasáis bycode, que se va a pasar a NoFly

240
00:17:58,000 --> 00:18:00,000
y que se va a ejecutar de forma escalable

241
00:18:00,000 --> 00:18:03,000
en la infraestructura de NoFly, cuando vosotros lo invoqueis.

242
00:18:03,000 --> 00:18:05,000
Eso es muy potente, porque lo que te da

243
00:18:05,000 --> 00:18:07,000
es una infraestructura de cómputo escalable

244
00:18:07,000 --> 00:18:09,000
fácil de usar para cualquier carga.

245
00:18:09,000 --> 00:18:13,000
Entrenar un modelo, inferencia, transformaciones de datos,

246
00:18:13,000 --> 00:18:15,000
cálculos complejos.

247
00:18:15,000 --> 00:18:19,000
NoFly lo que hacía era eso, pero solamente para SQL.

248
00:18:19,000 --> 00:18:21,000
Tú lo pasabas cualquier consulta en SQL

249
00:18:21,000 --> 00:18:23,000
y en la paralelizaba y te daba un resultado

250
00:18:23,000 --> 00:18:26,000
para volumetría gigantesca muy rápido.

251
00:18:26,000 --> 00:18:28,000
Pero con SQL podías hacer ciertas operaciones.

252
00:18:28,000 --> 00:18:32,000
Es cómputo, pero cómputo estructurado, algebraico,

253
00:18:32,000 --> 00:18:34,000
y todo el resto de cómputo,

254
00:18:34,000 --> 00:18:36,000
lenguajes de alto nivel,

255
00:18:36,000 --> 00:18:39,000
con bucle, iteraciones, for, control, if.

256
00:18:39,000 --> 00:18:42,000
En SQL no hay tanta riqueza para hacer operaciones.

257
00:18:42,000 --> 00:18:44,000
También las va a poder tener con el NoFly.

258
00:18:44,000 --> 00:18:46,000
¿Cómo funciona?

259
00:18:46,000 --> 00:18:50,000
Si veis NoFly como un motor de cálculo elástico,

260
00:18:50,000 --> 00:18:54,000
veis la parte izquierda, que era como se confibió originalmente el producto.

261
00:18:54,000 --> 00:18:57,000
SQL lo han ampliado para que en el lado de servidor

262
00:18:57,000 --> 00:19:01,000
podáis ejecutar cualquier código elásticamente

263
00:19:01,000 --> 00:19:03,000
sin preocuparos de nada.

264
00:19:03,000 --> 00:19:07,000
¿Pero que lo haces por debajo si es un código Java 20 máquinas virtuales

265
00:19:07,000 --> 00:19:09,000
en paralelo accediendo al mismo dato?

266
00:19:09,000 --> 00:19:11,000
Es encargar a eso.

267
00:19:11,000 --> 00:19:13,000
No tenéis que preocupar de eso.

268
00:19:13,000 --> 00:19:15,000
Lo único que voy a hacer es invocarlo.

269
00:19:15,000 --> 00:19:18,000
Podéis usar, es como una mezcla del concepto DataFrameDepart

270
00:19:18,000 --> 00:19:21,000
y código que podáis ingestar en el NoFly

271
00:19:21,000 --> 00:19:24,000
y invocar bien como procedimiento almacenado o como UDF.

272
00:19:24,000 --> 00:19:27,000
A los que trabajáis con SQL, las funciones definidas por el usuario,

273
00:19:27,000 --> 00:19:31,000
las va a poder usar en SQL como si fuese una zoom o una operación normal.

274
00:19:31,000 --> 00:19:35,000
Vaya poder crear UDF, vosotros, que además escalan

275
00:19:35,000 --> 00:19:38,000
porque previamente la vais desarrollado en el lenguaje de vuestra Java.

276
00:19:38,000 --> 00:19:40,000
Esto es muy potente para el que...

277
00:19:40,000 --> 00:19:43,000
No sé si conseguiremos traer la ley de Avion o no, el que entienda esto,

278
00:19:43,000 --> 00:19:47,000
esto es game changing, esto cambia el paradigma.

279
00:19:47,000 --> 00:19:49,000
Siguiendo un poco, sí, por favor,

280
00:19:49,000 --> 00:19:53,000
¿cuáles son las ventajas que da esto?

281
00:19:53,000 --> 00:19:57,000
Primero, no es como solamente en Spark,

282
00:19:57,000 --> 00:20:00,000
que está limitado a Spark, de SQL Spark o escala.

283
00:20:00,000 --> 00:20:03,000
Ya se abre a Java y van a seguir metiendo más lenguajes

284
00:20:03,000 --> 00:20:06,000
para que cada uno programes realmente en el lenguaje que quieras.

285
00:20:06,000 --> 00:20:10,000
Aquí lo que cambia realmente el juego aquí es,

286
00:20:10,000 --> 00:20:13,000
por ejemplo, frente a un Databricks, todo el cómputo,

287
00:20:13,000 --> 00:20:16,000
está en el motor de cómputo de Databricks,

288
00:20:16,000 --> 00:20:18,000
está fuera de donde están tus datos.

289
00:20:18,000 --> 00:20:20,000
Si tú quieres hacer cualquier operación,

290
00:20:20,000 --> 00:20:22,000
te tienes que traer los datos desde NoFly o de...

291
00:20:22,000 --> 00:20:25,000
Digo, el NoFly podría ser otra tecnología, pero entende el concepto.

292
00:20:25,000 --> 00:20:28,000
Lo tenéis que sacar de NoFly, llevarlo al Clastio de Databricks,

293
00:20:28,000 --> 00:20:32,000
procesar el dato y luego seguramente volver a guardar el resultado.

294
00:20:32,000 --> 00:20:35,000
Aquí cómputo y datos están en la misma plataforma.

295
00:20:35,000 --> 00:20:41,000
Esa es eficiencia, seguridad, eso es muy potente.

296
00:20:41,000 --> 00:20:43,000
Es equivalente a que cuando está haciendo operaciones,

297
00:20:43,000 --> 00:20:46,000
por ejemplo, de Atanghenirin, está haciendo pushdown.

298
00:20:46,000 --> 00:20:48,000
La ejecución de ese cómputo, de SQL,

299
00:20:48,000 --> 00:20:51,000
se hace en el mismo motor de base de datos.

300
00:20:51,000 --> 00:20:53,000
¿Por qué no se hace hace cinco años, hace 10 años,

301
00:20:53,000 --> 00:20:55,000
antes de que llegan estas tecnologías?

302
00:20:55,000 --> 00:20:57,000
Porque los motor de base de datos no eran escalables,

303
00:20:57,000 --> 00:21:00,000
no soportaran cómputos escalables, echarle al revés.

304
00:21:00,000 --> 00:21:02,000
Tenéis que protegerlo para que no se petaran

305
00:21:02,000 --> 00:21:05,000
y tenéis que sacar fuera el cómputo.

306
00:21:05,000 --> 00:21:09,000
Ahora no, cuanto más este cómputo en el motor de base de datos,

307
00:21:09,000 --> 00:21:10,000
mejor.

308
00:21:10,000 --> 00:21:13,000
Os va a permitir el uso de DataFrame como Spark,

309
00:21:13,000 --> 00:21:15,000
es como digo una copia, sin más,

310
00:21:15,000 --> 00:21:17,000
no se han cumplido mucho la vida.

311
00:21:17,000 --> 00:21:19,000
Vaya poder usar UDF definidas por vosotros

312
00:21:19,000 --> 00:21:21,000
y luego esto es muy potente.

313
00:21:21,000 --> 00:21:24,000
Tenéis registrado en la plataforma, de forma escalable y fácilmente usable,

314
00:21:24,000 --> 00:21:27,000
de manejando todas las dependencias, paquetes, etcétera,

315
00:21:27,000 --> 00:21:30,000
todos los paquetes, todas las librerías anacondas.

316
00:21:30,000 --> 00:21:33,000
Es decir, vaya poder usar en el backend cualquier desarrollo

317
00:21:33,000 --> 00:21:36,000
que ya está haciendo normalmente con cualquiera de las librerías comunes que usáis.

318
00:21:36,000 --> 00:21:39,000
Es decir, realmente esto se convierte en,

319
00:21:39,000 --> 00:21:41,000
no quiero saber nada de la infra,

320
00:21:41,000 --> 00:21:44,000
yo diseño mi lógica, la enchufo ahí y la ejecuto

321
00:21:44,000 --> 00:21:47,000
con escalabilidad para la grande volumetría, etcétera.

322
00:21:47,000 --> 00:21:48,000
Vale.

323
00:21:48,000 --> 00:21:51,000
Es facilitar el desarrollo porque vaya poder hacer cualquier,

324
00:21:51,000 --> 00:21:53,000
con un mismo equipo y con una misma infra,

325
00:21:53,000 --> 00:21:56,000
poder hacer prácticamente cualquier cosa que se pueda hacer con datos.

326
00:21:56,000 --> 00:21:59,000
Y luego, como digo, al estar el dato en el mismo sitio

327
00:21:59,000 --> 00:22:02,000
y no tener que salir, está gobernado, está securizado,

328
00:22:02,000 --> 00:22:04,000
puedes controlar con un modelo de seguridad basado en roles,

329
00:22:04,000 --> 00:22:06,000
qué usuario puede ver qué dato y qué no,

330
00:22:06,000 --> 00:22:08,000
y no depende de los consumidores y de los clientes

331
00:22:08,000 --> 00:22:10,000
de qué consulta hagan o no.

332
00:22:10,000 --> 00:22:12,000
Nunca van a pasar el filtro de seguridad.

333
00:22:14,000 --> 00:22:17,000
Ese gráfico, bueno, aparte, no he comentado antes,

334
00:22:17,000 --> 00:22:20,000
todo el código que tenemos ahí, que no da tiempo a explicarlo en detalle,

335
00:22:20,000 --> 00:22:23,000
no lo podéis pedir o dudas que tengáis después, las comentamos.

336
00:22:23,000 --> 00:22:25,000
Esto es igual, ¿no?

337
00:22:25,000 --> 00:22:28,000
Realmente, cómo funciona es la parte izquierda,

338
00:22:28,000 --> 00:22:30,000
es como venía funcionando hasta ahora.

339
00:22:30,000 --> 00:22:32,000
Hay un query engine que coge las consultas de SQL,

340
00:22:32,000 --> 00:22:36,000
las paraleliza y las hace sobre los datos que están guardados en el NOFLE,

341
00:22:36,000 --> 00:22:39,000
pues lo que han hecho es un serializador de datos

342
00:22:39,000 --> 00:22:42,000
para que tú registras en el NOFLE tu código item,

343
00:22:42,000 --> 00:22:47,000
tu código Java, y luego lo invoques desde un cliente

344
00:22:47,000 --> 00:22:49,000
ejecutándose en el NOFLE, ¿se entiende?

345
00:22:49,000 --> 00:22:51,000
¿No, el concepto?

346
00:22:51,000 --> 00:22:54,000
Básicamente te da una infra de cómputo escalable

347
00:22:54,000 --> 00:22:57,000
para cualquier tipo de proyecto basado en datos prácticamente.

348
00:22:57,000 --> 00:23:00,000
Si a esto le ponéis, dice, vale, me habéis resuelto el vaquen

349
00:23:00,000 --> 00:23:03,000
y me das una forma, un servicio totalmente ligero y sencillo

350
00:23:03,000 --> 00:23:06,000
de hacer la parte de front que es Strigly,

351
00:23:06,000 --> 00:23:10,000
pues puede hacer prácticamente cualquier aplicación basada en datos

352
00:23:10,000 --> 00:23:13,000
sin salirme del NOFLE, que es lo que ellos van buscando,

353
00:23:13,000 --> 00:23:18,000
llevarte tu dato y tu cómputo y tus desarrollos a la propia plataforma, ¿vale?

354
00:23:18,000 --> 00:23:23,000
Os vamos a enseñar un ejemplo de Snowpad, rápido, como en 5 minutos,

355
00:23:23,000 --> 00:23:27,000
y comentamos cómo todo esto empaquetado es muy potente, ¿vale?

356
00:23:27,000 --> 00:23:29,000
Es bastante...

357
00:23:29,000 --> 00:23:33,000
Cambia bastante las reglas de juego de este tipo de proyectos.

358
00:23:33,000 --> 00:23:35,000
Vale.

359
00:23:37,000 --> 00:23:41,000
Lo dicho, el data set que hemos usado en este caso

360
00:23:41,000 --> 00:23:44,000
es un data set típico de operaciones fraudulentas.

361
00:23:44,000 --> 00:23:48,000
En este caso, no voy a entrar ahora en el detalle de Strigly,

362
00:23:48,000 --> 00:23:51,000
porque veréis que hemos utilizado Strigly,

363
00:23:51,000 --> 00:23:53,000
¿para qué? Para la hiperparametrización del modelo,

364
00:23:53,000 --> 00:23:58,000
para luego ver la inferencia, etcétera, de una manera muy visual.

365
00:23:58,000 --> 00:24:04,000
Entonces, ¿para qué usamos aquí en Snowpad?

366
00:24:04,000 --> 00:24:06,000
¿Para qué en la ciencia el dato puede aportar a Snowpad?

367
00:24:06,000 --> 00:24:08,000
¿Y para qué en la ingeniería del dato?

368
00:24:08,000 --> 00:24:12,000
En nuestro caso, en un entrenamiento típico de machine learning,

369
00:24:12,000 --> 00:24:14,000
vamos aquí, nosotros disponemos todo lo hiperparametro

370
00:24:14,000 --> 00:24:18,000
que tendría nuestro modelo, y nosotros aquí utilizamos en Snowpad.

371
00:24:18,000 --> 00:24:20,000
¿Para qué?

372
00:24:20,000 --> 00:24:23,000
Para que todo ese cómputo, toda esa escalabilidad,

373
00:24:23,000 --> 00:24:26,000
si son miles, millones de datos, me da igual lo que sea,

374
00:24:26,000 --> 00:24:28,000
el tipo de modelo que esté usando, todo,

375
00:24:28,000 --> 00:24:31,000
como tengo el soporte de Naconda, tengo la escalabilidad,

376
00:24:31,000 --> 00:24:34,000
todo eso se va a hacer arriba, junto al dato.

377
00:24:34,000 --> 00:24:37,000
En cambio, esto con SPAR, ¿qué pasaba?

378
00:24:37,000 --> 00:24:39,000
El dato me lo tenía que traer, junto a dónde,

379
00:24:39,000 --> 00:24:42,000
junto a los clásteres de SPAR, los datos se tenían que mover.

380
00:24:42,000 --> 00:24:44,000
En este caso, no.

381
00:24:44,000 --> 00:24:46,000
¿Cómo hacemos esto?

382
00:24:46,000 --> 00:24:50,000
Bueno, lo hacemos gracias al uso de estos paquetes de Naconda,

383
00:24:50,000 --> 00:24:54,000
como he comentado anteriormente, y al uso de procedimiento almacenado.

384
00:24:54,000 --> 00:24:56,000
¿Por qué procedimiento almacenado y no UDF?

385
00:24:56,000 --> 00:24:59,000
Bueno, esto luego, si queréis, en el apartado de dudas,

386
00:24:59,000 --> 00:25:01,000
lo comentáis.

387
00:25:01,000 --> 00:25:08,000
Ahora voy a comentar rápidamente, ¿cómo cae esto dentro del código?

388
00:25:08,000 --> 00:25:11,000
En nuestro caso, para el entrenamiento del modelo,

389
00:25:11,000 --> 00:25:13,000
nosotros se tearíamos todas las variables,

390
00:25:13,000 --> 00:25:16,000
todo lo que necesitamos, en ese cuadro de mando que hemos hecho rápidamente,

391
00:25:16,000 --> 00:25:20,000
en Strigly, y ahora queremos probar ese modelo, ¿cómo sería?

392
00:25:20,000 --> 00:25:26,000
Entonces, en nuestro caso, aquí hemos entrenado un modelo,

393
00:25:26,000 --> 00:25:32,000
ese modelo, esa función de entrenamiento que recibe,

394
00:25:32,000 --> 00:25:35,000
recibe todos los hiperparámetros que hemos seteado en el apartado de Strigly,

395
00:25:35,000 --> 00:25:39,000
y aquí dentro haríamos todo el proceso de ciencia del dato,

396
00:25:39,000 --> 00:25:43,000
tal y como se haría en un Jupyter, en cualquier otro sitio.

397
00:25:43,000 --> 00:25:48,000
Todo exactamente igual, Juan Jotén, Coding, División Entre Inits, todo, ¿vale?

398
00:25:48,000 --> 00:25:53,000
Aquí utilizamos un modelo random forest y sacamos una serie de predicciones.

399
00:25:53,000 --> 00:25:58,000
¿Vale? Pero estamos haciendo en la nube, ese modelo, ¿dónde está?

400
00:25:58,000 --> 00:26:00,000
Bueno, nosotros hemos almacenado ese modelo,

401
00:26:00,000 --> 00:26:03,000
donde en el stage, justo ahí, también en el noflet,

402
00:26:03,000 --> 00:26:06,000
y luego, ese modelo, cuando queramos inferir,

403
00:26:06,000 --> 00:26:10,000
ese modelo lo cargaremos y lo utilizaremos,

404
00:26:10,000 --> 00:26:14,000
pero el modelo no sale de ahí arriba, y aprovechamos la infra, por supuesto.

405
00:26:14,000 --> 00:26:18,000
Entonces, ¿qué se hace dentro de esta función?

406
00:26:18,000 --> 00:26:22,000
Bueno, ya lo hemos explicado, ese entrenamiento, división,

407
00:26:22,000 --> 00:26:24,000
esa serie de métricas, etcétera.

408
00:26:24,000 --> 00:26:28,000
Y ahora veámoslo un poco sobre el caso práctico, ¿vale? Así, rápidamente.

409
00:26:28,000 --> 00:26:32,000
¿Vean entrenado un modelo tipo random forest, como he comentado?

410
00:26:32,000 --> 00:26:35,000
Pues con toda esa serie de hiperparámetros que tenemos y establecido,

411
00:26:35,000 --> 00:26:37,000
y este botón lecturing, lo que hace es,

412
00:26:37,000 --> 00:26:40,000
llámese el procedimiento almacenado, ¿qué detallado?

413
00:26:40,000 --> 00:26:43,000
Lo está entrenando ahora mismo ahí arriba, veis que pone running,

414
00:26:43,000 --> 00:26:46,000
y ahí pone, pues, lo que me ha devuelto el modelo tras entrenado.

415
00:26:46,000 --> 00:26:48,000
Esa es que hubo así, esa serie de métricas que nosotros,

416
00:26:48,000 --> 00:26:50,000
los científicos de datos, nos aportan.

417
00:26:50,000 --> 00:26:53,000
¿Vale? Tenemos el modelo, ¿qué nos interesa?

418
00:26:53,000 --> 00:26:55,000
¿No interesa darle práctica a ese modelo, ¿no?

419
00:26:55,000 --> 00:27:00,000
¿Vale? ¿Cómo podemos llamar a ese modelo en base a qué?

420
00:27:00,000 --> 00:27:02,000
Bueno, pues, en base a ese que para llamar a ese modelo,

421
00:27:02,000 --> 00:27:05,000
utilizaríamos una serie de parámetros.

422
00:27:05,000 --> 00:27:08,000
Quiero predecir si esta operación es freudulenta o no,

423
00:27:08,000 --> 00:27:12,000
en base a el emisor, el receptor, la cantidad de dinero, etcétera,

424
00:27:12,000 --> 00:27:14,000
tipo de transacción, ¿vale?

425
00:27:14,000 --> 00:27:20,000
Eso como se hace cerca del dato en este entorno mediante una UDF, ¿vale?

426
00:27:20,000 --> 00:27:23,000
Tenemos el concepto de procedimiento almacenado,

427
00:27:23,000 --> 00:27:26,000
y en este caso, para la inferencia, tenemos una UDF.

428
00:27:26,000 --> 00:27:28,000
Esa UDF, ¿qué es?

429
00:27:28,000 --> 00:27:30,000
Yo me comento a mi compañero Manuel,

430
00:27:30,000 --> 00:27:33,000
igual que tenemos un zoom y le pasamos dos parámetros,

431
00:27:33,000 --> 00:27:35,000
y no devolvería la suma de esos dos parámetros,

432
00:27:35,000 --> 00:27:37,000
o tenemos cualquier otra función,

433
00:27:37,000 --> 00:27:39,000
nosotros hemos creado aquí una propia.

434
00:27:39,000 --> 00:27:41,000
¿Cómo se crea esa propia función?

435
00:27:41,000 --> 00:27:44,000
Pues, bueno, llamaríamos desde el propio SNOPER

436
00:27:44,000 --> 00:27:46,000
a un registro de esa función,

437
00:27:46,000 --> 00:27:49,000
que esa función tiene una serie de lógica dentro,

438
00:27:49,000 --> 00:27:51,000
todo Python, pero mediante el Python Coder,

439
00:27:51,000 --> 00:27:53,000
a nosotros no da igual, está ahí arriba,

440
00:27:53,000 --> 00:27:56,000
sin importar la dependencia de los paquetes, ni nada.

441
00:27:56,000 --> 00:27:58,000
¿Cómo hacemos esto?

442
00:27:58,000 --> 00:28:02,000
Vale, aquí.

443
00:28:02,000 --> 00:28:05,000
En nuestro caso, añadimos los import,

444
00:28:05,000 --> 00:28:07,000
que son los propios fichetitos que nos hacen falta,

445
00:28:07,000 --> 00:28:12,000
aquí los paquetes, aquí los paquetes que necesitemos,

446
00:28:12,000 --> 00:28:15,000
como hemos dicho, a nosotros nos preocupamos,

447
00:28:15,000 --> 00:28:18,000
y hacemos un register de esa función.

448
00:28:18,000 --> 00:28:20,000
¿Cómo nosotros vamos a utilizar luego esa función

449
00:28:20,000 --> 00:28:22,000
con este predictfraududf,

450
00:28:22,000 --> 00:28:25,000
y entre paréntesis le pasaremos todos los argumentos

451
00:28:25,000 --> 00:28:28,000
que necesitemos, y los ejecutamos justo ahí.

452
00:28:28,000 --> 00:28:30,000
Veámoslo en la práctica.

453
00:28:30,000 --> 00:28:32,000
Esto es la práctica como sería,

454
00:28:32,000 --> 00:28:35,000
tendríamos esta información sobre las operaciones

455
00:28:35,000 --> 00:28:38,000
que son fraudulentas, y ahora queremos anexarle

456
00:28:38,000 --> 00:28:41,000
esa columna que nos diga, ¿es fraudulenta o no es fraudulenta?

457
00:28:41,000 --> 00:28:45,000
Bueno, lo estamos llamando.

458
00:28:45,000 --> 00:28:48,000
Y ahora, automáticamente, está llamando al modelo,

459
00:28:48,000 --> 00:28:50,000
está sacando para cada caso,

460
00:28:50,000 --> 00:28:52,000
si es fraudulenta o no es fraudulenta,

461
00:28:52,000 --> 00:28:54,000
y aquí tenemos la salida.

462
00:28:54,000 --> 00:28:57,000
Que lo veáis un poco más aterrizado, ¿vale?

463
00:28:57,000 --> 00:28:59,000
¿Cómo sería esto?

464
00:28:59,000 --> 00:29:02,000
Así, esto es en noflet, estamos dentro del noflet,

465
00:29:02,000 --> 00:29:04,000
y la manera de usarlo es así.

466
00:29:04,000 --> 00:29:08,000
Se le da a este disco, y esta salida del predictfraududf

467
00:29:08,000 --> 00:29:11,000
que recordá, la acabamos de registrar justo ahora,

468
00:29:11,000 --> 00:29:14,000
todo esto lo hemos hecho justo ahora,

469
00:29:14,000 --> 00:29:16,000
registro el modelo, el guardado del modelo,

470
00:29:16,000 --> 00:29:26,000
el predictio, y si ejecutamos esta línea de código...

471
00:29:39,000 --> 00:29:44,000
Aquí tenemos, ahí está, predictio, predictio,

472
00:29:44,000 --> 00:29:47,000
y ya estaría el modelo donde se guarda.

473
00:29:47,000 --> 00:29:51,000
Bueno, es un ejemplo de que el modelo se ha guardado efectivamente,

474
00:29:51,000 --> 00:29:53,000
y está ahí, ¿vale?

475
00:29:53,000 --> 00:29:56,000
Y creo que con esto ya puedo dar por terminado.

476
00:29:56,000 --> 00:29:59,000
Vale, perdona que vamos muy acelerados,

477
00:29:59,000 --> 00:30:03,000
pero es que queremos enseñar las dos partes y venza las charlas.

478
00:30:03,000 --> 00:30:06,000
Se ha entendido, al final, hemos hecho un ejemplo.

479
00:30:06,000 --> 00:30:09,000
Ha usado Streamlis para la interfaz gráfica,

480
00:30:09,000 --> 00:30:11,000
hacer una captura de datos,

481
00:30:11,000 --> 00:30:14,000
y esto simplemente sirve para pintar resultados,

482
00:30:14,000 --> 00:30:17,000
sino que puedes poner formularios y hacer el data entry ahí.

483
00:30:17,000 --> 00:30:20,000
Con eso, el parámetro hemos llamado un procedimiento almacenado

484
00:30:20,000 --> 00:30:24,000
que dentro del noflet ha ejecutado un entrenamiento del modelo,

485
00:30:24,000 --> 00:30:27,000
y el modelo, la salida que es un binario, lo ha guardado

486
00:30:27,000 --> 00:30:29,000
en un área dentro del noflet.

487
00:30:29,000 --> 00:30:32,000
Y luego ha hecho una función que va, es capaz de coger ese modelo,

488
00:30:32,000 --> 00:30:35,000
cargarlo, y sobre eso, inferir, dado un data set,

489
00:30:35,000 --> 00:30:38,000
y ponerle una columna, hacer una columna que calcula 0 o 1.

490
00:30:38,000 --> 00:30:42,000
¿Qué es fraudulento? ¿O no? Toda la lógica, todo el cómputo,

491
00:30:42,000 --> 00:30:45,000
se ha hecho en el noflet.

492
00:30:45,000 --> 00:30:48,000
Procedimiento almacenado para, digamos, una función pesada

493
00:30:48,000 --> 00:30:51,000
que está guardada, que se ha registrado previamente en Python,

494
00:30:51,000 --> 00:30:53,000
todo lo del ejemplo está hecho en Python,

495
00:30:53,000 --> 00:30:55,000
podría ser en otras tecnologías también,

496
00:30:55,000 --> 00:30:58,000
y luego la inferencia, una UDF para que en ese QL

497
00:30:58,000 --> 00:31:00,000
tú puedas usarlo como si fuese ya un dato

498
00:31:00,000 --> 00:31:03,000
que está calculado en tu modelo, pero no está en tu tabla,

499
00:31:03,000 --> 00:31:05,000
no está en tu modelo físico, se está calculando al vuelo

500
00:31:05,000 --> 00:31:07,000
usando un modelo preestivo, ¿se entiende?

501
00:31:07,000 --> 00:31:12,000
Y usando Strilli para tanto, digamos, el data entry

502
00:31:12,000 --> 00:31:15,000
de los parámetros de lo que tú has invocado a la aplicación

503
00:31:15,000 --> 00:31:17,000
como la salida final resultante.

504
00:31:17,000 --> 00:31:19,000
¿Vale? Y esto era la guinda para el final,

505
00:31:19,000 --> 00:31:22,000
y no sabía si nos daba tiempo, pero os lo cuento en dos minutos

506
00:31:22,000 --> 00:31:24,000
de lo que quiere hacer el noflet.

507
00:31:24,000 --> 00:31:26,000
El noflet ya no quiere ser una plataforma,

508
00:31:26,000 --> 00:31:29,000
una base de datos relacional, semiestructurado,

509
00:31:29,000 --> 00:31:33,000
y datos noestructurados, quiere ser tu motor de cómputo

510
00:31:33,000 --> 00:31:34,000
de cualquier tipo.

511
00:31:34,000 --> 00:31:36,000
Entonces lo que han hecho yo al final,

512
00:31:36,000 --> 00:31:40,000
es que la base de lo que sería los motores de la base de datos

513
00:31:40,000 --> 00:31:44,000
te ofrecen, capaz hacia arriba, donde tenéis todas las librerías

514
00:31:44,000 --> 00:31:48,000
de Anaconda, donde tenéis las librerías de NoPark,

515
00:31:48,000 --> 00:31:50,000
tenéis la capacidad de trabajar con DataFrame

516
00:31:50,000 --> 00:31:54,000
igual que en Spark, tenéis Strilli como un servicio ya dentro

517
00:31:54,000 --> 00:31:56,000
de NoFlet para que podáis hacer esas aplicaciones

518
00:31:56,000 --> 00:31:58,000
sin tener que estar montando infraestructura por otro sitio.

519
00:31:58,000 --> 00:32:00,000
Lo único de la dependencia que tiene algo de fuera

520
00:32:00,000 --> 00:32:03,000
es vuestro Isha, obviamente ya en NoFlet

521
00:32:03,000 --> 00:32:07,000
el repo, pero quitando eso lo podría hacer todo dentro.

522
00:32:07,000 --> 00:32:10,000
Y al final la idea sería que deployáis aplicaciones

523
00:32:10,000 --> 00:32:12,000
completas dentro de NoFlet, es decir,

524
00:32:12,000 --> 00:32:14,000
que el propio backend de vuestra aplicación

525
00:32:14,000 --> 00:32:18,000
esté dentro de la propia plataforma de NoFlet.

526
00:32:18,000 --> 00:32:21,000
Lo único que vaya a tener un cliente que no hace nada,

527
00:32:21,000 --> 00:32:25,000
todo se ejecuta ahí, tanto la generación del front

528
00:32:25,000 --> 00:32:28,000
como el backend, un servicio completo de la plataforma.

529
00:32:28,000 --> 00:32:31,000
Que esto tenga una tracción en el mercado de la gente

530
00:32:31,000 --> 00:32:34,000
que lo haga así, lo veremos, esto es muy nuevo.

531
00:32:34,000 --> 00:32:36,000
De hecho, esto está todavía en beta,

532
00:32:36,000 --> 00:32:39,000
la parte de la aplicación en nativa.

533
00:32:39,000 --> 00:32:43,000
Y ya está, ahora sí disculpas de nuevo

534
00:32:43,000 --> 00:32:46,000
por lo atropellado, pero dudas, preguntas

535
00:32:46,000 --> 00:32:48,000
y que nos tenéis a vuestra disposición

536
00:32:48,000 --> 00:32:50,000
para enseñar el código para lo que queráis,

537
00:32:50,000 --> 00:32:52,000
y si queréis conocer más.

538
00:32:52,000 --> 00:32:59,000
Sí, ¿no?

539
00:32:59,000 --> 00:33:04,000
Hola, hacemos fuera como queráis, ¿sí?

540
00:33:04,000 --> 00:33:08,000
Sí.

541
00:33:08,000 --> 00:33:11,000
No, puede preparar.

542
00:33:11,000 --> 00:33:26,000
Para nosotros lo encantamos.

543
00:33:26,000 --> 00:33:28,000
Nosotros hemos encantado de quedar, ¿no?

544
00:33:28,000 --> 00:33:30,000
En el que le interese.

545
00:33:30,000 --> 00:33:33,000
Sí.

546
00:33:33,000 --> 00:33:48,000
A ver, esto es muy nuevo, la parte de NOPAR, ¿vale?

547
00:33:48,000 --> 00:33:51,000
Proyectos reales grandes en productivo están empezando

548
00:33:51,000 --> 00:33:53,000
a la gente a subirse y eso en Estados Unidos.

549
00:33:53,000 --> 00:33:55,000
Aquí en España tenemos un retraso de 2, 3 años

550
00:33:55,000 --> 00:33:57,000
respecto a la adopción de estas plataformas.

551
00:33:57,000 --> 00:33:59,000
En Cívica estamos empezando a hacer proyectos

552
00:33:59,000 --> 00:34:02,000
de Ley House sobre el NoFly ahora,

553
00:34:02,000 --> 00:34:05,000
si ahora es cuando están empezando a subir sus datos

554
00:34:05,000 --> 00:34:08,000
arriba y empezar a montar los modelos

555
00:34:08,000 --> 00:34:10,000
y empezar a hacer sus pinitos.

556
00:34:10,000 --> 00:34:12,000
Aquí en España estos casos de éxito grandes

557
00:34:12,000 --> 00:34:14,000
puestos en productivo no te van a encontrar,

558
00:34:14,000 --> 00:34:16,000
si encuentras uno, estarán empezando.

559
00:34:16,000 --> 00:34:18,000
Y los que están empezando,

560
00:34:18,000 --> 00:34:20,000
muchos de ellos lo estamos haciendo nosotros,

561
00:34:20,000 --> 00:34:22,000
entonces no es algo aquí más duro

562
00:34:22,000 --> 00:34:24,000
que te pueda ir a buscar casos de éxito.

563
00:34:24,000 --> 00:34:26,000
Entonces esto lo estamos contando más en perspectiva, ¿no?

564
00:34:26,000 --> 00:34:28,000
Del cambio de paradigma de mucha gente duda.

565
00:34:28,000 --> 00:34:30,000
Pongo una NOFLY, un bicuerio, lo que sea,

566
00:34:30,000 --> 00:34:35,000
y un Databricks aparte o me vengo a la misma plataforma.

567
00:34:35,000 --> 00:34:38,000
Nuestra recomendación como arquitectos cuando vamos a cliente

568
00:34:38,000 --> 00:34:41,000
monta el NoFly para todo tu Ley House

569
00:34:41,000 --> 00:34:44,000
y por ahora la parte de analítica avanzada en Databricks.

570
00:34:44,000 --> 00:34:47,000
Porque lo de que hayan copiado Spark

571
00:34:47,000 --> 00:34:50,000
pero no sea compatible Spark, eso tiene mucho.

572
00:34:50,000 --> 00:34:52,000
Pero todo tu código Spark,

573
00:34:52,000 --> 00:34:55,000
si luego ese fork que han hecho tira para otro lado,

574
00:34:55,000 --> 00:34:56,000
¿qué pasa?

575
00:34:56,000 --> 00:34:58,000
Todos tus desarrollos, todo tu Legacy, tienes que portarlo

576
00:34:58,000 --> 00:35:01,000
y te hace un vendor locking brutal con el NoFly.

577
00:35:01,000 --> 00:35:03,000
Eso a mí personalmente no me gusta.

578
00:35:03,000 --> 00:35:06,000
Pero esto es si me voy contigo y lo meto todo ahí,

579
00:35:06,000 --> 00:35:09,000
tengo una arquitectura súper sencilla

580
00:35:09,000 --> 00:35:11,000
y la Áctica escala todo es que tiene mucho potencial.

581
00:35:11,000 --> 00:35:13,000
Pero estás pagando un precio de que te estás casando

582
00:35:13,000 --> 00:35:16,000
100% con la tecnología propietaria.

583
00:35:16,000 --> 00:35:18,000
Entonces, pero si tu pregunta es,

584
00:35:18,000 --> 00:35:22,000
¿caso real en producción de que den que esto pueda ir?

585
00:35:22,000 --> 00:35:24,000
Ver que un éxito, esto en concreto

586
00:35:24,000 --> 00:35:26,000
y las aplicaciones nativas

587
00:35:26,000 --> 00:35:28,000
también empezarán a desplogar poco a poco en los próximos años.

588
00:35:28,000 --> 00:35:30,000
Fuera de España sí, hay gente que está montando

589
00:35:30,000 --> 00:35:33,000
arquitectura unificada solo con el NoFly, con todo.

590
00:35:33,000 --> 00:35:35,000
Si hay.

591
00:35:35,000 --> 00:35:57,000
Todo lo que me está dando es un caso de STL,

592
00:35:57,000 --> 00:36:00,000
y tu podes hacer tu join,

593
00:36:00,000 --> 00:36:02,000
todos tus casos, tus fiestas,

594
00:36:02,000 --> 00:36:05,000
y tu me lo entendí, que a partir de 6 y pronto,

595
00:36:05,000 --> 00:36:07,000
que eso a final ahí detrás,

596
00:36:07,000 --> 00:36:09,000
cuando tú haces un piloto de 5.filters,

597
00:36:09,000 --> 00:36:12,000
un punto web, un punto del falto,

598
00:36:12,000 --> 00:36:14,000
todo se puede ver, no da tiempo,

599
00:36:14,000 --> 00:36:16,000
pero básicamente lo cambia,

600
00:36:16,000 --> 00:36:18,000
de otra forma un código de secuero y de uso.

601
00:36:18,000 --> 00:36:21,000
Entonces, el potencial que tiene es brutal,

602
00:36:21,000 --> 00:36:23,000
es brutal desde su punto de vista.

603
00:36:23,000 --> 00:36:26,000
También, bueno, yo creo que se escuchan

604
00:36:26,000 --> 00:36:33,000
esto porque se no.

605
00:36:33,000 --> 00:36:36,000
También que esto sean opciones,

606
00:36:36,000 --> 00:36:38,000
no significa que esta sea magia,

607
00:36:38,000 --> 00:36:40,000
ni la única solución.

608
00:36:40,000 --> 00:36:42,000
Por ejemplo, nosotros para Data Engineering,

609
00:36:42,000 --> 00:36:44,000
recomendamos otras soluciones más tipo de SQL,

610
00:36:44,000 --> 00:36:46,000
como DBT, por ejemplo,

611
00:36:46,000 --> 00:36:48,000
no haga el Data Engineering con no par,

612
00:36:48,000 --> 00:36:50,000
ni siquiera con Data Bricks,

613
00:36:50,000 --> 00:36:52,000
porque los otros son como vistas de SQL,

614
00:36:52,000 --> 00:36:54,000
mucho más estándar y tiene el linaje garantizado

615
00:36:54,000 --> 00:36:56,000
y todo es push down,

616
00:36:56,000 --> 00:36:58,000
y aprovecha todas las capacidades de la herramienta.

617
00:36:58,000 --> 00:37:00,000
Si tienes código en Spark,

618
00:37:00,000 --> 00:37:02,000
lo cuesta la danza y la implementa, no,

619
00:37:02,000 --> 00:37:04,000
porque es la misma API que tiene.

620
00:37:04,000 --> 00:37:06,000
¿La misma API que tiene en un Data Fingerpark?

621
00:37:06,000 --> 00:37:08,000
Es la misma aquí.

622
00:37:08,000 --> 00:37:10,000
Te da muchas ventajas,

623
00:37:10,000 --> 00:37:12,000
pero a nivel de arquitectura hay que pensar bien

624
00:37:12,000 --> 00:37:14,000
los problemas contra.

625
00:37:16,000 --> 00:37:18,000
Bueno, el Spark al final también

626
00:37:18,000 --> 00:37:20,000
es el más adoptado dentro de Spark,

627
00:37:20,000 --> 00:37:24,000
pero bueno...

628
00:37:24,000 --> 00:37:26,000
al final es la API, ya está.

629
00:37:26,000 --> 00:37:28,000
Pero bueno, la idea era que lo conociera

630
00:37:28,000 --> 00:37:30,000
y que el que quiera, pues que investigue un poco

631
00:37:30,000 --> 00:37:32,000
y pueda ir más allá.

632
00:37:32,000 --> 00:37:34,000
Es igual.

633
00:37:46,000 --> 00:37:48,000
Puedes trasladar básicamente tu código,

634
00:37:48,000 --> 00:37:50,000
casi exactamente el mismo, casi el mismo.

635
00:37:50,000 --> 00:37:52,000
Para desarrollar un local,

636
00:37:52,000 --> 00:37:54,000
para desarrollar un local,

637
00:37:54,000 --> 00:37:56,000
te extraa la librería de no-park

638
00:37:56,000 --> 00:37:58,000
y cuál te platican, lo digas automáticamente.

639
00:37:58,000 --> 00:38:00,000
En vez de hacer un import de Spark,

640
00:38:00,000 --> 00:38:02,000
import de no-park,

641
00:38:02,000 --> 00:38:04,000
pero el resto del código es casi igual.

642
00:38:04,000 --> 00:38:06,000
¿Pero necesitas la cuarenta y el tres?

643
00:38:06,000 --> 00:38:08,000
Necesitas la cuarenta y el tres.

644
00:38:08,000 --> 00:38:18,000
En este caso, pero no Spark.Punk, es lo único que ve.

645
00:38:38,000 --> 00:38:40,000
Esto me quedan los de los mis jefes.

646
00:38:40,000 --> 00:38:42,000
Es que es prespor qué

647
00:38:42,000 --> 00:38:44,000
tantas compañías

648
00:38:44,000 --> 00:38:46,000
utilizan el no-flash

649
00:38:46,000 --> 00:38:48,000
para ir a ingeniería y integrar

650
00:38:48,000 --> 00:38:50,000
sino que los precios estarán

651
00:38:50,000 --> 00:38:52,000
en el primer momento de la generación

652
00:38:52,000 --> 00:38:54,000
de los años 20.

653
00:38:54,000 --> 00:38:56,000
Bueno, a ver, los modelos de licenciamiento

654
00:38:56,000 --> 00:38:58,000
hay que entender todo lo que te da.

655
00:38:58,000 --> 00:39:00,000
Es decir, para poder comparar precios

656
00:39:00,000 --> 00:39:02,000
de no-flash con otra cosa,

657
00:39:02,000 --> 00:39:04,000
no puedes comparar el precio con un...

658
00:39:04,000 --> 00:39:06,000
no sé, con una teradata,

659
00:39:06,000 --> 00:39:08,000
con una capacidad de que si hace el TCO

660
00:39:08,000 --> 00:39:10,000
el coste total de lo que tiene y lo que paga

661
00:39:10,000 --> 00:39:12,000
y no es fácil

662
00:39:12,000 --> 00:39:14,000
hacer esos casos de estudio,

663
00:39:14,000 --> 00:39:16,000
no sencillo, pero es que te da muchas cosas.

664
00:39:16,000 --> 00:39:18,000
Primero, tú solamente pagas

665
00:39:18,000 --> 00:39:20,000
por cuánto tiempo tienes levantado

666
00:39:20,000 --> 00:39:22,000
los virtual warehouses, que serían tus servidores.

667
00:39:22,000 --> 00:39:24,000
Esos virtual warehouses son escalables.

668
00:39:24,000 --> 00:39:26,000
Son como tallas de camisetas.

669
00:39:26,000 --> 00:39:28,000
Desde un XS, que es más pequeñito,

670
00:39:28,000 --> 00:39:30,000
un XS que sería el doble,

671
00:39:30,000 --> 00:39:32,000
un M que sería 4, cada vez el doble,

672
00:39:32,000 --> 00:39:34,000
tiene elasticidad vertical, horizontal,

673
00:39:34,000 --> 00:39:36,000
tiene ejecutar cargas de tipo data engineering,

674
00:39:36,000 --> 00:39:38,000
tiene no-fash, todo eso,

675
00:39:38,000 --> 00:39:40,000
lo paga en base a un control de tiempo

676
00:39:40,000 --> 00:39:42,000
de si yo el warehouse está levantado

677
00:39:42,000 --> 00:39:44,000
pago, pago por uso, pago por segundo

678
00:39:44,000 --> 00:39:46,000
y si está bajado no pago nada.

679
00:39:46,000 --> 00:39:48,000
Pero tengo toda esa infra, sin haber tenido

680
00:39:48,000 --> 00:39:50,000
que hacer una inversión, cuánto en un banco.

681
00:39:50,000 --> 00:39:52,000
Voy a comprar un teradata, ¿cómo de grande?

682
00:39:52,000 --> 00:39:54,000
Si no lo uso, estoy perdiendo dinero

683
00:39:54,000 --> 00:39:56,000
porque he comprado todo esto y si

684
00:39:56,000 --> 00:39:58,000
me queda corto, no puedo...

685
00:39:58,000 --> 00:40:00,000
Paga lo que necesitan cada momento.

686
00:40:00,000 --> 00:40:02,000
El caso más típico

687
00:40:02,000 --> 00:40:04,000
es cuando tú tienes una función,

688
00:40:04,000 --> 00:40:06,000
un modelo, entrenar un modelo que te tardase

689
00:40:06,000 --> 00:40:08,000
10 horas, le puedes subir una talla

690
00:40:08,000 --> 00:40:10,000
de una XS a una ALE

691
00:40:10,000 --> 00:40:12,000
y hacerlo en 50 minutos y va a pagar

692
00:40:12,000 --> 00:40:14,000
lo mismo porque como multiplica coste

693
00:40:14,000 --> 00:40:16,000
por tiempo, lo mismo va a pagar

694
00:40:16,000 --> 00:40:18,000
en un minuto en una ALE

695
00:40:18,000 --> 00:40:20,000
10 horas en una XS, cuánto hacer.

696
00:40:20,000 --> 00:40:22,000
Cuando dime al día del mes,

697
00:40:22,000 --> 00:40:24,000
quizás tiene que hacer una carga brutal

698
00:40:24,000 --> 00:40:26,000
de un montón de tablas.

699
00:40:26,000 --> 00:40:28,000
Ahí también, ahí quizás puede gestionar

700
00:40:28,000 --> 00:40:30,000
concurrencia, concurrencia en el acceso

701
00:40:30,000 --> 00:40:32,000
que puedes hacer automáticamente

702
00:40:32,000 --> 00:40:34,000
de forma elástica cláster para atender la demanda,

703
00:40:34,000 --> 00:40:36,000
puedes cumplir mejor con los SLEA, todo eso

704
00:40:36,000 --> 00:40:38,000
por le precio.

705
00:40:38,000 --> 00:40:40,000
Es decir, ya tú tener una infraestructura simple,

706
00:40:40,000 --> 00:40:42,000
no tener un modelo de seguridad en el NoFle

707
00:40:42,000 --> 00:40:44,000
y otro en DataBricks o en un DataLeg aparte

708
00:40:44,000 --> 00:40:46,000
sino que hacer una sola vez la seguridad

709
00:40:46,000 --> 00:40:48,000
y que te sirva para todos tus datos de tu compañía.

710
00:40:48,000 --> 00:40:50,000
¿Cuánto vale eso?

711
00:40:50,000 --> 00:40:52,000
Entonces, al final...

712
00:40:52,000 --> 00:40:54,000
No es tan sencillo, es verdad que hay que tener cuidado

713
00:40:54,000 --> 00:40:56,000
con el cómputo porque al final las facturas

714
00:40:56,000 --> 00:40:58,000
no son baratas, pero si lo gestionas bien

715
00:40:58,000 --> 00:41:00,000
no es más caro, no es más barato.

716
00:41:28,000 --> 00:41:30,000
Sí, tiene un montón de cosas que no...

717
00:41:30,000 --> 00:41:32,000
Sería una charla de 4 horas

718
00:41:32,000 --> 00:41:34,000
contaros todo lo que tiene NoFle.

719
00:41:48,000 --> 00:41:50,000
Estrinlead...

720
00:41:50,000 --> 00:41:52,000
No, no tiene nada que ver.

721
00:41:52,000 --> 00:41:54,000
Es decir, cuando tú haces tu aplicación

722
00:41:54,000 --> 00:41:56,000
la puedes hacer desde que la despliegas

723
00:41:56,000 --> 00:41:58,000
o limitar qué usuario pueden verla

724
00:41:58,000 --> 00:42:00,000
y esos usuarios van a ser usuarios

725
00:42:00,000 --> 00:42:02,000
del servicio de Strinlead.

726
00:42:02,000 --> 00:42:04,000
De hecho, eso es independiente de NoFle.

727
00:42:04,000 --> 00:42:06,000
Estrinlead, tú lo puedes usar y no tiene nada que ver

728
00:42:06,000 --> 00:42:08,000
con el NoFle.

729
00:42:18,000 --> 00:42:20,000
Ese modelo de seguridad es independiente

730
00:42:20,000 --> 00:42:26,000
del modelo de usuario y roles de NoFle.

731
00:42:30,000 --> 00:42:33,000
Lo han comprado para tener ellos la capacidad de hacer.

732
00:42:33,000 --> 00:42:35,000
Aplicaciones rápidas sin que tú tengas que ir

733
00:42:35,000 --> 00:42:37,000
de otra empresa a comprarlo.

734
00:42:41,000 --> 00:42:43,000
Data Abril es igual.

735
00:42:43,000 --> 00:42:45,000
Del Taléis con Data Abril quiere quedarse

736
00:42:45,000 --> 00:42:47,000
con todo tu cómputo, con todo tu dato.

737
00:42:47,000 --> 00:42:49,000
Todo.

738
00:42:49,000 --> 00:42:51,000
Son aproximaciones muy fáciles, sencillas,

739
00:42:51,000 --> 00:42:53,000
poca administración.

740
00:42:53,000 --> 00:42:55,000
Te lo hago muy fácil, pero bien para acá

741
00:42:55,000 --> 00:42:57,000
que te tengo completamente pillado.

742
00:42:57,000 --> 00:42:59,000
Vale, así.

743
00:42:59,000 --> 00:43:01,000
Exactamente.

744
00:43:01,000 --> 00:43:03,000
¿Estamos?

745
00:43:03,000 --> 00:43:20,000
Vale, gracias a vosotros.

