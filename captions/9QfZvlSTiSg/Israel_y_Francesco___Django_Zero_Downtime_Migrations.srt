1
00:00:00,000 --> 00:00:19,280
Welcome Francesco and Israel.

2
00:00:19,280 --> 00:00:23,600
We talk the migration without downtime.

3
00:00:23,600 --> 00:00:26,160
So hello.

4
00:00:26,160 --> 00:00:27,160
I'm Francesco.

5
00:00:27,160 --> 00:00:30,640
I work for Travel Perk and is one of my colleagues.

6
00:00:30,640 --> 00:00:34,200
We both work as software engineers.

7
00:00:34,200 --> 00:00:37,400
And let's deep dive in the topic.

8
00:00:37,400 --> 00:00:39,760
So what we do, what our company does,

9
00:00:39,760 --> 00:00:45,680
is basically provide a solution to buy, to book,

10
00:00:45,680 --> 00:00:47,920
and manage the business travel as a whole thing.

11
00:00:47,920 --> 00:00:53,480
So whatever is related from the booking to the management

12
00:00:53,480 --> 00:00:55,000
and to the post booking and everything

13
00:00:55,000 --> 00:00:57,760
is can be done in the platform.

14
00:00:57,760 --> 00:01:01,280
So what we offer to be different than others

15
00:01:01,280 --> 00:01:03,640
is that we have a huge inventory.

16
00:01:03,640 --> 00:01:06,960
We have unified payment and invoicing system.

17
00:01:06,960 --> 00:01:12,040
We also offer many options to upload the users in the platform

18
00:01:12,040 --> 00:01:14,600
and sync them in real time.

19
00:01:14,600 --> 00:01:17,480
Something like bamboo HR, if you know it.

20
00:01:17,480 --> 00:01:19,840
Something like SQL Scheme is another protocol

21
00:01:19,840 --> 00:01:22,680
that we use to sync users.

22
00:01:22,680 --> 00:01:25,080
But those are a little bit technical.

23
00:01:25,080 --> 00:01:26,520
Also from a business point of view,

24
00:01:26,520 --> 00:01:30,000
we offer the possibility to define different policies

25
00:01:30,000 --> 00:01:31,960
and different approval processes.

26
00:01:31,960 --> 00:01:33,560
Because in some companies, there is

27
00:01:33,560 --> 00:01:38,720
the need to control what the employees are booking.

28
00:01:38,720 --> 00:01:43,160
Also reporting, cost management, and carbon

29
00:01:43,160 --> 00:01:46,280
offsetting, which is a huge topic for us right now.

30
00:01:46,280 --> 00:01:47,960
So what we offer is the possibility

31
00:01:47,960 --> 00:01:52,400
to contribute in being more green, let's say.

32
00:01:52,400 --> 00:01:55,560
Also, we have different pricing levels.

33
00:01:55,560 --> 00:02:00,280
So any company can decide what they need for their business.

34
00:02:00,280 --> 00:02:05,640
And we have an amazing 24-7 customer service.

35
00:02:05,640 --> 00:02:08,240
If I can add something, probably,

36
00:02:08,240 --> 00:02:10,040
since you came here to the conference,

37
00:02:10,040 --> 00:02:12,800
are you out in a company with a lot of people?

38
00:02:12,800 --> 00:02:15,240
You can see the pain that it can be sometimes

39
00:02:15,240 --> 00:02:17,960
for having one central person, like having

40
00:02:17,960 --> 00:02:20,600
to manage all the travel for everyone,

41
00:02:20,600 --> 00:02:24,160
because you need to ask for all the data, the passport,

42
00:02:24,160 --> 00:02:29,000
whatever, everyone has to send the final confirmation

43
00:02:29,000 --> 00:02:30,960
in advance with the codes to everyone.

44
00:02:30,960 --> 00:02:33,640
So one thing that we do in the platform,

45
00:02:33,640 --> 00:02:35,760
which has to do from the business and power,

46
00:02:35,760 --> 00:02:38,960
the travelers to book the travel themselves within a policy.

47
00:02:38,960 --> 00:02:40,880
So if you are an employee in the company,

48
00:02:40,880 --> 00:02:43,960
instead of having to contact the office manager or the travel

49
00:02:43,960 --> 00:02:46,480
manager of the company, you can book your own travel

50
00:02:46,480 --> 00:02:48,520
using the payment methods of the company that

51
00:02:48,520 --> 00:02:51,440
give you a bank transfer or Sepadabit.

52
00:02:51,440 --> 00:02:54,080
So it's much easier for everyone in the company

53
00:02:54,080 --> 00:02:57,640
instead of having to have one central point, which

54
00:02:57,640 --> 00:02:59,120
is a lot when the company speaks.

55
00:02:59,120 --> 00:03:05,080
So for me, it's one of the big value proposals for companies.

56
00:03:05,080 --> 00:03:08,280
So OK, what we are talking today is

57
00:03:08,280 --> 00:03:12,720
about doing modifications and changes to the database

58
00:03:12,720 --> 00:03:14,840
without causing a disruption of the service.

59
00:03:14,840 --> 00:03:18,880
Because as you see, as you saw before, we are providing the solution

60
00:03:18,880 --> 00:03:21,360
as a service online.

61
00:03:21,360 --> 00:03:24,400
So what we want to avoid is for our clients

62
00:03:24,400 --> 00:03:27,240
to experience like disruption in their service

63
00:03:27,240 --> 00:03:30,960
once we update the database.

64
00:03:30,960 --> 00:03:35,400
But we are going a little bit down now for some basics.

65
00:03:35,400 --> 00:03:37,920
And we will talk about models in general.

66
00:03:37,920 --> 00:03:39,520
We will talk about migration.

67
00:03:39,520 --> 00:03:42,640
And then we'll explain the strategy

68
00:03:42,640 --> 00:03:46,360
we are using to avoid the actual downtime.

69
00:03:46,360 --> 00:03:48,560
So what are migrations?

70
00:03:48,560 --> 00:03:51,440
First, let's talk about the models.

71
00:03:51,440 --> 00:03:53,560
It's a funny one.

72
00:03:53,560 --> 00:03:57,240
So the models are basically what Django provides us

73
00:03:57,240 --> 00:03:59,440
to model the schema in the database.

74
00:03:59,440 --> 00:04:02,040
So we have in the code the representation

75
00:04:02,040 --> 00:04:05,800
that we want to give to the tables.

76
00:04:05,800 --> 00:04:08,240
Let's say you can define the same constraints

77
00:04:08,240 --> 00:04:12,080
and the same options that you can define at the database level

78
00:04:12,080 --> 00:04:14,520
but in Python, let's say.

79
00:04:14,520 --> 00:04:17,680
So what you see there is like a basic example of a model

80
00:04:17,680 --> 00:04:19,840
that can have two fields.

81
00:04:19,840 --> 00:04:20,920
One is question text.

82
00:04:20,920 --> 00:04:22,160
One is pub date.

83
00:04:22,160 --> 00:04:28,880
And how it is mapped into the SQL DDL.

84
00:04:28,880 --> 00:04:32,560
Which is you can see that in the model, we have two fields.

85
00:04:32,560 --> 00:04:34,120
And in the table, we have three.

86
00:04:34,120 --> 00:04:42,440
Because Django by default provides the ID as an auto increment.

87
00:04:42,440 --> 00:04:46,040
But let's go to the migrations now.

88
00:04:46,040 --> 00:04:47,600
So what is a migration?

89
00:04:47,600 --> 00:04:51,480
Migration is what Django provides us to actually apply

90
00:04:51,480 --> 00:04:53,760
modifications to the database.

91
00:04:53,760 --> 00:04:55,000
So what we want, for example, is

92
00:04:55,000 --> 00:04:57,800
adding a field, deleting a field, adding a default value

93
00:04:57,800 --> 00:05:01,560
for a column to the database.

94
00:05:01,560 --> 00:05:06,080
Whatever is impacting the schema level, the changes

95
00:05:06,080 --> 00:05:10,320
that we do at the model is done via migration with Django.

96
00:05:13,080 --> 00:05:17,160
So this is just a simple representation of what happens.

97
00:05:17,160 --> 00:05:22,520
So when we want to change the model A to A1, what Django does

98
00:05:22,520 --> 00:05:26,160
is what we need to do is actually create the migration.

99
00:05:26,160 --> 00:05:29,240
It's done by this command called make migration.

100
00:05:29,240 --> 00:05:31,720
And it generates basically a meta language that

101
00:05:31,720 --> 00:05:37,680
contains a SQL that is actually applied when we go to production

102
00:05:37,680 --> 00:05:40,600
to actually modify the table.

103
00:05:40,600 --> 00:05:43,160
And in the migration file, you can review the changes

104
00:05:43,160 --> 00:05:45,880
if you want to take a look to everything.

105
00:05:45,880 --> 00:05:47,840
So let's say it's split into phases.

106
00:05:47,840 --> 00:05:51,200
First, we create the first Django creates this migration

107
00:05:51,200 --> 00:05:53,280
file called migration file.

108
00:05:53,280 --> 00:05:56,720
And then when going in production,

109
00:05:56,720 --> 00:06:00,800
you need to actually apply the migration.

110
00:06:00,800 --> 00:06:02,200
This is an example.

111
00:06:02,200 --> 00:06:06,040
As you see, so all the migrations extend

112
00:06:06,040 --> 00:06:10,560
from migrations.migration, which is the Django class for it.

113
00:06:10,560 --> 00:06:14,720
The dependencies are explaining what

114
00:06:14,720 --> 00:06:17,120
are the previous migrations that need to be run

115
00:06:17,120 --> 00:06:19,440
before running this one.

116
00:06:19,440 --> 00:06:21,680
And the operation is what actually

117
00:06:21,680 --> 00:06:23,000
was going on with the migration.

118
00:06:23,000 --> 00:06:28,000
In this case, there is a model tree

119
00:06:28,000 --> 00:06:31,440
that gets deleted so the table gets eliminated.

120
00:06:31,440 --> 00:06:34,360
And the migration is adding the rating

121
00:06:34,360 --> 00:06:37,040
field to the author model.

122
00:06:37,040 --> 00:06:38,080
There is an integer.

123
00:06:38,080 --> 00:06:42,720
So that's roughly this simple migration what it's doing.

124
00:06:45,360 --> 00:06:49,560
This is a graph that explains the flow that

125
00:06:49,560 --> 00:06:50,880
happened with the migration.

126
00:06:50,880 --> 00:06:53,080
So as you can see, it kind of looks

127
00:06:53,080 --> 00:06:55,160
similar like the Gitflow.

128
00:06:55,160 --> 00:06:58,200
Because what it's saying is starting

129
00:06:58,200 --> 00:07:05,120
for the migration 1A to B3C, there is a branching.

130
00:07:05,120 --> 00:07:08,760
Because the 4D one and the 4D are actually

131
00:07:08,760 --> 00:07:11,200
depending only on the 3C.

132
00:07:11,200 --> 00:07:13,680
So they can go in parallel.

133
00:07:13,680 --> 00:07:15,960
And then once everything gets merged,

134
00:07:15,960 --> 00:07:18,600
let's say after a few other migrations,

135
00:07:18,600 --> 00:07:21,040
everything goes linear again.

136
00:07:21,040 --> 00:07:25,680
And the representation that you see on the right

137
00:07:25,680 --> 00:07:28,160
after the command show migration is basically

138
00:07:28,160 --> 00:07:31,440
show migration is the command that shows all the migrations

139
00:07:31,440 --> 00:07:34,760
that are applied to the current database level.

140
00:07:34,760 --> 00:07:38,360
So in that case, when you run show migration,

141
00:07:38,360 --> 00:07:42,560
if you see what's shown there, so 01 initial 02 auto,

142
00:07:42,560 --> 00:07:45,520
it means that the one with the X has been applied already

143
00:07:45,520 --> 00:07:46,920
on the database.

144
00:07:46,920 --> 00:07:49,520
The second one is not yet applied.

145
00:07:49,520 --> 00:07:54,040
So you need to run a specific command to do it, as I said

146
00:07:54,040 --> 00:07:56,400
before.

147
00:07:56,400 --> 00:07:59,120
Let's go to the next.

148
00:07:59,120 --> 00:08:01,000
This is just a repetition.

149
00:08:01,000 --> 00:08:01,480
Sorry.

150
00:08:04,400 --> 00:08:06,920
This is just to wrap up a little bit what I said before.

151
00:08:06,920 --> 00:08:10,200
So the workflow that happens when we

152
00:08:10,200 --> 00:08:14,280
need to execute a migration, it's just

153
00:08:14,280 --> 00:08:17,080
running the command that is listed there,

154
00:08:17,080 --> 00:08:20,520
that is the migrate command.

155
00:08:20,520 --> 00:08:24,000
And the running migration report is basically

156
00:08:24,000 --> 00:08:25,160
what's going on in production.

157
00:08:25,160 --> 00:08:27,000
If you see the logs, you will see this,

158
00:08:27,000 --> 00:08:29,240
because every migration that gets applied

159
00:08:29,240 --> 00:08:33,000
is logged with an OK or KO in case it's not going well.

160
00:08:36,880 --> 00:08:38,920
So this is just a recap of the commands that

161
00:08:38,920 --> 00:08:41,880
can be run to end of migration.

162
00:08:41,880 --> 00:08:45,400
The migrate, as I said before, is the way we have to actually

163
00:08:45,400 --> 00:08:47,680
apply the migrations in the database.

164
00:08:47,680 --> 00:08:51,600
Make migration is to create the migration file from the change

165
00:08:51,600 --> 00:08:52,960
to the model that we're doing.

166
00:08:52,960 --> 00:08:54,800
So when we change the model, we always

167
00:08:54,800 --> 00:08:58,120
need to run mic migration to generate the migration file,

168
00:08:58,120 --> 00:09:01,760
so the same change can be applied at the database level.

169
00:09:01,760 --> 00:09:03,160
Because otherwise, there is the possibility

170
00:09:03,160 --> 00:09:05,680
that the model and the database are not aligned,

171
00:09:05,680 --> 00:09:10,320
and this can be quite a big problem.

172
00:09:10,320 --> 00:09:13,600
The SQL migrate is a tool that you

173
00:09:13,600 --> 00:09:17,880
can use to actually inspect the SQL that is generated

174
00:09:17,880 --> 00:09:19,520
from a migration file.

175
00:09:19,520 --> 00:09:22,240
So it's just if you want to be more on control of what's

176
00:09:22,240 --> 00:09:25,040
going on, you can run this command

177
00:09:25,040 --> 00:09:28,800
and you can see what is actually happening at the database

178
00:09:28,800 --> 00:09:29,880
level.

179
00:09:29,880 --> 00:09:31,600
And the show migration, as we showed before,

180
00:09:31,600 --> 00:09:34,640
is just to see which migration has been applied already

181
00:09:34,640 --> 00:09:35,840
and which are not yet.

182
00:09:35,840 --> 00:09:41,840
So now I leave the word to Isra.

183
00:09:41,840 --> 00:09:42,440
OK.

184
00:09:42,440 --> 00:09:45,560
So if you got a bit confused by all what we said,

185
00:09:45,560 --> 00:09:47,560
it was just an introduction.

186
00:09:47,560 --> 00:09:50,880
The purpose of the talk was not to talk about how migrations

187
00:09:50,880 --> 00:09:52,240
work, but to avoid downtime.

188
00:09:52,240 --> 00:09:55,600
It was just a bit of context, so you understand everything.

189
00:09:55,600 --> 00:09:56,760
So don't worry.

190
00:09:56,760 --> 00:09:59,040
Now I'm going to talk, know that we are introduced models

191
00:09:59,040 --> 00:09:59,720
and migrations.

192
00:09:59,720 --> 00:10:02,960
I'm going to talk a bit about the main purpose of the talk,

193
00:10:02,960 --> 00:10:05,880
which is downtime when you're applying migrations

194
00:10:05,880 --> 00:10:09,200
and why they happen and how can we try to avoid them.

195
00:10:09,200 --> 00:10:10,200
OK.

196
00:10:10,200 --> 00:10:14,200
So OK.

197
00:10:14,200 --> 00:10:18,080
What we want to say is why do they happen?

198
00:10:18,080 --> 00:10:22,200
And there are two reasons why they can happen.

199
00:10:22,200 --> 00:10:27,600
The first one is that usually when you're running an application

200
00:10:27,600 --> 00:10:29,160
that you don't want to have downtime,

201
00:10:29,160 --> 00:10:33,400
you need to deploy a new version of the app

202
00:10:33,400 --> 00:10:35,560
while the previous version is running.

203
00:10:35,560 --> 00:10:40,400
So you don't stop the previous version, then apply the migration,

204
00:10:40,400 --> 00:10:43,320
apply the change the database, and start the new one.

205
00:10:43,320 --> 00:10:46,080
Because there can be even a few seconds.

206
00:10:46,080 --> 00:10:48,480
These seconds can mean a lot in certain systems,

207
00:10:48,480 --> 00:10:49,400
so you don't want that.

208
00:10:49,400 --> 00:10:52,400
So what you do, I think I have a graph here.

209
00:10:52,400 --> 00:10:53,200
Yeah.

210
00:10:53,200 --> 00:10:55,720
You deploy the new version of the app

211
00:10:55,720 --> 00:10:57,400
while the previous version is running.

212
00:10:57,400 --> 00:10:59,320
And then this creates an issue.

213
00:10:59,320 --> 00:11:00,320
Why?

214
00:11:00,320 --> 00:11:03,680
Because you can have two versions of the app, the old one,

215
00:11:03,680 --> 00:11:05,920
and the new one with the new models in Python

216
00:11:05,920 --> 00:11:07,520
running at the same time.

217
00:11:07,520 --> 00:11:10,080
But you cannot have two schemas of the database.

218
00:11:10,080 --> 00:11:10,640
I don't know.

219
00:11:10,640 --> 00:11:12,640
Perhaps there are some databases that allow that.

220
00:11:12,640 --> 00:11:14,760
But you cannot have two schemas.

221
00:11:14,760 --> 00:11:18,680
When you run the migration, you apply a change to the schema,

222
00:11:18,680 --> 00:11:20,480
and then it's a different one.

223
00:11:20,480 --> 00:11:23,840
Perhaps you have a field that was nullable before,

224
00:11:23,840 --> 00:11:24,920
and no, it's not nullable.

225
00:11:24,920 --> 00:11:29,880
So it cannot run with both versions at the same time.

226
00:11:29,880 --> 00:11:30,360
OK.

227
00:11:30,360 --> 00:11:34,480
Then you can see the two versions.

228
00:11:34,480 --> 00:11:36,640
At some point, there are two of them running.

229
00:11:36,640 --> 00:11:39,600
But the database schema changes when

230
00:11:39,600 --> 00:11:41,280
you apply the migration.

231
00:11:41,280 --> 00:11:42,520
That is a separate command.

232
00:11:45,840 --> 00:11:50,680
So what happens if you are, for example, deleting a more?

233
00:11:50,680 --> 00:11:51,180
Are you?

234
00:11:51,180 --> 00:11:51,680
Yeah.

235
00:11:51,680 --> 00:11:51,680
OK.

236
00:11:51,680 --> 00:11:53,040
You did it on purpose.

237
00:11:53,040 --> 00:11:55,880
What happens if you are deleting a model, for example,

238
00:11:55,880 --> 00:11:58,920
and that model was in use by the application?

239
00:11:58,920 --> 00:12:02,880
What happens if you change a field or delete a field?

240
00:12:02,880 --> 00:12:04,880
And this field, of course, it was being used.

241
00:12:04,880 --> 00:12:06,000
It cannot be OK.

242
00:12:06,000 --> 00:12:07,080
Or you change attributes.

243
00:12:07,080 --> 00:12:10,080
Like, for example, you make a field not nullable.

244
00:12:10,080 --> 00:12:12,040
And then every time the old app tries

245
00:12:12,040 --> 00:12:14,240
to create that model or change something,

246
00:12:14,240 --> 00:12:17,560
and this is nullable, then OK, then it's going to fail.

247
00:12:17,560 --> 00:12:17,960
OK.

248
00:12:17,960 --> 00:12:20,840
Then in order to avoid that, basically a rule of thumb

249
00:12:20,840 --> 00:12:24,080
is that to have backwards compatibility every time

250
00:12:24,080 --> 00:12:28,280
you make a change, you need to make the new schema compatible

251
00:12:28,280 --> 00:12:29,480
with the old application.

252
00:12:29,480 --> 00:12:32,520
And we will see, I'm trying to introduce the main reasons.

253
00:12:32,520 --> 00:12:34,800
It can have downtime.

254
00:12:34,800 --> 00:12:36,800
And later, under the rules of thumb,

255
00:12:36,800 --> 00:12:41,120
later we will see some examples of the typical operations

256
00:12:41,120 --> 00:12:41,760
that we do.

257
00:12:41,760 --> 00:12:42,760
How can we avoid that?

258
00:12:42,760 --> 00:12:43,160
OK.

259
00:12:43,160 --> 00:12:44,560
This is the main thing to consider.

260
00:12:44,560 --> 00:12:47,560
Whenever you are running this, take this into account.

261
00:12:47,560 --> 00:12:50,600
The new version has to be compatible with the old app.

262
00:12:50,600 --> 00:12:52,160
OK.

263
00:12:52,160 --> 00:12:55,320
And then the second reason, the second main reason

264
00:12:55,320 --> 00:12:58,640
that you can have downtime is the locks in the database.

265
00:12:58,640 --> 00:13:00,560
Basically, whenever you have a data

266
00:13:00,560 --> 00:13:06,160
structure that you need to perform certain operations,

267
00:13:06,160 --> 00:13:10,120
in order to have certain guarantees of the reliability

268
00:13:10,120 --> 00:13:13,680
of the data, that different operations see the same data,

269
00:13:13,680 --> 00:13:17,480
et cetera, et cetera, there are mechanisms called locks

270
00:13:17,480 --> 00:13:20,760
that prevent multiple operations that are not

271
00:13:20,760 --> 00:13:23,480
compatible among them to have these guarantees

272
00:13:23,480 --> 00:13:24,520
run simultaneously.

273
00:13:24,520 --> 00:13:25,880
Because if they run simultaneously,

274
00:13:25,880 --> 00:13:27,040
you can have inconsistent data.

275
00:13:27,040 --> 00:13:29,520
If you are, I don't know, deleting a file at the same time

276
00:13:29,520 --> 00:13:32,000
updating, it doesn't make sense.

277
00:13:32,000 --> 00:13:33,880
Then it doesn't work.

278
00:13:33,880 --> 00:13:36,400
So in order to do that, well, in this case, in our company,

279
00:13:36,400 --> 00:13:37,280
we use Postgres.

280
00:13:37,280 --> 00:13:40,480
I guess that in MySQL, there can be similar things.

281
00:13:40,480 --> 00:13:46,200
But the data system implement mechanism called locks,

282
00:13:46,200 --> 00:13:51,360
where they basically, when there are two operations,

283
00:13:51,360 --> 00:13:54,280
depending on the kind of exclusivity

284
00:13:54,280 --> 00:13:56,640
that they need in the operations, they say, OK,

285
00:13:56,640 --> 00:13:59,920
I lock this, for example, this row or this table,

286
00:13:59,920 --> 00:14:01,920
and nothing can write there, for example.

287
00:14:01,920 --> 00:14:04,680
And until I finish this transaction,

288
00:14:04,680 --> 00:14:06,400
the next operation cannot do anything.

289
00:14:06,400 --> 00:14:09,080
This way, you stop there.

290
00:14:09,080 --> 00:14:10,000
There are my get-on there.

291
00:14:10,000 --> 00:14:13,080
And you know that you are not breaking anything in the data.

292
00:14:13,080 --> 00:14:14,320
Imagine it's a bank.

293
00:14:14,320 --> 00:14:17,080
And you do multiple, imagine you do double transactions

294
00:14:17,080 --> 00:14:17,960
or stuff like that.

295
00:14:17,960 --> 00:14:20,040
So you want to be able to lock stuff.

296
00:14:20,040 --> 00:14:22,880
So even things could happen concurrently.

297
00:14:22,880 --> 00:14:27,040
You don't do that in order to avoid mistakes.

298
00:14:27,040 --> 00:14:28,040
I said a lot of things.

299
00:14:28,040 --> 00:14:33,520
But then the problem with this is that almost always,

300
00:14:33,520 --> 00:14:36,280
whenever there's a migration and you

301
00:14:36,280 --> 00:14:39,280
have an alter table statement, for example, adding a field

302
00:14:39,280 --> 00:14:43,880
or changing something, I think that almost all

303
00:14:43,880 --> 00:14:48,160
alter table statements, which are the ones like use migrations,

304
00:14:48,160 --> 00:14:51,320
acquire a kind of lock that is called access,

305
00:14:51,320 --> 00:14:53,160
I think it's called access exclusive,

306
00:14:53,160 --> 00:14:55,480
on the table that is being modified.

307
00:14:55,480 --> 00:14:56,320
What does this mean?

308
00:14:56,320 --> 00:15:01,720
This means that, basically, it stops when it's running.

309
00:15:01,720 --> 00:15:03,560
No other operation, no other transaction

310
00:15:03,560 --> 00:15:05,480
can run on the same table.

311
00:15:05,480 --> 00:15:06,320
Then what happens?

312
00:15:06,320 --> 00:15:09,800
If you have an alter table that takes a long time,

313
00:15:09,800 --> 00:15:13,360
then even if it's just reading, and really,

314
00:15:13,360 --> 00:15:15,400
it was not important because it could just,

315
00:15:15,400 --> 00:15:16,600
I don't know, adding a field.

316
00:15:16,600 --> 00:15:17,840
OK, you're adding a field.

317
00:15:17,840 --> 00:15:19,640
And then you are reading from other fields.

318
00:15:19,640 --> 00:15:20,760
It's not important.

319
00:15:20,760 --> 00:15:22,360
But the table is locked.

320
00:15:22,360 --> 00:15:24,080
So nothing can read from that table.

321
00:15:24,080 --> 00:15:26,840
And then if the transaction, the alter table,

322
00:15:26,840 --> 00:15:30,120
takes a long time for any reason, then,

323
00:15:30,120 --> 00:15:33,600
and if this long time is obviously subjective,

324
00:15:33,600 --> 00:15:36,280
depending on the SLI of your application.

325
00:15:36,280 --> 00:15:37,880
If your application needs to return,

326
00:15:37,880 --> 00:15:39,520
I don't know, your Google, and you

327
00:15:39,520 --> 00:15:43,320
need to return in less than, I don't know, 100 milliseconds,

328
00:15:43,320 --> 00:15:44,760
five seconds can be a lot.

329
00:15:44,760 --> 00:15:47,080
Some other companies, OK, you can have four more downtime.

330
00:15:47,080 --> 00:15:47,560
It's OK.

331
00:15:47,560 --> 00:15:50,480
But if this is longer, and the more data you have,

332
00:15:50,480 --> 00:15:53,240
usually, if there are read writes of table and stuff

333
00:15:53,240 --> 00:15:55,240
like that, the longer the alter table takes,

334
00:15:55,240 --> 00:15:57,400
because sometimes they have to rewrite the entire table,

335
00:15:57,400 --> 00:15:58,960
and it takes a long time.

336
00:15:58,960 --> 00:16:01,160
Then you need to control for this.

337
00:16:01,160 --> 00:16:05,880
And you need to be aware of the alter table locking the tables

338
00:16:05,880 --> 00:16:07,440
even for this and for everything.

339
00:16:07,440 --> 00:16:12,680
OK, here you have a representation,

340
00:16:12,680 --> 00:16:15,000
OK, where there are some transactions.

341
00:16:15,000 --> 00:16:17,360
In data-based operations, there are always transactions.

342
00:16:17,360 --> 00:16:18,880
So there can be some transaction.

343
00:16:18,880 --> 00:16:21,520
At some point, we introduced the fifth transaction,

344
00:16:21,520 --> 00:16:24,440
which is the migration, where we are doing the migrate command

345
00:16:24,440 --> 00:16:25,760
that we saw before.

346
00:16:25,760 --> 00:16:28,040
And then there was this sixth transaction

347
00:16:28,040 --> 00:16:31,800
that could have run, perhaps, in that table.

348
00:16:31,800 --> 00:16:35,080
But the fifth one was locking the table.

349
00:16:35,080 --> 00:16:39,120
So perhaps the sixth one was super fast.

350
00:16:39,120 --> 00:16:41,640
But since the previous one started earlier,

351
00:16:41,640 --> 00:16:43,720
then now it cannot work.

352
00:16:43,720 --> 00:16:46,000
And it can take, I don't know, one minute,

353
00:16:46,000 --> 00:16:49,040
even if it was fast, because it arrived too late,

354
00:16:49,040 --> 00:16:50,960
OK, because the table is locked.

355
00:16:50,960 --> 00:16:53,560
You see.

356
00:16:53,560 --> 00:16:56,200
OK, an important thing to highlight here

357
00:16:56,200 --> 00:16:58,960
is something that is not very well known,

358
00:16:58,960 --> 00:17:02,480
is that this is a complex thing.

359
00:17:02,480 --> 00:17:05,440
And the locks on the tables, what at least Postgres does,

360
00:17:05,440 --> 00:17:08,000
it has a first in, first out.

361
00:17:08,000 --> 00:17:10,960
It has a queue of the locks to acquire.

362
00:17:10,960 --> 00:17:14,200
So in this case, I'm going to put all these things.

363
00:17:14,200 --> 00:17:16,560
OK, so it's easy to see.

364
00:17:16,560 --> 00:17:19,040
You have, for example, one long running query,

365
00:17:19,040 --> 00:17:24,200
for example, a select or account on a table, a very big one.

366
00:17:24,200 --> 00:17:27,360
And then imagine it takes, I don't know, 30 seconds to run.

367
00:17:27,360 --> 00:17:31,520
And then while it's running, imagine on the second one,

368
00:17:31,520 --> 00:17:33,080
you apply the migration.

369
00:17:33,080 --> 00:17:36,280
I say, OK, it needs to alter that table.

370
00:17:36,280 --> 00:17:39,160
But that other select query is running.

371
00:17:39,160 --> 00:17:43,320
Then when you do the alter table, what Postgres does,

372
00:17:43,320 --> 00:17:47,080
since the select is running and the alter table cannot acquire

373
00:17:47,080 --> 00:17:51,520
the lock on that table, because there's another transaction,

374
00:17:51,520 --> 00:17:53,040
it waits for the lock.

375
00:17:53,040 --> 00:17:56,800
But then if another operation comes,

376
00:17:56,800 --> 00:18:01,400
the next operation cannot either go and do any operations

377
00:18:01,400 --> 00:18:04,040
on the table, because there was a long running one.

378
00:18:04,040 --> 00:18:06,200
The third one is compatible with the first one,

379
00:18:06,200 --> 00:18:08,520
but the second one is in the middle.

380
00:18:08,520 --> 00:18:11,360
I don't know why it's like that, but I guess

381
00:18:11,360 --> 00:18:13,600
that is because otherwise, imagine that then, OK,

382
00:18:13,600 --> 00:18:16,080
we say, OK, the first one is compatible with the third one,

383
00:18:16,080 --> 00:18:17,880
then we let the third one pass.

384
00:18:17,880 --> 00:18:20,240
But then the other table, in some scenarios,

385
00:18:20,240 --> 00:18:22,840
can perhaps, if there are a lot of transactions,

386
00:18:22,840 --> 00:18:24,200
perhaps it never runs.

387
00:18:24,200 --> 00:18:25,120
So it has a queue.

388
00:18:25,120 --> 00:18:28,720
So it says, before, if this operation has not finished yet,

389
00:18:28,720 --> 00:18:30,360
the next one cannot go.

390
00:18:30,360 --> 00:18:34,200
So you have a very busy table, where there are a lot of some

391
00:18:34,200 --> 00:18:37,120
cases where the transaction that run very long,

392
00:18:37,120 --> 00:18:41,880
even if the alter table is short in time,

393
00:18:41,880 --> 00:18:45,120
the long running query is the one that is going to make

394
00:18:45,120 --> 00:18:48,560
the rest of the transactions later queue up,

395
00:18:48,560 --> 00:18:49,800
and then cost downtime.

396
00:18:49,800 --> 00:18:51,280
And this has happened to us a lot.

397
00:18:51,280 --> 00:18:52,760
And you say, why is this happening?

398
00:18:52,760 --> 00:18:55,600
Because we had some query that was like four, five seconds,

399
00:18:55,600 --> 00:18:57,960
and it was locked.

400
00:18:57,960 --> 00:19:00,160
So yeah, that's what I said.

401
00:19:00,160 --> 00:19:04,400
OK, then, Russell Thunford is to try to avoid this.

402
00:19:04,400 --> 00:19:07,280
First, the SQL migrate command that Francesco

403
00:19:07,280 --> 00:19:08,720
was talking about.

404
00:19:08,720 --> 00:19:11,040
Every time you are running a migration,

405
00:19:11,040 --> 00:19:13,320
check the SQL is being run.

406
00:19:13,320 --> 00:19:15,160
So this way, you can check documentation

407
00:19:15,160 --> 00:19:17,520
and try to understand what kind of blocks are acquired

408
00:19:17,520 --> 00:19:20,480
and try to prevent bad things happening,

409
00:19:20,480 --> 00:19:23,480
especially if they are big tables or they

410
00:19:23,480 --> 00:19:24,520
are big or busy tables.

411
00:19:24,520 --> 00:19:28,360
Because the big tables usually takes more time.

412
00:19:28,360 --> 00:19:31,040
Then the second thing is there are some operations

413
00:19:31,040 --> 00:19:33,320
that need to rewrite the whole table.

414
00:19:33,320 --> 00:19:35,480
It was the case, I will talk later,

415
00:19:35,480 --> 00:19:39,120
of Postgres when you were applying a non-nulable default,

416
00:19:39,120 --> 00:19:40,680
it had to rewrite the whole table.

417
00:19:40,680 --> 00:19:42,120
So it's a big one.

418
00:19:42,120 --> 00:19:44,040
And you have the alter during a transaction,

419
00:19:44,040 --> 00:19:47,000
then you say, OK, add this default by default.

420
00:19:47,000 --> 00:19:49,560
The value has to be three, or zero,

421
00:19:49,560 --> 00:19:51,520
in this new field that I add.

422
00:19:51,520 --> 00:19:55,400
But before, it had to rewrite the whole table,

423
00:19:55,400 --> 00:19:56,520
and it took a long time.

424
00:19:56,520 --> 00:19:59,120
It's millions of records, and it locks for that time.

425
00:19:59,120 --> 00:20:01,320
And it's terrible.

426
00:20:01,320 --> 00:20:03,160
In some cases there, you can do alter tables

427
00:20:03,160 --> 00:20:05,040
with less restrictive blocks, which is good then,

428
00:20:05,040 --> 00:20:12,520
because then you have less chances of everything blocking.

429
00:20:12,520 --> 00:20:15,920
If the other restrictive blocks are unavoidable,

430
00:20:15,920 --> 00:20:20,120
an important thing is that to run the locking things

431
00:20:20,120 --> 00:20:22,080
separated from the rest.

432
00:20:22,080 --> 00:20:23,840
For example, you have a migration.

433
00:20:23,840 --> 00:20:25,840
Later, you have to do a data migration,

434
00:20:25,840 --> 00:20:28,400
which is changing some data, run them

435
00:20:28,400 --> 00:20:29,400
in different transactions.

436
00:20:29,400 --> 00:20:29,720
Why?

437
00:20:29,720 --> 00:20:32,520
Because you put them in the same transaction,

438
00:20:32,520 --> 00:20:35,880
the lock is going to be held until the end of the transaction.

439
00:20:35,880 --> 00:20:38,640
Even if the other table was fast,

440
00:20:38,640 --> 00:20:41,680
or you can put the first one, the order doesn't matter,

441
00:20:41,680 --> 00:20:43,640
but the locks are for transaction.

442
00:20:43,640 --> 00:20:46,080
So then you separate them.

443
00:20:46,080 --> 00:20:47,440
You separate them.

444
00:20:47,440 --> 00:20:51,440
The stronger lock, the access-clusive lock,

445
00:20:51,440 --> 00:20:52,800
we will have for a short time, and then you

446
00:20:52,800 --> 00:20:54,160
have the long-running operation that

447
00:20:54,160 --> 00:20:55,960
is compatible with all the rest.

448
00:20:58,840 --> 00:21:01,680
And then for the last part, I think

449
00:21:01,680 --> 00:21:03,480
we have this good, because we are on time.

450
00:21:03,480 --> 00:21:06,600
I'm going to show some examples of typical operations

451
00:21:06,600 --> 00:21:09,400
where you can have downtime and hope to avoid them.

452
00:21:09,400 --> 00:21:13,040
This is the important thing, perhaps, for some people.

453
00:21:13,040 --> 00:21:17,040
That said, probably you look for this topic online.

454
00:21:17,040 --> 00:21:19,600
You will find other people talking about this

455
00:21:19,600 --> 00:21:20,920
and telling them how to avoid this.

456
00:21:20,920 --> 00:21:24,520
So probably better explain that we are explaining here.

457
00:21:24,520 --> 00:21:26,440
So yeah, yeah.

458
00:21:26,440 --> 00:21:27,720
For me, at least, we are not trying

459
00:21:27,720 --> 00:21:30,480
to show you to have an exhaustive list of all

460
00:21:30,480 --> 00:21:31,920
the possible cases.

461
00:21:31,920 --> 00:21:33,840
Just to show you the typical cases,

462
00:21:33,840 --> 00:21:35,560
then you look up online.

463
00:21:35,560 --> 00:21:38,040
You will find documentation where you have every case,

464
00:21:38,040 --> 00:21:39,560
and why, et cetera, et cetera.

465
00:21:39,560 --> 00:21:41,040
OK.

466
00:21:41,040 --> 00:21:42,240
I don't know if you can see this.

467
00:21:42,240 --> 00:21:43,160
It's not very easy.

468
00:21:43,160 --> 00:21:43,920
It's my fault.

469
00:21:43,920 --> 00:21:47,960
I don't know how to do slides that work in these things.

470
00:21:47,960 --> 00:21:48,960
Yeah.

471
00:21:48,960 --> 00:21:51,280
Adding a normal field.

472
00:21:51,280 --> 00:21:55,760
Adding a field is normally safe because at least now,

473
00:21:55,760 --> 00:21:58,480
starting with Postgres 11, even if you

474
00:21:58,480 --> 00:22:00,080
have a non-nullable default, it doesn't

475
00:22:00,080 --> 00:22:01,640
need a full rewrite on the table.

476
00:22:01,640 --> 00:22:05,240
Before, it had to do a full rewrite that took a really long

477
00:22:05,240 --> 00:22:06,800
time to run.

478
00:22:06,800 --> 00:22:10,240
So why is this?

479
00:22:10,240 --> 00:22:11,240
Because I don't know if you know,

480
00:22:11,240 --> 00:22:16,240
but Django keeps the default in the code, not in the database.

481
00:22:16,240 --> 00:22:23,720
So when you added a non-nullable field with a default,

482
00:22:23,720 --> 00:22:28,960
it had to first add the column with the default value,

483
00:22:28,960 --> 00:22:30,120
and then drop the default.

484
00:22:30,120 --> 00:22:32,880
And this adding the column with the default value

485
00:22:32,880 --> 00:22:37,640
was what was making rewrite the whole table.

486
00:22:37,640 --> 00:22:41,480
So the important thing is this second thing is already solved.

487
00:22:41,480 --> 00:22:44,000
Otherwise, you had to resort to nasty tricks.

488
00:22:44,000 --> 00:22:45,840
You can find somewhere else.

489
00:22:45,840 --> 00:22:49,160
And important thing to avoid, the first problem

490
00:22:49,160 --> 00:22:51,720
that I talked about, which was the two versions of the same

491
00:22:51,720 --> 00:22:54,480
app running at the same time, is that the new field has

492
00:22:54,480 --> 00:22:57,040
to have null equal true.

493
00:22:57,040 --> 00:22:57,320
Why?

494
00:22:57,320 --> 00:22:58,840
Because the old version of the app

495
00:22:58,840 --> 00:23:02,480
will try to write in that model and say, OK, put this data.

496
00:23:02,480 --> 00:23:04,560
And obviously, there's a field that is missing,

497
00:23:04,560 --> 00:23:05,640
and then it will fail.

498
00:23:05,640 --> 00:23:10,200
So OK, this file constraint, this field cannot be null,

499
00:23:10,200 --> 00:23:11,200
and you are making it null.

500
00:23:11,200 --> 00:23:12,240
OK, it's going to fail.

501
00:23:12,240 --> 00:23:15,240
So nullable, you can make another migration later

502
00:23:15,240 --> 00:23:16,600
to make it nullable.

503
00:23:16,600 --> 00:23:19,520
But nullable and the other issue, it's OK.

504
00:23:19,520 --> 00:23:22,320
Forget about it.

505
00:23:22,320 --> 00:23:26,320
Adding fields, foreign keys, when you have foreign keys,

506
00:23:26,320 --> 00:23:31,000
it needs to acquire a specific kind of lock in the table

507
00:23:31,000 --> 00:23:33,320
that you were adding the key and the other table,

508
00:23:33,320 --> 00:23:37,840
because it needs to check that you know how foreign keys work.

509
00:23:37,840 --> 00:23:41,920
The version in the first, the number in the first table

510
00:23:41,920 --> 00:23:43,760
has too much, and only in the second table.

511
00:23:43,760 --> 00:23:45,360
Otherwise, there's an inconsistency.

512
00:23:45,360 --> 00:23:47,840
That's the basic thing.

513
00:23:47,840 --> 00:23:56,000
So if it's a new field and it was not referencing,

514
00:23:56,000 --> 00:23:59,120
if it was not a normal field that you added a foreign key later,

515
00:23:59,120 --> 00:24:00,680
usually it's empty.

516
00:24:00,680 --> 00:24:03,120
So it doesn't have to check this constraint

517
00:24:03,120 --> 00:24:04,000
on all the values.

518
00:24:04,000 --> 00:24:05,320
So it's usually very fast.

519
00:24:05,320 --> 00:24:06,560
So you don't need to do anything.

520
00:24:06,560 --> 00:24:09,280
But if you need to turn up, imagine

521
00:24:09,280 --> 00:24:11,720
you have a normal before an integer field,

522
00:24:11,720 --> 00:24:13,600
and then you turn into a foreign key,

523
00:24:13,600 --> 00:24:16,240
then you need to do a specific trick that we list there.

524
00:24:16,240 --> 00:24:18,400
Basically, it's creating the foreign key,

525
00:24:18,400 --> 00:24:21,200
but without validating it, and then later validating it

526
00:24:21,200 --> 00:24:22,400
in a different transaction.

527
00:24:22,400 --> 00:24:24,840
So you can run both things at the same time.

528
00:24:24,840 --> 00:24:27,880
And as I put there, that is a fast operation.

529
00:24:27,880 --> 00:24:30,120
But remember the issue with the long-running transaction.

530
00:24:30,120 --> 00:24:32,600
If you're adding, might you have a table that has

531
00:24:32,600 --> 00:24:34,560
some long-running transaction, and then you

532
00:24:34,560 --> 00:24:37,520
add a foreign key to it, then the problem you will have

533
00:24:37,520 --> 00:24:40,160
is that it will hold this lock, and there will be,

534
00:24:40,160 --> 00:24:43,280
you cannot do updates on that table

535
00:24:43,280 --> 00:24:48,160
until the long transaction ends, finishes running.

536
00:24:48,160 --> 00:24:49,840
Five minutes, good.

537
00:24:49,840 --> 00:24:52,720
Adding models is very, don't worry,

538
00:24:52,720 --> 00:24:54,000
it's the same with the foreign key.

539
00:24:54,000 --> 00:24:56,800
If there are long-running transactions

540
00:24:56,800 --> 00:24:58,960
if you are adding foreign keys to a table,

541
00:24:58,960 --> 00:25:00,200
otherwise it's a new model.

542
00:25:00,200 --> 00:25:02,080
You are not really changing anything,

543
00:25:02,080 --> 00:25:05,400
just adding a new model.

544
00:25:05,400 --> 00:25:10,360
Renaming field, usually you should try to avoid that.

545
00:25:10,360 --> 00:25:14,280
If the column name in the database is not important,

546
00:25:14,280 --> 00:25:16,640
Django has a mechanism to say, OK, perhaps

547
00:25:16,640 --> 00:25:20,240
you want to rename it just to make it more clear for other

548
00:25:20,240 --> 00:25:21,000
people.

549
00:25:21,000 --> 00:25:24,400
You can just say, OK, I changed the name of the field

550
00:25:24,400 --> 00:25:27,480
in Python, but the database name is another one.

551
00:25:27,480 --> 00:25:28,960
So you can do this.

552
00:25:28,960 --> 00:25:34,080
But if you really want to change the column in the database,

553
00:25:34,080 --> 00:25:36,040
then you have to do a lot of nasty things

554
00:25:36,040 --> 00:25:37,520
that are right here.

555
00:25:37,520 --> 00:25:39,240
You need to create another field.

556
00:25:39,240 --> 00:25:41,880
If you don't want on time, you need to create another field,

557
00:25:41,880 --> 00:25:44,080
update both, do some data migration

558
00:25:44,080 --> 00:25:47,600
so you get all the old values into the both fields

559
00:25:47,600 --> 00:25:49,440
at the same time, and then delete the old one.

560
00:25:49,440 --> 00:25:51,360
Because otherwise, we have this issue

561
00:25:51,360 --> 00:25:56,440
with adding fields that are, if they cannot be nulled,

562
00:25:56,440 --> 00:25:58,800
then you have these kind of issues.

563
00:25:58,800 --> 00:26:00,520
You cannot just change it directly,

564
00:26:00,520 --> 00:26:03,720
because then it will try to write in the old one,

565
00:26:03,720 --> 00:26:05,280
and then it won't work.

566
00:26:05,280 --> 00:26:06,840
The previous version of the app.

567
00:26:06,840 --> 00:26:11,240
So this is how you do it.

568
00:26:11,240 --> 00:26:12,920
Changing attributes in a foreign key.

569
00:26:12,920 --> 00:26:17,040
This is something that hit us hard sometimes,

570
00:26:17,040 --> 00:26:18,080
at least in the past.

571
00:26:18,080 --> 00:26:21,520
Django, every time you did any change at all

572
00:26:21,520 --> 00:26:23,200
in a field containing a foreign key,

573
00:26:23,200 --> 00:26:27,040
it was dropping the foreign key and recreating it again.

574
00:26:27,040 --> 00:26:31,800
Of course, if this is a foreign key that references two big

575
00:26:31,800 --> 00:26:35,120
tables, it needs to check the constraint in both tables

576
00:26:35,120 --> 00:26:37,040
that are being referenced.

577
00:26:37,040 --> 00:26:39,640
And as I said, to validate this foreign key constraint,

578
00:26:39,640 --> 00:26:42,560
it takes a long time, and it was like blocking everything

579
00:26:42,560 --> 00:26:43,120
there.

580
00:26:43,120 --> 00:26:45,360
So this was a big issue.

581
00:26:45,360 --> 00:26:49,560
It was improved a bit in Django 3.2, where they added,

582
00:26:49,560 --> 00:26:54,240
where if you are changing some stuff in the field,

583
00:26:54,240 --> 00:26:56,840
that doesn't really change the database.

584
00:26:56,840 --> 00:26:58,880
Nothing is done, but for some other things,

585
00:26:58,880 --> 00:27:01,160
like something that happened to us,

586
00:27:01,160 --> 00:27:04,560
you had a field that was not nulled all before,

587
00:27:04,560 --> 00:27:08,600
and you make it nullable, and it was still dropping the foreign

588
00:27:08,600 --> 00:27:11,720
key and recreating it with the same issues as before.

589
00:27:11,720 --> 00:27:15,240
You can see there, Django provides a way to say, OK,

590
00:27:15,240 --> 00:27:18,560
the model changes are this, but don't do any operation.

591
00:27:18,560 --> 00:27:21,280
For example, it's called Migrations Rule

592
00:27:21,280 --> 00:27:23,480
SQL or Migrations Separate Database and State,

593
00:27:23,480 --> 00:27:25,640
where you can see, where you can say, OK, the model changes

594
00:27:25,640 --> 00:27:29,360
like this, but I'm telling you which SQL operations I want

595
00:27:29,360 --> 00:27:33,120
to run in order to talk about Django running things on its own.

596
00:27:33,120 --> 00:27:34,600
It's really nice.

597
00:27:34,600 --> 00:27:36,480
Indexes.

598
00:27:36,480 --> 00:27:41,200
Also, when you add indexes, what happens?

599
00:27:41,200 --> 00:27:43,400
Postgres by default, when you're creating an index on a field,

600
00:27:43,400 --> 00:27:45,800
OK, let's add index, because the data will be faster,

601
00:27:45,800 --> 00:27:48,520
because we have this really big table, where, of course,

602
00:27:48,520 --> 00:27:51,280
we need to run a query and search for things really fast.

603
00:27:51,280 --> 00:27:52,280
Let's create the index.

604
00:27:52,280 --> 00:27:53,160
Good, nice.

605
00:27:53,160 --> 00:27:56,640
But when you create the index, it block writes on the table,

606
00:27:56,640 --> 00:27:58,600
because the way it computes the index,

607
00:27:58,600 --> 00:28:02,920
it needs, OK, you change the values of the table, of course,

608
00:28:02,920 --> 00:28:05,360
something is going to be wrong with the index.

609
00:28:05,360 --> 00:28:08,480
Then you need, instead of doing the default,

610
00:28:08,480 --> 00:28:11,400
Django added an operation that it can be done in progress,

611
00:28:11,400 --> 00:28:14,280
adding index concurrently that doesn't block updates,

612
00:28:14,280 --> 00:28:14,960
basically.

613
00:28:14,960 --> 00:28:18,680
And dropping should be fast, except in the case

614
00:28:18,680 --> 00:28:21,000
of other online transactions.

615
00:28:21,000 --> 00:28:26,120
OK, delete fields.

616
00:28:26,120 --> 00:28:29,200
This is a very complicated thing.

617
00:28:29,200 --> 00:28:32,240
I don't think I have a lot of time, like two minutes.

618
00:28:32,240 --> 00:28:34,440
Basically, I wrote here the operations

619
00:28:34,440 --> 00:28:35,280
that you need to do.

620
00:28:35,280 --> 00:28:36,760
We did this multiple times.

621
00:28:36,760 --> 00:28:40,520
It's very painful, because of the backwards compatibility.

622
00:28:40,520 --> 00:28:42,320
If you cannot just delete it, because obviously,

623
00:28:42,320 --> 00:28:45,560
the previous app will try to select those fields that

624
00:28:45,560 --> 00:28:47,120
were existing in the previous app.

625
00:28:47,120 --> 00:28:50,520
So you need to do all these things.

626
00:28:50,520 --> 00:28:52,880
First, OK, it's nullable, so I don't write it anymore.

627
00:28:52,880 --> 00:28:54,920
Don't use it in the code.

628
00:28:54,920 --> 00:28:57,920
Then you delete the field in the model,

629
00:28:57,920 --> 00:29:00,680
deploy a new version that is not using this field at all.

630
00:29:00,680 --> 00:29:01,960
Why wait until?

631
00:29:01,960 --> 00:29:03,200
This is fully deployed.

632
00:29:03,200 --> 00:29:05,040
And then when you have the new code that

633
00:29:05,040 --> 00:29:08,600
doesn't use this field at all anymore, then you delete it.

634
00:29:08,600 --> 00:29:11,040
But you need to run the migration after you

635
00:29:11,040 --> 00:29:16,000
deployed the new version that doesn't use the field,

636
00:29:16,000 --> 00:29:16,920
is fully deployed.

637
00:29:16,920 --> 00:29:18,360
Because otherwise, the previous version

638
00:29:18,360 --> 00:29:19,320
will try to select it.

639
00:29:19,320 --> 00:29:23,400
Because Django, when you query for a model,

640
00:29:23,400 --> 00:29:26,800
it tries to get all the fields of the model by default.

641
00:29:26,800 --> 00:29:29,400
So it will try to get the field that doesn't exist anymore.

642
00:29:29,400 --> 00:29:31,560
So you need to delete it from the model, deploy,

643
00:29:31,560 --> 00:29:33,440
and then run the migration.

644
00:29:33,440 --> 00:29:36,760
And for deleting models, it's like similar thing

645
00:29:36,760 --> 00:29:40,880
that the previous slide, you need to do more or less the same.

646
00:29:40,880 --> 00:29:42,600
Like delete the usage.

647
00:29:42,600 --> 00:29:44,240
Deploy the version.

648
00:29:44,240 --> 00:29:46,760
The Python version doesn't use those fields anymore.

649
00:29:46,760 --> 00:29:49,840
And then after you have done that, then run the migration.

650
00:29:49,840 --> 00:29:53,160
You need to stop using those fields and those models

651
00:29:53,160 --> 00:29:57,480
in the code before those models and those fields

652
00:29:57,480 --> 00:30:00,120
are deleted from the database.

653
00:30:00,120 --> 00:30:01,560
And that's it.

654
00:30:01,560 --> 00:30:03,680
Some links that we use is very, of course,

655
00:30:03,680 --> 00:30:06,320
the Postgres documentation that you

656
00:30:06,320 --> 00:30:09,440
can check to understand more about logs.

657
00:30:09,440 --> 00:30:12,880
And some posts that we found useful about some company

658
00:30:12,880 --> 00:30:16,040
called Citus Data, where they explain how logs work

659
00:30:16,040 --> 00:30:19,600
and how to avoid certain situations with logs

660
00:30:19,600 --> 00:30:22,120
when you are doing changes in the schema changes

661
00:30:22,120 --> 00:30:23,400
in the database.

662
00:30:23,400 --> 00:30:25,640
And that's all.

663
00:30:25,640 --> 00:30:29,080
Other companies you have seen, we are hiring, obviously.

664
00:30:29,080 --> 00:30:32,480
You want to join or you are interested in business travel

665
00:30:32,480 --> 00:30:33,600
for your company as well.

666
00:30:33,600 --> 00:30:35,440
Talk to us.

667
00:30:35,440 --> 00:30:36,320
Yeah, and that's it.

668
00:30:36,320 --> 00:30:37,920
Thank you very much.

669
00:30:37,920 --> 00:30:38,920
Have a good day.

670
00:30:38,920 --> 00:30:59,920
Thank you.

